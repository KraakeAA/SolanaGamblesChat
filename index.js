// --- Start of Part 1 (FINAL CORRECTION - Original Constant Names Restored, All Declarations Fixed, All Original Code Included, Retains Granular Active Game Limits - WITH JACKPOT POLLER VARS INTEGRATED) ---
// index.js -  Part 1: Core Imports, Basic Setup, Global State & Utilities
//---------------------------------------------------------------------------

import 'dotenv/config';
import TelegramBot from 'node-telegram-bot-api';
import { Pool } from 'pg';
import express from 'express';
import {
    Connection,
    PublicKey,
    LAMPORTS_PER_SOL,
    Keypair,
    Transaction,
    SystemProgram,
    sendAndConfirmTransaction,
    ComputeBudgetProgram,
    SendTransactionError,
    TransactionExpiredBlockheightExceededError
} from '@solana/web3.js';
import bs58 from 'bs58';
import * as crypto from 'crypto'; // For createHash and randomBytes
import { createHash } from 'crypto';
import PQueue from 'p-queue';
import { Buffer } from 'buffer';
import bip39 from 'bip39';
import { derivePath } from 'ed25519-hd-key';
import nacl from 'tweetnacl';
import axios from 'axios';

// Assuming this path is correct relative to your project structure
import RateLimitedConnection from './lib/solana-connection.js';
import { deriveLitecoinAddress } from './lib/litecoin-payment.js';

// Helper function to stringify objects with BigInts and Functions for logging
function stringifyWithBigInt(obj) {
  return JSON.stringify(obj, (key, value) => {
    if (typeof value === 'bigint') {
      return value.toString() + 'n';
    }
    if (typeof value === 'function') {
      return `[Function: ${value.name || 'anonymous'}]`;
    }
    if (value === undefined) {
      return 'undefined_value';
    }
    return value;
  }, 2);
}

// --- Environment Variable Defaults ---
const CASINO_ENV_DEFAULTS = {
  'DB_POOL_MAX': '25',
  'DB_POOL_MIN': '5',
  'DB_IDLE_TIMEOUT': '30000',
  'DB_CONN_TIMEOUT': '5000',
  'DB_SSL': 'true',
  'DB_REJECT_UNAUTHORIZED': 'true',
  'SHUTDOWN_FAIL_TIMEOUT_MS': '10000',
  'JACKPOT_CONTRIBUTION_PERCENT': '0.01',
  'MIN_BET_AMOUNT_LAMPORTS': '5000000',
  'MAX_BET_AMOUNT_LAMPORTS': '1000000000',
  'COMMAND_COOLDOWN_MS': '1500',
  'UNIFIED_OFFER_TIMEOUT_MS': '30000',
  'DIRECT_CHALLENGE_ACCEPT_TIMEOUT_MS': '45000',
  'ACTIVE_GAME_TURN_TIMEOUT_MS': '45000',
  'INSTANT_GAME_ACTION_TIMEOUT_MS': '60000',
  'DEFAULT_STARTING_BALANCE_LAMPORTS': '0',
  'TARGET_JACKPOT_SCORE': '100',
  'DICE_ESCALATOR_BUST_ON': '1',
  'DICE_21_TARGET_SCORE': '21',
  'DICE_21_BOT_STAND_SCORE': '17',
  'OU7_DICE_COUNT': '2',
  'OU7_PAYOUT_NORMAL': '1',
  'OU7_PAYOUT_SEVEN': '4',
  'DUEL_DICE_COUNT': '2',
  'LADDER_ROLL_COUNT': '5',
  'LADDER_BUST_ON': '1',
  'RULES_CALLBACK_PREFIX': 'rules_game_',
  'DEPOSIT_CALLBACK_ACTION': 'deposit_action',
  'WITHDRAW_CALLBACK_ACTION': 'withdraw_action',
  'QUICK_DEPOSIT_CALLBACK_ACTION': 'menu:quick_deposit_choice',
  'MAX_RETRY_POLLING_DELAY': '60000',
  'INITIAL_RETRY_POLLING_DELAY': '5000',
  'BOT_NAME': 'Solana Casino Royale',
  'DICE_ROLL_POLL_INTERVAL_MS': '2500',
  'DICE_ROLL_POLL_ATTEMPTS': '24',
  'MINES_DEFAULT_ROWS': '5',
  'MINES_DEFAULT_COLS': '5',
  'MINES_FALLBACK_DEFAULT_MINES': '3',
  'MINES_MIN_MINES': '1',
  'MINES_MAX_MINES_PERCENT': '0.6',
  'MINES_EDIT_THROTTLE_MS': '1200',
  'LIMIT_UNIFIED_OFFER_COINFLIP': '1',
  'LIMIT_DIRECT_CHALLENGE_COINFLIP_OFFER': '1', // For pending direct challenge offers
  'LIMIT_UNIFIED_OFFER_RPS': '1',
  'LIMIT_DIRECT_CHALLENGE_RPS_OFFER': '1',
  'LIMIT_UNIFIED_OFFER_MINES': '1',
  'LIMIT_UNIFIED_OFFER_DICE_ESCALATOR': '1',
  'LIMIT_DIRECT_CHALLENGE_DICE_ESCALATOR_OFFER': '1',
  'LIMIT_UNIFIED_OFFER_DICE_21': '1',
  'LIMIT_DIRECT_CHALLENGE_DICE_21_OFFER': '1',
  'LIMIT_UNIFIED_OFFER_DUEL': '1',
  'LIMIT_DIRECT_CHALLENGE_DUEL_OFFER': '1',
  'LIMIT_ACTIVE_GAME_COINFLIP_PVB': '1',
  'LIMIT_ACTIVE_GAME_COINFLIP_PVP_UNIFIED': '1',
  'LIMIT_ACTIVE_GAME_COINFLIP_PVP_DIRECT': '1',
  'LIMIT_ACTIVE_GAME_RPS_PVB': '1',
  'LIMIT_ACTIVE_GAME_RPS_PVP_UNIFIED': '1',
  'LIMIT_ACTIVE_GAME_RPS_PVP_DIRECT': '1',
  'LIMIT_ACTIVE_GAME_DICE_ESCALATOR_PVB': '1',
  'LIMIT_ACTIVE_GAME_DICE_ESCALATOR_PVP_UNIFIED': '1',
  'LIMIT_ACTIVE_GAME_DICE_ESCALATOR_PVP_DIRECT': '1',
  'LIMIT_ACTIVE_GAME_DICE_21_PVB': '1',
  'LIMIT_ACTIVE_GAME_DICE_21_PVP_UNIFIED': '1',
  'LIMIT_ACTIVE_GAME_DICE_21_PVP_DIRECT': '1',
  'LIMIT_ACTIVE_GAME_DUEL_PVB': '1',
  'LIMIT_ACTIVE_GAME_DUEL_PVP_UNIFIED': '1',
  'LIMIT_ACTIVE_GAME_DUEL_PVP_DIRECT': '1',
  'LIMIT_ACTIVE_GAME_MINES': '1',
  'LIMIT_ACTIVE_GAME_OVER_UNDER_7': '1',
  'LIMIT_ACTIVE_GAME_LADDER': '1',
  'LIMIT_ACTIVE_GAME_SLOT_FRENZY': '1',
  'LIMIT_ACTIVE_GAME_LUCKY_SUM': '1',
  'JACKPOT_SESSION_POLL_INTERVAL_MS_MAINBOT': '7000', // Default for MainBot's Dice Escalator jackpot session poller
};

const PAYMENT_ENV_DEFAULTS = {
  'SOLANA_RPC_URL': 'https://api.mainnet-beta.solana.com/',
  'RPC_URLS': '',
  'DEPOSIT_ADDRESS_EXPIRY_MINUTES': '60',
  'DEPOSIT_CONFIRMATIONS': 'confirmed',
  'WITHDRAWAL_FEE_LAMPORTS': '10000',
  'MIN_WITHDRAWAL_USD': '50.00',
  'PAYOUT_BASE_PRIORITY_FEE_MICROLAMPORTS': '10000',
  'PAYOUT_MAX_PRIORITY_FEE_MICROLAMPORTS': '1000000',
  'PAYOUT_COMPUTE_UNIT_LIMIT': '30000',
  'PAYOUT_JOB_RETRIES': '3',
  'PAYOUT_JOB_RETRY_DELAY_MS': '7000',
  'SWEEP_INTERVAL_MS': '300000',
  'SWEEP_BATCH_SIZE': '15',
  'SWEEP_FEE_BUFFER_LAMPORTS': '50000',
  'SWEEP_COMPUTE_UNIT_LIMIT': '30000',
  'SWEEP_PRIORITY_FEE_MICROLAMPORTS': '5000',
  'SWEEP_ADDRESS_DELAY_MS': '1500',
  'SWEEP_RETRY_ATTEMPTS': '2',
  'SWEEP_RETRY_DELAY_MS': '10000',
  'RPC_MAX_CONCURRENT': '10',
  'RPC_RETRY_BASE_DELAY': '750',
  'RPC_MAX_RETRIES': '4',
  'RPC_RATE_LIMIT_COOLOFF': '3000',
  'RPC_RETRY_MAX_DELAY': '25000',
  'RPC_RETRY_JITTER': '0.3',
  'RPC_COMMITMENT': 'confirmed',
  'PAYOUT_QUEUE_CONCURRENCY': '4',
  'PAYOUT_QUEUE_TIMEOUT_MS': '90000',
  'DEPOSIT_PROCESS_QUEUE_CONCURRENCY': '5',
  'DEPOSIT_PROCESS_QUEUE_TIMEOUT_MS': '45000',
  'TELEGRAM_SEND_QUEUE_CONCURRENCY': '1',
  'TELEGRAM_SEND_QUEUE_INTERVAL_MS': '1050',
  'TELEGRAM_SEND_QUEUE_INTERVAL_CAP': '1',
  'DEPOSIT_MONITOR_INTERVAL_MS': '15000',
  'DEPOSIT_MONITOR_ADDRESS_BATCH_SIZE': '75',
  'DEPOSIT_MONITOR_SIGNATURE_FETCH_LIMIT': '15',
  'WALLET_CACHE_TTL_MS': (15 * 60 * 1000).toString(),
  'DEPOSIT_ADDR_CACHE_TTL_MS': (parseInt(CASINO_ENV_DEFAULTS.DEPOSIT_ADDRESS_EXPIRY_MINUTES, 10) * 60 * 1000 + 5 * 60 * 1000).toString(),
  'MAX_PROCESSED_TX_CACHE': '10000',
  'INIT_DELAY_MS': '7000',
  'ENABLE_PAYMENT_WEBHOOKS': 'false',
  'PAYMENT_WEBHOOK_PORT': '3000',
  'PAYMENT_WEBHOOK_PATH': '/webhook/solana-payments',
  'SOL_PRICE_API_URL': 'https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd',
  'LTC_PRICE_API_URL': 'https://api.coingecko.com/api/v3/simple/price?ids=litecoin&vs_currencies=usd',
  'SOL_USD_PRICE_CACHE_TTL_MS': (60 * 60 * 1000).toString(),
  'LTC_USD_PRICE_CACHE_TTL_MS': (60 * 60 * 1000).toString(),
  'MIN_BET_USD': '1.00',
  'MAX_BET_USD': '100.00',
};

const tempOptionalDefaults = { ...CASINO_ENV_DEFAULTS, ...PAYMENT_ENV_DEFAULTS };
if (!tempOptionalDefaults.hasOwnProperty('MIN_WITHDRAWAL_LAMPORTS')) {
    tempOptionalDefaults['MIN_WITHDRAWAL_LAMPORTS'] = '0';
}
if (!tempOptionalDefaults.hasOwnProperty('JOIN_GAME_TIMEOUT_MS')) {
    tempOptionalDefaults['JOIN_GAME_TIMEOUT_MS'] = '120000';
}
if (!tempOptionalDefaults.hasOwnProperty('PVP_TURN_TIMEOUT_MS')) {
    tempOptionalDefaults['PVP_TURN_TIMEOUT_MS'] = '60000';
}

const OPTIONAL_ENV_DEFAULTS = tempOptionalDefaults;

Object.entries(OPTIONAL_ENV_DEFAULTS).forEach(([key, defaultValue]) => {
  if (process.env[key] === undefined) {
    process.env[key] = defaultValue;
  }
});

// --- Core Configuration Constants ---
const BOT_TOKEN = process.env.BOT_TOKEN;
const ADMIN_USER_ID = process.env.ADMIN_USER_ID;
const DATABASE_URL = process.env.DATABASE_URL;
const BOT_NAME = process.env.BOT_NAME; // Original global constant

// Payment System Keys & Seeds
const DEPOSIT_MASTER_SEED_PHRASE = process.env.DEPOSIT_MASTER_SEED_PHRASE;
const MAIN_BOT_PRIVATE_KEY_BS58 = process.env.MAIN_BOT_PRIVATE_KEY;
const REFERRAL_PAYOUT_PRIVATE_KEY_BS58 = process.env.REFERRAL_PAYOUT_PRIVATE_KEY;

// --- GAME_IDS Constant (UPDATED for Granular Active Game Tracking & Distinct Offer Keys) ---
const GAME_IDS = {
    COINFLIP: 'coinflip',
    COINFLIP_UNIFIED_OFFER: 'coinflip_unified_offer', // For pending unified offers
    COINFLIP_DIRECT_CHALLENGE_OFFER: 'coinflip_direct_challenge_offer', // For pending direct challenge offers
    COINFLIP_PVB: 'coinflip_pvb',
    COINFLIP_PVP: 'coinflip_pvp', // Represents active PvP from Direct Challenge
    COINFLIP_PVP_FROM_UNIFIED: 'coinflip_pvp_from_unified',

    RPS: 'rps',
    RPS_UNIFIED_OFFER: 'rps_unified_offer',
    RPS_DIRECT_CHALLENGE_OFFER: 'rps_direct_challenge_offer',
    RPS_PVB: 'rps_pvb',
    RPS_PVP: 'rps_pvp',
    RPS_PVP_FROM_UNIFIED: 'rps_pvp_from_unified',

    DICE_ESCALATOR: 'dice_escalator',
    DICE_ESCALATOR_UNIFIED_OFFER: 'dice_escalator_unified_offer',
    DICE_ESCALATOR_DIRECT_CHALLENGE_OFFER: 'dice_escalator_direct_challenge_offer',
    DICE_ESCALATOR_PVB: 'dice_escalator_pvb',
    DICE_ESCALATOR_PVP: 'dice_escalator_pvp',
    DICE_ESCALATOR_PVP_FROM_UNIFIED: 'dice_escalator_pvp_from_unified',

    DICE_21: 'dice21',
    DICE_21_UNIFIED_OFFER: 'dice21_unified_offer',
    DICE_21_DIRECT_CHALLENGE_OFFER: 'dice21_direct_challenge_offer',
    DICE_21_PVP: 'dice21_pvp',
    DICE_21_PVP_FROM_UNIFIED: 'dice21_pvp_from_unified',

    DUEL: 'duel',
    DUEL_UNIFIED_OFFER: 'duel_unified_offer',
    DUEL_DIRECT_CHALLENGE_OFFER: 'duel_direct_challenge_offer',
    DUEL_PVB: 'duel_pvb',
    DUEL_PVP: 'duel_pvp',
    DUEL_PVP_FROM_UNIFIED: 'duel_pvp_from_unified',

    OVER_UNDER_7: 'ou7',
    LADDER: 'ladder',
    SEVEN_OUT: 'sevenout',
    SLOT_FRENZY: 'slotfrenzy',
    MINES: 'mines',
    MINES_OFFER: 'mines_offer',

    DIRECT_PVP_CHALLENGE: 'direct_pvp_challenge',
};

// Game Specific Constants
const DICE_21_TARGET_SCORE = parseInt(process.env.DICE_21_TARGET_SCORE, 10);
const DICE_21_BOT_STAND_SCORE = parseInt(process.env.DICE_21_BOT_STAND_SCORE, 10);
const DICE_ROLL_POLLING_MAX_ATTEMPTS = parseInt(process.env.DICE_ROLL_POLL_ATTEMPTS, 10);
const DICE_ROLL_POLLING_INTERVAL_MS = parseInt(process.env.DICE_ROLL_POLL_INTERVAL_MS, 10);

const UNIFIED_OFFER_TIMEOUT_MS = parseInt(process.env.UNIFIED_OFFER_TIMEOUT_MS, 10);
const DIRECT_CHALLENGE_ACCEPT_TIMEOUT_MS = parseInt(process.env.DIRECT_CHALLENGE_ACCEPT_TIMEOUT_MS, 10);
const ACTIVE_GAME_TURN_TIMEOUT_MS = parseInt(process.env.ACTIVE_GAME_TURN_TIMEOUT_MS, 10);
const INSTANT_GAME_ACTION_TIMEOUT_MS = parseInt(process.env.INSTANT_GAME_ACTION_TIMEOUT_MS, 10);

const JOIN_GAME_TIMEOUT_MS_LEGACY = parseInt(process.env.JOIN_GAME_TIMEOUT_MS, 10);
const PVP_TURN_TIMEOUT_MS_LEGACY = parseInt(process.env.PVP_TURN_TIMEOUT_MS, 10);

const OU7_DICE_COUNT = parseInt(process.env.OU7_DICE_COUNT, 10);
const OU7_PAYOUT_NORMAL = parseFloat(process.env.OU7_PAYOUT_NORMAL);
const OU7_PAYOUT_SEVEN = parseFloat(process.env.OU7_PAYOUT_SEVEN);
const DUEL_DICE_COUNT = parseInt(process.env.DUEL_DICE_COUNT, 10);
const LADDER_ROLL_COUNT = parseInt(process.env.LADDER_ROLL_COUNT, 10);
const LADDER_BUST_ON = parseInt(process.env.LADDER_BUST_ON, 10);
const DICE_ESCALATOR_BUST_ON = parseInt(process.env.DICE_ESCALATOR_BUST_ON, 10);

const LADDER_PAYOUTS = [
    { min: 10, max: 14, multiplier: 1, label: "Nice Climb!" },
    { min: 15, max: 19, multiplier: 2, label: "High Rungs!" },
    { min: 20, max: 24, multiplier: 5, label: "Peak Performer!" },
    { min: 25, max: 29, multiplier: 10, label: "Sky High Roller!" },
    { min: 30, max: 30, multiplier: 25, label: "Ladder Legend!" }
];

const MINES_DEFAULT_ROWS = parseInt(process.env.MINES_DEFAULT_ROWS, 10);
const MINES_DEFAULT_COLS = parseInt(process.env.MINES_DEFAULT_COLS, 10);
const MINES_FALLBACK_DEFAULT_MINES = parseInt(process.env.MINES_FALLBACK_DEFAULT_MINES, 10);
const MINES_MIN_MINES = parseInt(process.env.MINES_MIN_MINES, 10);
const MINES_MAX_MINES_PERCENT = parseFloat(process.env.MINES_MAX_MINES_PERCENT);
const MINES_EDIT_THROTTLE_MS = parseInt(process.env.MINES_EDIT_THROTTLE_MS, 10) || 1200;

const TILE_EMOJI_HIDDEN = '❓';
const TILE_EMOJI_GEM = '💎';
const TILE_EMOJI_MINE = '💣';
const TILE_EMOJI_EXPLOSION = '💥';

const MINES_DIFFICULTY_CONFIG = {
    easy: {
        rows: 5, cols: 5, mines: 3, label: "Easy (5x5, 3 Mines)", emoji: '🟢',
        multipliers: [ 0, 1.08, 1.18, 1.29, 1.42, 1.55, 1.70, 1.88, 2.08, 2.30, 2.55,
                        2.85, 3.20, 3.60, 4.05, 4.50, 5.00, 6.00, 7.50, 10.00, 15.00, 25.00, 50.00 ]
    },
    medium: {
        rows: 5, cols: 5, mines: 5, label: "Medium (5x5, 5 Mines)", emoji: '🟡',
        multipliers: [ 0, 1.12, 1.28, 1.47, 1.70, 1.98, 2.30, 2.70, 3.15, 3.70, 4.35,
                        5.10, 6.00, 7.10, 8.50, 10.50, 13.00, 16.50, 22.00, 30.00, 75.00 ]
    },
    hard:   {
        rows: 5, cols: 5, mines: 7, label: "Hard (5x5, 7 Mines)", emoji: '🔴',
        multipliers: [ 0, 1.18, 1.40, 1.68, 2.00, 2.40, 2.90, 3.50, 4.20, 5.10, 6.20,
                        7.50, 9.20, 11.50, 14.50, 18.00, 23.00, 30.00, 100.00 ]
    },
};

// --- NEW Referral System Configurations ---
const REFERRAL_QUALIFYING_BET_USD_CONST = 1.00;

const REFERRAL_INITIAL_BET_TIERS_CONFIG = [
    { upToReferrals: 10, percentage: 0.05 },
    { upToReferrals: 25, percentage: 0.10 },
    { upToReferrals: 50, percentage: 0.15 },
    { upToReferrals: 100, percentage: 0.20 },
    { upToReferrals: Infinity, percentage: 0.25 }
];

const REFERRAL_WAGER_MILESTONES_USD_CONFIG = [10, 25, 50, 100, 250, 500, 1000];

const REFERRAL_WAGER_MILESTONE_BONUS_PERCENTAGE_CONST = 0.005; // 0.5%
// --- End of NEW Referral System Configurations ---
// --- NEW Level Up Bonus System Configurations ---
const LEVEL_CONFIG = [
    // --- Bronze Tier ---
    { order_index: 1,  name: "Bronze I",     wager_threshold_usd: 50.00,    bonus_amount_usd: 0.25 },
    { order_index: 2,  name: "Bronze II",    wager_threshold_usd: 100.00,   bonus_amount_usd: 0.50 },
    { order_index: 3,  name: "Bronze III",   wager_threshold_usd: 250.00,   bonus_amount_usd: 1.00 },
    { order_index: 4,  name: "Bronze IV",    wager_threshold_usd: 500.00,   bonus_amount_usd: 2.00 },
    { order_index: 5,  name: "Bronze V",     wager_threshold_usd: 1000.00,  bonus_amount_usd: 5.00 },

    // --- Silver Tier ---
    { order_index: 6,  name: "Silver I",     wager_threshold_usd: 2000.00,  bonus_amount_usd: 10.00 },
    { order_index: 7,  name: "Silver II",    wager_threshold_usd: 4000.00,  bonus_amount_usd: 15.00 },
    { order_index: 8,  name: "Silver III",   wager_threshold_usd: 7500.00,  bonus_amount_usd: 25.00 },
    { order_index: 9,  name: "Silver IV",    wager_threshold_usd: 12500.00, bonus_amount_usd: 40.00 },
    { order_index: 10, name: "Silver V",     wager_threshold_usd: 20000.00, bonus_amount_usd: 60.00 },

    // --- Gold Tier ---
    { order_index: 11, name: "Gold I",       wager_threshold_usd: 30000.00, bonus_amount_usd: 90.00 },
    { order_index: 12, name: "Gold II",      wager_threshold_usd: 50000.00, bonus_amount_usd: 125.00 },
    { order_index: 13, name: "Gold III",     wager_threshold_usd: 75000.00, bonus_amount_usd: 175.00 },
    { order_index: 14, name: "Gold IV",      wager_threshold_usd: 100000.00,bonus_amount_usd: 250.00 },
    { order_index: 15, name: "Gold V",       wager_threshold_usd: 150000.00,bonus_amount_usd: 350.00 },

    // --- Platinum Tier ---
    { order_index: 16, name: "Platinum I",   wager_threshold_usd: 250000.00,bonus_amount_usd: 500.00 },
    { order_index: 17, name: "Platinum II",  wager_threshold_usd: 400000.00,bonus_amount_usd: 750.00 },
    { order_index: 18, name: "Platinum III", wager_threshold_usd: 600000.00,bonus_amount_usd: 1000.00 },
    { order_index: 19, name: "Platinum IV",  wager_threshold_usd: 800000.00,bonus_amount_usd: 1250.00 },
    { order_index: 20, name: "Platinum V",   wager_threshold_usd: 1000000.00,bonus_amount_usd: 1500.00 },

    // --- Diamond Tier ---
    { order_index: 21, name: "Diamond I",    wager_threshold_usd: 1500000.00,bonus_amount_usd: 2000.00 },
    { order_index: 22, name: "Diamond II",   wager_threshold_usd: 2000000.00,bonus_amount_usd: 2500.00 },
    { order_index: 23, name: "Diamond III",  wager_threshold_usd: 3000000.00,bonus_amount_usd: 3500.00 },
    { order_index: 24, name: "Diamond IV",   wager_threshold_usd: 4000000.00,bonus_amount_usd: 4500.00 },
    { order_index: 25, name: "Diamond V",    wager_threshold_usd: 5000000.00,bonus_amount_usd: 5000.00 },
    
    // --- Elite Tiers (Example) ---
    { order_index: 26, name: "Master",       wager_threshold_usd: 7500000.00, bonus_amount_usd: 7500.00 },
    { order_index: 27, name: "Grandmaster",  wager_threshold_usd: 10000000.00,bonus_amount_usd: 10000.00 },
    { order_index: 28, name: "Legend",       wager_threshold_usd: 15000000.00,bonus_amount_usd: 15000.00 },
    // Add more as needed, ensuring 'order_index' is always unique and sequential.
];
// --- End of NEW Level Up Bonus System Configurations ---

const DEFAULT_GAME_ACTIVITY_CONCURRENCY_LIMITS = {
    UNIFIED_OFFERS: { // These keys are for *pending unified offers*
        [GAME_IDS.COINFLIP]: parseInt(process.env.LIMIT_UNIFIED_OFFER_COINFLIP, 10) || 1,
        [GAME_IDS.RPS]: parseInt(process.env.LIMIT_UNIFIED_OFFER_RPS, 10) || 1,
        [GAME_IDS.MINES_OFFER]: parseInt(process.env.LIMIT_UNIFIED_OFFER_MINES, 10) || 1,
        [GAME_IDS.DICE_ESCALATOR]: parseInt(process.env.LIMIT_UNIFIED_OFFER_DICE_ESCALATOR, 10) || 1,
        [GAME_IDS.DICE_21]: parseInt(process.env.LIMIT_UNIFIED_OFFER_DICE_21, 10) || 1,
        [GAME_IDS.DUEL]: parseInt(process.env.LIMIT_UNIFIED_OFFER_DUEL, 10) || 1,
    },
    DIRECT_CHALLENGES: { // These keys are for *pending direct challenge offers*
        [GAME_IDS.COINFLIP_DIRECT_CHALLENGE_OFFER]: parseInt(process.env.LIMIT_DIRECT_CHALLENGE_COINFLIP_OFFER, 10) || 1,
        [GAME_IDS.RPS_DIRECT_CHALLENGE_OFFER]: parseInt(process.env.LIMIT_DIRECT_CHALLENGE_RPS_OFFER, 10) || 1,
        [GAME_IDS.DICE_ESCALATOR_DIRECT_CHALLENGE_OFFER]: parseInt(process.env.LIMIT_DIRECT_CHALLENGE_DICE_ESCALATOR_OFFER, 10) || 1,
        [GAME_IDS.DICE_21_DIRECT_CHALLENGE_OFFER]: parseInt(process.env.LIMIT_DIRECT_CHALLENGE_DICE_21_OFFER, 10) || 1,
        [GAME_IDS.DUEL_DIRECT_CHALLENGE_OFFER]: parseInt(process.env.LIMIT_DIRECT_CHALLENGE_DUEL_OFFER, 10) || 1,
    },
    ACTIVE_GAMES: { // These keys are for *active games*
        [GAME_IDS.COINFLIP_PVB]: parseInt(process.env.LIMIT_ACTIVE_GAME_COINFLIP_PVB, 10) || 1,
        [GAME_IDS.COINFLIP_PVP_FROM_UNIFIED]: parseInt(process.env.LIMIT_ACTIVE_GAME_COINFLIP_PVP_UNIFIED, 10) || 1,
        [GAME_IDS.COINFLIP_PVP]: parseInt(process.env.LIMIT_ACTIVE_GAME_COINFLIP_PVP_DIRECT, 10) || 1, // Active PvP from Direct

        [GAME_IDS.RPS_PVB]: parseInt(process.env.LIMIT_ACTIVE_GAME_RPS_PVB, 10) || 1,
        [GAME_IDS.RPS_PVP_FROM_UNIFIED]: parseInt(process.env.LIMIT_ACTIVE_GAME_RPS_PVP_UNIFIED, 10) || 1,
        [GAME_IDS.RPS_PVP]: parseInt(process.env.LIMIT_ACTIVE_GAME_RPS_PVP_DIRECT, 10) || 1, // Active PvP from Direct

        [GAME_IDS.DICE_ESCALATOR_PVB]: parseInt(process.env.LIMIT_ACTIVE_GAME_DICE_ESCALATOR_PVB, 10) || 1,
        [GAME_IDS.DICE_ESCALATOR_PVP_FROM_UNIFIED]: parseInt(process.env.LIMIT_ACTIVE_GAME_DICE_ESCALATOR_PVP_UNIFIED, 10) || 1,
        [GAME_IDS.DICE_ESCALATOR_PVP]: parseInt(process.env.LIMIT_ACTIVE_GAME_DICE_ESCALATOR_PVP_DIRECT, 10) || 1, // Active PvP from Direct

        [GAME_IDS.DICE_21]: parseInt(process.env.LIMIT_ACTIVE_GAME_DICE_21_PVB, 10) || 1,
        [GAME_IDS.DICE_21_PVP_FROM_UNIFIED]: parseInt(process.env.LIMIT_ACTIVE_GAME_DICE_21_PVP_UNIFIED, 10) || 1,
        [GAME_IDS.DICE_21_PVP]: parseInt(process.env.LIMIT_ACTIVE_GAME_DICE_21_PVP_DIRECT, 10) || 1, // Active PvP from Direct

        [GAME_IDS.DUEL_PVB]: parseInt(process.env.LIMIT_ACTIVE_GAME_DUEL_PVB, 10) || 1,
        [GAME_IDS.DUEL_PVP_FROM_UNIFIED]: parseInt(process.env.LIMIT_ACTIVE_GAME_DUEL_PVP_UNIFIED, 10) || 1,
        [GAME_IDS.DUEL_PVP]: parseInt(process.env.LIMIT_ACTIVE_GAME_DUEL_PVP_DIRECT, 10) || 1, // Active PvP from Direct

        [GAME_IDS.MINES]: parseInt(process.env.LIMIT_ACTIVE_GAME_MINES, 10) || 1,
        [GAME_IDS.OVER_UNDER_7]: parseInt(process.env.LIMIT_ACTIVE_GAME_OVER_UNDER_7, 10) || 1,
        [GAME_IDS.LADDER]: parseInt(process.env.LIMIT_ACTIVE_GAME_LADDER, 10) || 1,
        [GAME_IDS.SLOT_FRENZY]: parseInt(process.env.LIMIT_ACTIVE_GAME_SLOT_FRENZY, 10) || 1,
        [GAME_IDS.SEVEN_OUT]: parseInt(process.env.LIMIT_ACTIVE_GAME_LUCKY_SUM, 10) || 1,
    }
};
const GAME_ACTIVITY_LIMITS = DEFAULT_GAME_ACTIVITY_CONCURRENCY_LIMITS;

// Keypair Initializations
let MAIN_BOT_KEYPAIR = null;
if (MAIN_BOT_PRIVATE_KEY_BS58) {
    try {
        MAIN_BOT_KEYPAIR = Keypair.fromSecretKey(bs58.decode(MAIN_BOT_PRIVATE_KEY_BS58));
        console.log(`🔑 Main Bot Payout Wallet Initialized: ${MAIN_BOT_KEYPAIR.publicKey.toBase58()}`);
    } catch (e) {
        console.error("🚨 FATAL ERROR: Invalid MAIN_BOT_PRIVATE_KEY. Withdrawals and critical operations will fail.", e.message);
        process.exit(1);
    }
} else {
    console.error("🚨 FATAL ERROR: MAIN_BOT_PRIVATE_KEY is not defined. Withdrawals and critical operations will fail.");
    process.exit(1);
}

let REFERRAL_PAYOUT_KEYPAIR = null;
if (REFERRAL_PAYOUT_PRIVATE_KEY_BS58) {
    try {
        REFERRAL_PAYOUT_KEYPAIR = Keypair.fromSecretKey(bs58.decode(REFERRAL_PAYOUT_PRIVATE_KEY_BS58));
        console.log(`🔑 Referral Payout Wallet Initialized: ${REFERRAL_PAYOUT_KEYPAIR.publicKey.toBase58()}`);
    } catch (e) {
        console.warn(`⚠️ WARNING: Invalid REFERRAL_PAYOUT_PRIVATE_KEY. Falling back to main bot wallet for referral payouts. Error: ${e.message}`);
        REFERRAL_PAYOUT_KEYPAIR = null;
    }
} else {
    console.log("ℹ️ INFO: REFERRAL_PAYOUT_PRIVATE_KEY not set. Main bot wallet will be used for referral payouts.");
}
if (!REFERRAL_PAYOUT_KEYPAIR) {
    REFERRAL_PAYOUT_KEYPAIR = MAIN_BOT_KEYPAIR;
}

// RPC Endpoint Configuration
const RPC_URLS_LIST_FROM_ENV = (process.env.RPC_URLS || '')
    .split(',')
    .map(u => u.trim())
    .filter(u => u && (u.startsWith('http://') || u.startsWith('https://')));
const SINGLE_MAINNET_RPC_FROM_ENV = process.env.SOLANA_RPC_URL || null;
let combinedRpcEndpointsForConnection = [...RPC_URLS_LIST_FROM_ENV];
if (SINGLE_MAINNET_RPC_FROM_ENV && !combinedRpcEndpointsForConnection.some(url => url.startsWith(SINGLE_MAINNET_RPC_FROM_ENV.split('?')[0]))) {
    combinedRpcEndpointsForConnection.push(SINGLE_MAINNET_RPC_FROM_ENV);
}
if (combinedRpcEndpointsForConnection.length === 0) {
    console.warn("⚠️ WARNING: No RPC URLs provided (RPC_URLS, SOLANA_RPC_URL). Using default public Solana RPC as a last resort.");
    combinedRpcEndpointsForConnection.push('https://api.mainnet-beta.solana.com/');
}

// More Constants derived from ENV (using original names from process.env)
const SHUTDOWN_FAIL_TIMEOUT_MS = parseInt(process.env.SHUTDOWN_FAIL_TIMEOUT_MS, 10);
const MAX_RETRY_POLLING_DELAY = parseInt(process.env.MAX_RETRY_POLLING_DELAY, 10);
const INITIAL_RETRY_POLLING_DELAY = parseInt(process.env.INITIAL_RETRY_POLLING_DELAY, 10);
const JACKPOT_CONTRIBUTION_PERCENT = parseFloat(process.env.JACKPOT_CONTRIBUTION_PERCENT);
const MAIN_JACKPOT_ID = 'dice_escalator_main_pvb';
const TARGET_JACKPOT_SCORE = parseInt(process.env.TARGET_JACKPOT_SCORE, 10); // Reverted from _CONST

const MIN_BET_AMOUNT_LAMPORTS_config = BigInt(process.env.MIN_BET_AMOUNT_LAMPORTS);
const MAX_BET_AMOUNT_LAMPORTS_config = BigInt(process.env.MAX_BET_AMOUNT_LAMPORTS);
const MIN_BET_USD_val = parseFloat(process.env.MIN_BET_USD);
const MAX_BET_USD_val = parseFloat(process.env.MAX_BET_USD);

const COMMAND_COOLDOWN_MS = parseInt(process.env.COMMAND_COOLDOWN_MS, 10);
const DEFAULT_STARTING_BALANCE_LAMPORTS = BigInt(process.env.DEFAULT_STARTING_BALANCE_LAMPORTS);
const RULES_CALLBACK_PREFIX_CONST = process.env.RULES_CALLBACK_PREFIX; // MODIFIED
const DEPOSIT_CALLBACK_ACTION_CONST = process.env.DEPOSIT_CALLBACK_ACTION; // MODIFIED
const WITHDRAW_CALLBACK_ACTION_CONST = process.env.WITHDRAW_CALLBACK_ACTION; // MODIFIED
const QUICK_DEPOSIT_CALLBACK_ACTION_CONST = process.env.QUICK_DEPOSIT_CALLBACK_ACTION; // MODIFIED

// Dice Escalator Jackpot Session Poller Interval (for MainBot)
const JACKPOT_SESSION_POLL_INTERVAL_MS = parseInt(process.env.JACKPOT_SESSION_POLL_INTERVAL_MS_MAINBOT, 10);
if (isNaN(JACKPOT_SESSION_POLL_INTERVAL_MS) || JACKPOT_SESSION_POLL_INTERVAL_MS < 2000) {
    // This console.warn will use the default if the env var is bad or missing, as per CASINO_ENV_DEFAULTS handling.
    // The actual value of JACKPOT_SESSION_POLL_INTERVAL_MS will be the parsed default if this path is taken.
    // If you want to force exit or have a hardcoded fallback *here* different from the default, you can add it.
    // For now, relying on the CASINO_ENV_DEFAULTS mechanism.
    console.warn(`⚠️ WARNING: JACKPOT_SESSION_POLL_INTERVAL_MS_MAINBOT ('${process.env.JACKPOT_SESSION_POLL_INTERVAL_MS_MAINBOT}') is invalid or too low after parsing. Check .env or defaults. Using effective value: ${JACKPOT_SESSION_POLL_INTERVAL_MS}ms.`);
    // If after defaults and parsing, it's still bad (e.g., default was bad), you might force a safe value:
    // if (isNaN(JACKPOT_SESSION_POLL_INTERVAL_MS) || JACKPOT_SESSION_POLL_INTERVAL_MS < 2000) JACKPOT_SESSION_POLL_INTERVAL_MS = 7000;
}


const SOL_DECIMALS = 9;
const DEPOSIT_ADDRESS_EXPIRY_MINUTES = parseInt(process.env.DEPOSIT_ADDRESS_EXPIRY_MINUTES, 10);
const DEPOSIT_ADDRESS_EXPIRY_MS = DEPOSIT_ADDRESS_EXPIRY_MINUTES * 60 * 1000;
const DEPOSIT_CONFIRMATION_LEVEL = process.env.DEPOSIT_CONFIRMATIONS?.toLowerCase() || 'confirmed';
const WITHDRAWAL_FEE_LAMPORTS = BigInt(process.env.WITHDRAWAL_FEE_LAMPORTS);

const MIN_WITHDRAWAL_LAMPORTS_LEGACY_REFERENCE = BigInt(process.env.MIN_WITHDRAWAL_LAMPORTS || '0');
const MIN_WITHDRAWAL_USD_val = parseFloat(process.env.MIN_WITHDRAWAL_USD);

const LITOSHIS_PER_LTC = 100000000;
const LTC_DEPOSIT_CONFIRMATIONS = parseInt(process.env.LTC_DEPOSIT_CONFIRMATIONS, 10) || 6;
const LTC_USD_PRICE_CACHE_TTL_MS = parseInt(process.env.LTC_USD_PRICE_CACHE_TTL_MS, 10) || 300000;
const LITECOIN_API_BASE_URL = `https://api.blockcypher.com/v1/ltc/main`;
const LITECOIN_API_TOKEN = process.env.BLOCKCYPHER_API_TOKEN;

// Critical Configuration Validations
if (!BOT_TOKEN) { console.error("🚨 FATAL ERROR: BOT_TOKEN is not defined. Bot cannot start."); process.exit(1); }
if (!DATABASE_URL) { console.error("🚨 FATAL ERROR: DATABASE_URL is not defined. Cannot connect to PostgreSQL."); process.exit(1); }
if (!DEPOSIT_MASTER_SEED_PHRASE) { console.error("🚨 FATAL ERROR: DEPOSIT_MASTER_SEED_PHRASE is not defined. Payment system cannot generate deposit addresses."); process.exit(1); }
if (isNaN(UNIFIED_OFFER_TIMEOUT_MS) || UNIFIED_OFFER_TIMEOUT_MS <= 0) { console.error(`🚨 FATAL ERROR: UNIFIED_OFFER_TIMEOUT_MS ('${process.env.UNIFIED_OFFER_TIMEOUT_MS}') must be a positive number.`); process.exit(1); }
if (isNaN(DIRECT_CHALLENGE_ACCEPT_TIMEOUT_MS) || DIRECT_CHALLENGE_ACCEPT_TIMEOUT_MS <= 0) { console.error(`🚨 FATAL ERROR: DIRECT_CHALLENGE_ACCEPT_TIMEOUT_MS ('${process.env.DIRECT_CHALLENGE_ACCEPT_TIMEOUT_MS}') must be a positive number.`); process.exit(1); }
if (isNaN(ACTIVE_GAME_TURN_TIMEOUT_MS) || ACTIVE_GAME_TURN_TIMEOUT_MS <= 0) { console.error(`🚨 FATAL ERROR: ACTIVE_GAME_TURN_TIMEOUT_MS ('${process.env.ACTIVE_GAME_TURN_TIMEOUT_MS}') must be a positive number.`); process.exit(1); }
if (isNaN(INSTANT_GAME_ACTION_TIMEOUT_MS) || INSTANT_GAME_ACTION_TIMEOUT_MS <= 0) { console.error(`🚨 FATAL ERROR: INSTANT_GAME_ACTION_TIMEOUT_MS ('${process.env.INSTANT_GAME_ACTION_TIMEOUT_MS}') must be a positive number.`); process.exit(1); }
if (isNaN(PVP_TURN_TIMEOUT_MS_LEGACY) || PVP_TURN_TIMEOUT_MS_LEGACY <= 0) { console.warn(`⚠️ WARNING: Legacy PVP_TURN_TIMEOUT_MS ('${process.env.PVP_TURN_TIMEOUT_MS}') is not a valid positive number. Logic has shifted to ACTIVE_GAME_TURN_TIMEOUT_MS.`);}
if (isNaN(JOIN_GAME_TIMEOUT_MS_LEGACY) || JOIN_GAME_TIMEOUT_MS_LEGACY <= 0) { console.warn(`⚠️ WARNING: Legacy JOIN_GAME_TIMEOUT_MS ('${process.env.JOIN_GAME_TIMEOUT_MS}') is not a valid positive number. Logic has shifted to specific offer timeouts.`);}
const criticalGameScoresCheckFull = { TARGET_JACKPOT_SCORE, DICE_21_TARGET_SCORE, DICE_21_BOT_STAND_SCORE, OU7_DICE_COUNT, DUEL_DICE_COUNT, LADDER_ROLL_COUNT, LADDER_BUST_ON, DICE_ESCALATOR_BUST_ON };
for (const [key, value] of Object.entries(criticalGameScoresCheckFull)) { if (isNaN(value) || value <=0) { console.error(`🚨 FATAL ERROR: Game score/parameter '${key}' ('${value}') is not a valid positive number.`); process.exit(1);}}
if (isNaN(MIN_BET_USD_val) || MIN_BET_USD_val <= 0) { console.error(`🚨 FATAL ERROR: MIN_BET_USD ('${process.env.MIN_BET_USD}') must be a positive number.`); process.exit(1);}
if (isNaN(MAX_BET_USD_val) || MAX_BET_USD_val < MIN_BET_USD_val) { console.error(`🚨 FATAL ERROR: MAX_BET_USD ('${process.env.MAX_BET_USD}') must be >= MIN_BET_USD and be a number.`); process.exit(1);}
if (isNaN(MIN_WITHDRAWAL_USD_val) || MIN_WITHDRAWAL_USD_val <= 0) { console.error(`🚨 FATAL ERROR: MIN_WITHDRAWAL_USD ('${process.env.MIN_WITHDRAWAL_USD}') must be a positive number. Bot cannot start.`); process.exit(1);}
if (MIN_WITHDRAWAL_LAMPORTS_LEGACY_REFERENCE < 0n) { console.warn(`⚠️ WARNING: MIN_WITHDRAWAL_LAMPORTS ('${process.env.MIN_WITHDRAWAL_LAMPORTS}') is negative. This value is legacy for withdrawal minimums but should ideally be non-negative if set.`);}
if (MIN_BET_AMOUNT_LAMPORTS_config < 1n || isNaN(Number(MIN_BET_AMOUNT_LAMPORTS_config))) { console.error(`🚨 FATAL ERROR: MIN_BET_AMOUNT_LAMPORTS ('${MIN_BET_AMOUNT_LAMPORTS_config}') must be a positive number.`); process.exit(1);}
if (MAX_BET_AMOUNT_LAMPORTS_config < MIN_BET_AMOUNT_LAMPORTS_config || isNaN(Number(MAX_BET_AMOUNT_LAMPORTS_config))) { console.error(`🚨 FATAL ERROR: MAX_BET_AMOUNT_LAMPORTS ('${MAX_BET_AMOUNT_LAMPORTS_config}') must be >= MIN_BET_AMOUNT_LAMPORTS and be a number.`); process.exit(1);}
if (isNaN(JACKPOT_CONTRIBUTION_PERCENT) || JACKPOT_CONTRIBUTION_PERCENT < 0 || JACKPOT_CONTRIBUTION_PERCENT >= 1) { console.error(`🚨 FATAL ERROR: JACKPOT_CONTRIBUTION_PERCENT ('${process.env.JACKPOT_CONTRIBUTION_PERCENT}') must be a number between 0 (inclusive) and 1 (exclusive).`); process.exit(1);}
if (isNaN(OU7_PAYOUT_NORMAL) || OU7_PAYOUT_NORMAL < 0) { console.error(`🚨 FATAL ERROR: OU7_PAYOUT_NORMAL must be a non-negative number.`); process.exit(1);}
if (isNaN(OU7_PAYOUT_SEVEN) || OU7_PAYOUT_SEVEN < 0) { console.error(`🚨 FATAL ERROR: OU7_PAYOUT_SEVEN must be a non-negative number.`); process.exit(1);}
if (isNaN(MINES_DEFAULT_ROWS) || MINES_DEFAULT_ROWS < 3 || MINES_DEFAULT_ROWS > 8) { console.error("FATAL: MINES_DEFAULT_ROWS must be a number between 3-8 for reasonable button display."); process.exit(1); }
if (isNaN(MINES_DEFAULT_COLS) || MINES_DEFAULT_COLS < 3 || MINES_DEFAULT_COLS > 8) { console.error("FATAL: MINES_DEFAULT_COLS must be a number between 3-8."); process.exit(1); }
if (isNaN(MINES_FALLBACK_DEFAULT_MINES) || MINES_FALLBACK_DEFAULT_MINES < 1) { console.error("FATAL: MINES_FALLBACK_DEFAULT_MINES must be at least 1."); process.exit(1); }
if (MINES_FALLBACK_DEFAULT_MINES >= MINES_DEFAULT_ROWS * MINES_DEFAULT_COLS) { console.error("FATAL: MINES_FALLBACK_DEFAULT_MINES must be less than total cells."); process.exit(1); }
if (isNaN(MINES_MIN_MINES) || MINES_MIN_MINES < 1) { console.error("FATAL: MINES_MIN_MINES must be at least 1."); process.exit(1); }
if (isNaN(MINES_MAX_MINES_PERCENT) || MINES_MAX_MINES_PERCENT <= 0 || MINES_MAX_MINES_PERCENT >= 0.8) { console.error("FATAL: MINES_MAX_MINES_PERCENT must be between 0 (exclusive) and 0.8 (exclusive for playability)."); process.exit(1); }
for (const key in MINES_DIFFICULTY_CONFIG) {
    const config = MINES_DIFFICULTY_CONFIG[key];
    if (isNaN(config.rows) || config.rows < 2 || config.rows > 8) { console.error(`FATAL: MINES_DIFFICULTY_CONFIG.${key}.rows must be 2-8.`); process.exit(1); }
    if (isNaN(config.cols) || config.cols < 2 || config.cols > 8) { console.error(`FATAL: MINES_DIFFICULTY_CONFIG.${key}.cols must be 2-8.`); process.exit(1); }
    if (isNaN(config.mines) || config.mines < MINES_MIN_MINES) { console.error(`FATAL: MINES_DIFFICULTY_CONFIG.${key}.mines must be >= MINES_MIN_MINES.`); process.exit(1); }
    if (config.mines >= config.rows * config.cols) { console.error(`FATAL: MINES_DIFFICULTY_CONFIG.${key}.mines must be less than total cells.`); process.exit(1); }
    if (config.mines > Math.floor((config.rows * config.cols) * MINES_MAX_MINES_PERCENT)) {console.error(`FATAL: MINES_DIFFICULTY_CONFIG.${key}.mines exceeds MINES_MAX_MINES_PERCENT for its grid size.`); process.exit(1); }
    if (!Array.isArray(config.multipliers) || config.multipliers.length !== (config.rows * config.cols - config.mines + 1)) { console.error(`FATAL: MINES_DIFFICULTY_CONFIG.${key}.multipliers array is missing or has incorrect length. Expected ${config.rows * config.cols - config.mines + 1} entries (0 gems + N gems).`); process.exit(1); }
}

// Critical validation for JACKPOT_SESSION_POLL_INTERVAL_MS
if (isNaN(JACKPOT_SESSION_POLL_INTERVAL_MS) || JACKPOT_SESSION_POLL_INTERVAL_MS < 2000) {
    console.error(`🚨 FATAL ERROR: JACKPOT_SESSION_POLL_INTERVAL_MS_MAINBOT ('${process.env.JACKPOT_SESSION_POLL_INTERVAL_MS_MAINBOT}') is invalid or less than 2000ms. Effective value: ${JACKPOT_SESSION_POLL_INTERVAL_MS}. Bot cannot start reliably.`);
    process.exit(1);
}


if (ADMIN_USER_ID) console.log(`ℹ️ Admin User ID: ${ADMIN_USER_ID} loaded.`);

function formatLamportsToSolStringForLog(lamports) {
    if (typeof lamports !== 'bigint' && typeof lamports !== 'number') {
        try { lamports = BigInt(lamports); }
        catch (e) { return 'Invalid_Lamports_Input'; }
    } else if (typeof lamports === 'number') {
        lamports = BigInt(lamports);
    }
    if (lamports === undefined || lamports === null) return 'N/A_Lamports';
    return (Number(lamports) / Number(LAMPORTS_PER_SOL)).toFixed(SOL_DECIMALS);
}

console.log(`--- ⚙️ Key Game & Bot Configurations Loaded ---
  Dice Escalator (PvB): Target Jackpot Score: ${TARGET_JACKPOT_SCORE}, Player Bust On: ${DICE_ESCALATOR_BUST_ON}, Jackpot Fee: ${JACKPOT_CONTRIBUTION_PERCENT * 100}%
  Dice 21 (Blackjack): Target Score: ${DICE_21_TARGET_SCORE}, Bot Stand: ${DICE_21_BOT_STAND_SCORE}
  Mines Config (Example 'easy'): Grid ${MINES_DIFFICULTY_CONFIG.easy.rows}x${MINES_DIFFICULTY_CONFIG.easy.cols}, Mines: ${MINES_DIFFICULTY_CONFIG.easy.mines}
  Bet Limits (USD): $${MIN_BET_USD_val.toFixed(2)} - $${MAX_BET_USD_val.toFixed(2)} (Lamports Ref: ${formatLamportsToSolStringForLog(MIN_BET_AMOUNT_LAMPORTS_config)} SOL - ${formatLamportsToSolStringForLog(MAX_BET_AMOUNT_LAMPORTS_config)} SOL)
  Default Starting Credits: ${formatLamportsToSolStringForLog(DEFAULT_STARTING_BALANCE_LAMPORTS)} SOL
  Command Cooldown: ${COMMAND_COOLDOWN_MS / 1000}s
  --- Timeouts ---
  Unified Offer Choice/Accept: ${UNIFIED_OFFER_TIMEOUT_MS / 1000}s
  Direct Challenge Acceptance: ${DIRECT_CHALLENGE_ACCEPT_TIMEOUT_MS / 1000}s
  Active Game Turn (PvB/PvP): ${ACTIVE_GAME_TURN_TIMEOUT_MS / 1000}s
  Instant Game Initial Action (e.g., OU7 choice): ${INSTANT_GAME_ACTION_TIMEOUT_MS / 1000}s
  --- End Timeouts ---
  Min Withdrawal: Approx. $${MIN_WITHDRAWAL_USD_val.toFixed(2)} USD (actual SOL equivalent varies based on current price), Fee: ${formatLamportsToSolStringForLog(WITHDRAWAL_FEE_LAMPORTS)} SOL
  Deposit Address Expiry: ${DEPOSIT_ADDRESS_EXPIRY_MINUTES} minutes
  SOL/USD Price API: ${process.env.SOL_PRICE_API_URL}
  Dice Roll Polling (Helper Bot System): Interval ${DICE_ROLL_POLLING_INTERVAL_MS}ms, Max Attempts ${DICE_ROLL_POLLING_MAX_ATTEMPTS}
  MainBot Jackpot Session Poller Interval: ${JACKPOT_SESSION_POLL_INTERVAL_MS / 1000}s 
  Sweep Fee Buffer (for TX cost): ${formatLamportsToSolStringForLog(BigInt(process.env.SWEEP_FEE_BUFFER_LAMPORTS))} SOL
  --- Game Activity Limits (Per Group, Defaults) ---
  Coinflip: Unified Offers=${GAME_ACTIVITY_LIMITS.UNIFIED_OFFERS[GAME_IDS.COINFLIP]}, Pending Direct Challenges=${GAME_ACTIVITY_LIMITS.DIRECT_CHALLENGES[GAME_IDS.COINFLIP_DIRECT_CHALLENGE_OFFER]}
    Active PvB: ${GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[GAME_IDS.COINFLIP_PVB]}, Active PvP (Unified): ${GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[GAME_IDS.COINFLIP_PVP_FROM_UNIFIED]}, Active PvP (Direct): ${GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[GAME_IDS.COINFLIP_PVP]}
  RPS: Unified Offers=${GAME_ACTIVITY_LIMITS.UNIFIED_OFFERS[GAME_IDS.RPS]}, Pending Direct Challenges=${GAME_ACTIVITY_LIMITS.DIRECT_CHALLENGES[GAME_IDS.RPS_DIRECT_CHALLENGE_OFFER]}
    Active PvB: ${GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[GAME_IDS.RPS_PVB]}, Active PvP (Unified): ${GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[GAME_IDS.RPS_PVP_FROM_UNIFIED]}, Active PvP (Direct): ${GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[GAME_IDS.RPS_PVP]}
  Dice Escalator: Unified Offers=${GAME_ACTIVITY_LIMITS.UNIFIED_OFFERS[GAME_IDS.DICE_ESCALATOR]}, Pending Direct Challenges=${GAME_ACTIVITY_LIMITS.DIRECT_CHALLENGES[GAME_IDS.DICE_ESCALATOR_DIRECT_CHALLENGE_OFFER]}
    Active PvB: ${GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[GAME_IDS.DICE_ESCALATOR_PVB]}, Active PvP (Unified): ${GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[GAME_IDS.DICE_ESCALATOR_PVP_FROM_UNIFIED]}, Active PvP (Direct): ${GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[GAME_IDS.DICE_ESCALATOR_PVP]}
  Dice 21: Unified Offers=${GAME_ACTIVITY_LIMITS.UNIFIED_OFFERS[GAME_IDS.DICE_21]}, Pending Direct Challenges=${GAME_ACTIVITY_LIMITS.DIRECT_CHALLENGES[GAME_IDS.DICE_21_DIRECT_CHALLENGE_OFFER]}
    Active PvB: ${GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[GAME_IDS.DICE_21]}, Active PvP (Unified): ${GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[GAME_IDS.DICE_21_PVP_FROM_UNIFIED]}, Active PvP (Direct): ${GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[GAME_IDS.DICE_21_PVP]}
  Duel: Unified Offers=${GAME_ACTIVITY_LIMITS.UNIFIED_OFFERS[GAME_IDS.DUEL]}, Pending Direct Challenges=${GAME_ACTIVITY_LIMITS.DIRECT_CHALLENGES[GAME_IDS.DUEL_DIRECT_CHALLENGE_OFFER]}
    Active PvB: ${GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[GAME_IDS.DUEL_PVB]}, Active PvP (Unified): ${GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[GAME_IDS.DUEL_PVP_FROM_UNIFIED]}, Active PvP (Direct): ${GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[GAME_IDS.DUEL_PVP]}
  Mines: Unified Offers=${GAME_ACTIVITY_LIMITS.UNIFIED_OFFERS[GAME_IDS.MINES_OFFER]}, Active PvB: ${GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[GAME_IDS.MINES]}
  (Other PvB-only game family limits also apply: OU7 (${GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[GAME_IDS.OVER_UNDER_7]}), Ladder (${GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[GAME_IDS.LADDER]}), Slot Frenzy (${GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[GAME_IDS.SLOT_FRENZY]}), Lucky Sum (${GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[GAME_IDS.SEVEN_OUT]}))
-------------------------------------------------`);

const useSsl = process.env.DB_SSL === 'true';
const rejectUnauthorizedSsl = process.env.DB_REJECT_UNAUTHORIZED === 'true';

const pool = new Pool({
  connectionString: DATABASE_URL,
  max: parseInt(process.env.DB_POOL_MAX, 10),
  min: parseInt(process.env.DB_POOL_MIN, 10),
  idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT, 10),
  connectionTimeoutMillis: parseInt(process.env.DB_CONN_TIMEOUT, 10),
  ssl: useSsl ? { rejectUnauthorized: rejectUnauthorizedSsl } : false,
});

pool.on('error', (err, client) => {
  console.error('❌ Unexpected error on idle PostgreSQL client', err);
  if (ADMIN_USER_ID && typeof safeSendMessage === "function" && typeof escapeMarkdownV2 === "function") {
    const adminMessage = `🚨 *DATABASE POOL ERROR* 🚨\nAn unexpected error occurred with an idle PostgreSQL client:\n\n*Error Message:*\n\`${escapeMarkdownV2(String(err.message || err))}\`\n\nPlease check the server logs for more details.`;
    safeSendMessage(ADMIN_USER_ID, adminMessage, { parse_mode: 'MarkdownV2' })
      .catch(notifyErr => console.error("Failed to notify admin about DB pool error:", notifyErr));
  } else {
    console.error(`[Admin Alert Failure] DB Pool Error (Idle Client): ${err.message || String(err)} (safeSendMessage, escapeMarkdownV2, or ADMIN_USER_ID unavailable)`);
  }
});

async function queryDatabase(sql, params = [], dbClient = pool) {
    const logPrefix = '[DB_Query_V6_NATIVE]'; // V6 using native parameterization

    try {
        // The pg driver can handle BigInts if they are passed as strings.
        // We can create a sanitized parameters array for the driver.
        const sanitizedParams = params.map(p => {
            if (typeof p === 'bigint') {
                return p.toString();
            }
            // The driver handles strings, numbers, booleans, nulls, etc., correctly.
            return p;
        });

        const result = await dbClient.query(sql, sanitizedParams);
        return result;

    } catch (error) {
        console.error(`${logPrefix} ❌ Error executing query.`);
        // Log the original SQL and params for better debugging
        console.error(`${logPrefix} SQL: ${sql.replace(/\s+/g, ' ').trim().substring(0, 500)}`);
        console.error(`${logPrefix} Params:`, params);
        console.error(`${logPrefix} Error Details: Message: ${error.message}, Code: ${error.code || 'N/A'}`);
        // Re-throw the original error to be handled by the calling function
        throw error;
    }
}

const connectionOptions = {
    commitment: process.env.RPC_COMMITMENT,
    maxConcurrent: parseInt(process.env.RPC_MAX_CONCURRENT, 10),
    retryBaseDelay: parseInt(process.env.RPC_RETRY_BASE_DELAY, 10),
    maxRetries: parseInt(process.env.RPC_MAX_RETRIES, 10),
    rateLimitCooloff: parseInt(process.env.RPC_RATE_LIMIT_COOLOFF, 10),
    retryMaxDelay: parseInt(process.env.RPC_RETRY_MAX_DELAY, 10),
    retryJitter: parseFloat(process.env.RPC_RETRY_JITTER),
};

const solanaConnection = new RateLimitedConnection(
    combinedRpcEndpointsForConnection,
    connectionOptions
);

const bot = new TelegramBot(BOT_TOKEN, { polling: true });

let app = null;
if (process.env.ENABLE_PAYMENT_WEBHOOKS === 'true') {
    app = express();
    app.use(express.json({
        verify: (req, res, buf) => {
            req.rawBody = buf;
        }
    }));
}

const BOT_VERSION = process.env.BOT_VERSION || '3.4.0-de-rewrite';
const MAX_MARKDOWN_V2_MESSAGE_LENGTH = 4096;
let isShuttingDown = false;
let activeGames = new Map();
let userCooldowns = new Map();
let groupGameSessions = new Map();
const walletCache = new Map();
const activeDepositAddresses = new Map();
const processedDepositTxSignatures = new Set();
const userStateCache = new Map();
const SOL_PRICE_CACHE_KEY = 'sol_usd_price_cache';
const solPriceCache = new Map();

// For MainBot's Dice Escalator Jackpot Session Poller
let jackpotSessionPollIntervalId = null;

// NEW: For Litecoin background tasks
let ltcDepositMonitorIntervalId = null;
let ltcSweepIntervalId = null;

// CORRECTED checkUserActiveGameLimit (Strict one-game-per-user rule)
async function checkUserActiveGameLimit(userIdToCheck, gameBeingStartedIsDirectChallengeOffer = false, gameIdBeingActioned = null) {
    const userIdStr = String(userIdToCheck);
    let activeInvolvementFound = null;

    for (const [gameIdInLoop, gameData] of activeGames.entries()) {
        if (gameIdBeingActioned && gameIdInLoop === gameIdBeingActioned) {
            continue;
        }

        let isUserInThisGame = false;
        if (gameData.userId === userIdStr || gameData.playerId === userIdStr || gameData.initiatorId === userIdStr) {
            isUserInThisGame = true;
        } else if (gameData.player?.userId === userIdStr) {
            isUserInThisGame = true;
        } else if (gameData.initiator?.userId === userIdStr || gameData.opponent?.userId === userIdStr) {
            isUserInThisGame = true;
        } else if (gameData.p1?.userId === userIdStr || gameData.p2?.userId === userIdStr) {
            isUserInThisGame = true;
        } else if (Array.isArray(gameData.participants) && gameData.participants.some(p => String(p.userId) === userIdStr)) {
            isUserInThisGame = true;
        } else if (gameData.type === GAME_IDS.MINES_OFFER && gameData.initiatorId === userIdStr) {
            isUserInThisGame = true;
        } else if (gameData.targetUserId === userIdStr && (gameData.type === GAME_IDS.DIRECT_PVP_CHALLENGE || gameData.type.endsWith('_direct_challenge_offer'))) {
            isUserInThisGame = true;
        }

        if (isUserInThisGame) {
            const trulyTerminatedStates = ['cancelled', 'expired', 'resolved'];
            const isEngagementTerminated = gameData.status && (gameData.status.startsWith('game_over_') || trulyTerminatedStates.includes(gameData.status));

            if (!isEngagementTerminated) {
                // The exception block that was here has been removed.
                // Any active involvement will now trigger the limit.
                activeInvolvementFound = { type: gameData.type, status: gameData.status, id: gameIdInLoop.slice(-6) };
                break; // Found a blocking involvement
            }
        }
    }

    if (activeInvolvementFound) {
        console.log(`[checkUserActiveGameLimit UID:${userIdStr}] Limit reached. Active involvement found: Type=${activeInvolvementFound.type}, Status=${activeInvolvementFound.status}, ID=${activeInvolvementFound.id}`);
        return { limitReached: true, details: activeInvolvementFound };
    }
    
    console.log(`[checkUserActiveGameLimit UID:${userIdStr}] No blocking active involvement found. Limit not reached.`);
    return { limitReached: false };
}

const escapeMarkdownV2 = (text) => {
  if (text === null || typeof text === 'undefined') return '';
  return String(text).replace(/([_*\[\]()~`>#+\-=|{}\\])/g, '\\$1');
};

async function safeSendMessage(chatId, text, options = {}) {
    const LOG_PREFIX_SSM = `[SafeSend CH:${chatId}]`;
    if (!chatId || typeof text !== 'string') {
        console.error(`${LOG_PREFIX_SSM} Invalid input: ChatID ${chatId}, Text type ${typeof text}. Preview: ${String(text).substring(0, 100)}`);
        return undefined;
    }

    let messageToSend = text;
    let finalOptions = { ...options };

    if (finalOptions.parse_mode === 'MarkdownV2' && messageToSend.length > MAX_MARKDOWN_V2_MESSAGE_LENGTH) {
        const ellipsisBase = ` \\.\\.\\. (_message truncated by ${escapeMarkdownV2(BOT_NAME)}_)`;
        const truncateAt = Math.max(0, MAX_MARKDOWN_V2_MESSAGE_LENGTH - ellipsisBase.length);
        messageToSend = messageToSend.substring(0, truncateAt) + ellipsisBase;
    } else if (finalOptions.parse_mode !== 'HTML' && messageToSend.length > MAX_MARKDOWN_V2_MESSAGE_LENGTH) {
        const ellipsisPlain = `... (message truncated by ${BOT_NAME})`;
        const truncateAt = Math.max(0, MAX_MARKDOWN_V2_MESSAGE_LENGTH - ellipsisPlain.length);
        messageToSend = messageToSend.substring(0, truncateAt) + ellipsisPlain;
    } else if (finalOptions.parse_mode === 'HTML' && messageToSend.length > 4096) {
        const escapeHTMLFunc = (str) => str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
        const ellipsisBase = ` ... (<i>message truncated by ${escapeHTMLFunc(BOT_NAME)}</i>)`;
        const truncateAt = Math.max(0, 4096 - ellipsisBase.length);
        messageToSend = messageToSend.substring(0, truncateAt) + ellipsisBase;
    }

    if (!bot || typeof bot.sendMessage !== 'function') {
        console.error(`${LOG_PREFIX_SSM} ⚠️ Error: Telegram 'bot' instance or sendMessage function not available.`);
        return undefined;
    }

    try {
        const sentMessage = await bot.sendMessage(chatId, messageToSend, finalOptions);
        return sentMessage;
    } catch (error) {
        console.error(`${LOG_PREFIX_SSM} ❌ Failed to send. Code: ${error.code || 'N/A'}, Msg: ${error.message}`);
        if (error.response && error.response.body && error.response.body.description) {
            const errorDescription = error.response.body.description.toLowerCase();
            if ((finalOptions.parse_mode === 'MarkdownV2' || finalOptions.parse_mode === 'HTML') && (errorDescription.includes("can't parse entities") || errorDescription.includes("bad request"))) {
                console.warn(`${LOG_PREFIX_SSM} ${finalOptions.parse_mode} parse error detected by API: "${error.response.body.description}". Attempting plain text fallback for original text.`);
                try {
                    let plainTextFallbackOptions = { ...options };
                    delete plainTextFallbackOptions.parse_mode;
                    let plainTextForFallback = text;
                    if (plainTextForFallback.length > MAX_MARKDOWN_V2_MESSAGE_LENGTH) {
                        const ellipsisPlainFallback = `... (message truncated by ${BOT_NAME}, original was parse error)`;
                        const truncateAtPlain = Math.max(0, MAX_MARKDOWN_V2_MESSAGE_LENGTH - ellipsisPlainFallback.length);
                        plainTextForFallback = plainTextForFallback.substring(0, truncateAtPlain) + ellipsisPlainFallback;
                    }
                    return await bot.sendMessage(chatId, plainTextForFallback, plainTextFallbackOptions);
                } catch (fallbackError) {
                    console.error(`${LOG_PREFIX_SSM} ❌ Plain text fallback also failed. Code: ${fallbackError.code || 'N/A'}, Msg: ${fallbackError.message}`);
                    return undefined;
                }
            }
        }
        return undefined;
    }
}

const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function notifyAdmin(message, options = {}) {
    if (ADMIN_USER_ID) {
        // FIXED: Escaped the parentheses around the bot name for MarkdownV2
        const adminAlertMessage = `🔔 *ADMIN ALERT* \\(${escapeMarkdownV2(BOT_NAME)}\\) 🔔\n\n${message}`;
        return safeSendMessage(ADMIN_USER_ID, adminAlertMessage, { parse_mode: 'MarkdownV2', ...options });
    } else {
        return null;
    }
}

async function fetchSolUsdPriceFromBinanceAPI() {
    const apiUrl = 'https://api.binance.com/api/v3/ticker/price?symbol=SOLUSDT';
    const logPrefix = '[PriceFeed Binance]';

    try {
        // console.log(`${logPrefix} Attempting to fetch SOL/USDT price from Binance...`);
        const response = await axios.get(apiUrl, { timeout: 8000 });

        if (response.data && typeof response.data.price === 'string') {
            const price = parseFloat(response.data.price);
            if (isNaN(price) || price <= 0) {
                throw new Error('Invalid or non-positive price data from Binance API.');
            }
            return price;
        } else {
            console.error(`${logPrefix} ⚠️ SOLUSDT price not found or invalid structure in Binance API response:`, stringifyWithBigInt(response.data).substring(0,300));
            throw new Error('SOLUSDT price not found or invalid structure in Binance API response.');
        }
    } catch (error) {
        const errMsg = error.isAxiosError ? error.message : String(error);
        let detailedError = errMsg;
        if (error.response) {
            if (error.response.status === 429 || error.response.status === 418) {
                detailedError = `Request failed (status ${error.response.status}): Rate Limit Exceeded or IP Ban with Binance.`;
            } else if (error.response.data && (error.response.data.msg || error.response.data.message)) {
                detailedError = `API Error: ${error.response.data.msg || error.response.data.message}`;
            }
        } else {
             console.error(`${logPrefix} ❌ Error fetching SOL/USDT price from Binance: ${detailedError}`);
        }
        if (error.response && (error.response.status === 429 || error.response.status === 418)) {
            const rateLimitError = new Error(`Failed to fetch SOL/USDT price from Binance: ${detailedError}`);
            rateLimitError.isRateLimitError = true;
            throw rateLimitError;
        }
        throw new Error(`Failed to fetch SOL/USDT price from Binance: ${detailedError}`);
    }
}

// --- NEW: Price Fetching from CoinGecko (Backup) ---
async function fetchSolUsdPriceFromCoinGeckoAPI() {
    const apiUrl = 'https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd';
    const logPrefix = '[PriceFeed CoinGecko]';

    try {
        // console.log(`${logPrefix} Attempting to fetch SOL/USD price from CoinGecko (backup)...`); // Less verbose
        const response = await axios.get(apiUrl, { timeout: 8000 });

        if (response.data && response.data.solana && typeof response.data.solana.usd === 'number') {
            const price = parseFloat(response.data.solana.usd);
            if (isNaN(price) || price <= 0) {
                throw new Error('Invalid or non-positive price data from CoinGecko API.');
            }
            // console.log(`${logPrefix} Successfully fetched SOL/USD price: $${price.toFixed(4)}`); // Less verbose
            return price;
        } else {
            console.error(`${logPrefix} ⚠️ SOL price not found or invalid structure in CoinGecko API response:`, stringifyWithBigInt(response.data).substring(0,300));
            throw new Error('SOL price not found or invalid structure in CoinGecko API response.');
        }
    } catch (error) {
        const errMsg = error.isAxiosError ? error.message : String(error);
        let detailedError = errMsg;
        if (error.response) {
            // console.error(`${logPrefix} CoinGecko API Response Status: ${error.response.status}, Data:`, stringifyWithBigInt(response.response.data).substring(0,300)); // Less verbose
             if (error.response.status === 429) {
                detailedError = `Request failed with status code 429 (Rate Limit Exceeded with CoinGecko).`;
            } else if (error.response.data && error.response.data.error) { // Some APIs put error message in data.error
                detailedError = `API Error: ${error.response.data.error}`;
            }
        } else {
             console.error(`${logPrefix} ❌ Error fetching SOL/USD price from CoinGecko: ${detailedError}`);
        }
        if (error.response && error.response.status === 429) {
            const rateLimitError = new Error(`Failed to fetch SOL/USD price from CoinGecko: ${detailedError}`);
            rateLimitError.isRateLimitError = true;
            throw rateLimitError;
        }
        throw new Error(`Failed to fetch SOL/USD price from CoinGecko: ${detailedError}`);
    }
}

async function getSolUsdPrice() {
    const logPrefix = '[GetSolUsdPrice V4_BinancePrimary]'; // V4 for new version
    const cacheTtl = parseInt(process.env.SOL_USD_PRICE_CACHE_TTL_MS, 10); // Ensure this is set to a LONG value (e.g., 1 hour)
    const cachedEntry = solPriceCache.get(SOL_PRICE_CACHE_KEY);

    if (cachedEntry && (Date.now() - cachedEntry.timestamp < cacheTtl)) {
        return cachedEntry.price;
    }

    let price;
    let primaryError = null;
    let backupErrorObject = null;

    // Attempt 1: Primary API (Binance)
    try {
        console.log(`${logPrefix} Cache stale or empty. Attempting fetch from Primary (Binance)...`);
        price = await fetchSolUsdPriceFromBinanceAPI(); // NEW primary
        solPriceCache.set(SOL_PRICE_CACHE_KEY, { price, timestamp: Date.now() });
        console.log(`${logPrefix} Successfully fetched and cached price from Binance: $${price.toFixed(2)}`);
        return price;
    } catch (error) {
        console.warn(`${logPrefix} ⚠️ Primary API (Binance) failed: ${error.message}`);
        primaryError = error; 
    }

    // Attempt 2: Backup API (CoinGecko) - if primary failed
    if (price === undefined) { 
        console.log(`${logPrefix} Primary API (Binance) failed. Attempting fetch from Backup (CoinGecko)...`);
        try {
            price = await fetchSolUsdPriceFromCoinGeckoAPI();
            solPriceCache.set(SOL_PRICE_CACHE_KEY, { price, timestamp: Date.now() });
            console.log(`${logPrefix} Successfully fetched and cached price from CoinGecko (backup): $${price.toFixed(2)}`);
            return price;
        } catch (backupError) {
            console.warn(`${logPrefix} ⚠️ Backup API (CoinGecko) also failed: ${backupError.message}`);
            backupErrorObject = backupError;

            if (cachedEntry) {
                console.warn(`${logPrefix} Both live fetches failed. Using stale cached SOL/USD price: $${cachedEntry.price.toFixed(2)} from ${new Date(cachedEntry.timestamp).toLocaleTimeString()}`);
                return cachedEntry.price;
            }
            
            const primaryErrorMessage = primaryError ? primaryError.message : "N/A";
            const backupErrorMessage = backupErrorObject ? backupErrorObject.message : "N/A";
            
            // Ensure parentheses around BOT_NAME are escaped for MarkdownV2
            const criticalAdminMsgContent = `🚨 *CRITICAL PRICE FEED FAILURE* \\(${escapeMarkdownV2(BOT_NAME)}\\) 🚨\n\nUnable to fetch SOL/USD price from ALL sources and no cache available. USD conversions will be SEVERELY impacted.\n*Primary Error (Binance):* \`${escapeMarkdownV2(primaryErrorMessage)}\`\n*Backup Error (CoinGecko):* \`${escapeMarkdownV2(backupErrorMessage)}\``;
            
            console.error(`${logPrefix} ❌ CRITICAL: ${criticalAdminMsgContent.replace(/\n/g, ' ')}`);
            if (typeof notifyAdmin === 'function') {
                await notifyAdmin(criticalAdminMsgContent); // notifyAdmin handles overall MarkdownV2 structure
            }
            throw new Error(`Critical: Could not retrieve SOL/USD price from any source. Last Primary (Binance) Error: ${primaryErrorMessage}. Last Backup (CoinGecko) Error: ${backupErrorMessage}`);
        }
    }
    
    if (cachedEntry) return cachedEntry.price; // Should have been caught above, but as a failsafe
    const finalPrimaryErrorMsg = primaryError ? primaryError.message : "Unknown primary API error";
    throw new Error (`Critical: Price fetch logic ended unexpectedly. Last Primary (Binance) Error: ${finalPrimaryErrorMsg}`);
}

// Ltc price

async function fetchLtcUsdPriceFromBinanceAPI() {
    const apiUrl = 'https://api.binance.com/api/v3/ticker/price?symbol=LTCUSDT';
    const logPrefix = '[PriceFeed LTC Binance]';

    try {
        const response = await axios.get(apiUrl, { timeout: 8000 });

        if (response.data && typeof response.data.price === 'string') {
            const price = parseFloat(response.data.price);
            if (isNaN(price) || price <= 0) {
                throw new Error('Invalid or non-positive price data from Binance API for LTC.');
            }
            return price;
        } else {
            console.error(`${logPrefix} ⚠️ LTCUSDT price not found or invalid structure in Binance API response.`);
            throw new Error('LTCUSDT price not found or invalid structure in Binance API response.');
        }
    } catch (error) {
        const errMsg = error.isAxiosError ? error.message : String(error);
        let detailedError = errMsg;
        if (error.response) {
            if (error.response.status === 429 || error.response.status === 418) {
                detailedError = `Request failed (status ${error.response.status}): Rate Limit Exceeded or IP Ban with Binance.`;
            }
        }
        console.error(`${logPrefix} ❌ Error fetching LTC/USDT price from Binance: ${detailedError}`);
        throw new Error(`Failed to fetch LTC/USDT price from Binance: ${detailedError}`);
    }
}

async function fetchLtcUsdPriceFromCoinGeckoAPI() {
    const LTC_PRICE_API_URL = process.env.LTC_PRICE_API_URL;
    const logPrefix = '[PriceFeed LTC CoinGecko]';

    try {
        const response = await axios.get(LTC_PRICE_API_URL, { timeout: 8000 });

        if (response.data && response.data.litecoin && typeof response.data.litecoin.usd === 'number') {
            const price = parseFloat(response.data.litecoin.usd);
            if (isNaN(price) || price <= 0) {
                throw new Error('Invalid or non-positive price data from CoinGecko API for LTC.');
            }
            return price;
        } else {
            console.error(`${logPrefix} ⚠️ LTC price not found or invalid structure in CoinGecko API response.`);
            throw new Error('LTC price not found or invalid structure in CoinGecko API response.');
        }
    } catch (error) {
        const errMsg = error.isAxiosError ? error.message : String(error);
        console.error(`${logPrefix} ❌ Error fetching LTC/USD price from CoinGecko: ${errMsg}`);
        // Re-throw the error to be handled by the manager function
        throw new Error(`Failed to fetch LTC/USD price from CoinGecko: ${errMsg}`);
    }
}

async function getLtcUsdPrice() {
    const logPrefix = '[GetLtcUsdPrice V3_Failover]';
    const cachedEntry = ltcPriceCache.get('ltc_usd_price');

    // 1. Check the cache first (this enforces the 1-hour rule)
    if (cachedEntry && (Date.now() - cachedEntry.timestamp < LTC_USD_PRICE_CACHE_TTL_MS)) {
        return cachedEntry.price;
    }

    let price;
    let primaryError = null;

    // 2. Attempt to fetch from the primary API (Binance)
    try {
        console.log(`${logPrefix} Cache stale. Attempting fetch from Primary (Binance)...`);
        price = await fetchLtcUsdPriceFromBinanceAPI();
        ltcPriceCache.set('ltc_usd_price', { price, timestamp: Date.now() });
        console.log(`${logPrefix} Successfully fetched and cached LTC price from Binance: $${price.toFixed(2)}`);
        return price;
    } catch (error) {
        console.warn(`${logPrefix} ⚠️ Primary API (Binance) for LTC failed: ${error.message}`);
        primaryError = error;
    }

    // 3. If primary failed, attempt to fetch from the Backup API (CoinGecko)
    if (price === undefined) {
        console.log(`${logPrefix} Primary failed. Attempting fetch from Backup (CoinGecko)...`);
        try {
            price = await fetchLtcUsdPriceFromCoinGeckoAPI();
            ltcPriceCache.set('ltc_usd_price', { price, timestamp: Date.now() });
            console.log(`${logPrefix} Successfully fetched and cached LTC price from CoinGecko (backup): $${price.toFixed(2)}`);
            return price;
        } catch (backupError) {
            console.warn(`${logPrefix} ⚠️ Backup API (CoinGecko) for LTC also failed: ${backupError.message}`);
            
            // 4. If both APIs fail, try to use a stale cache entry as a last resort
            if (cachedEntry) {
                console.warn(`${logPrefix} Using stale cached LTC/USD price: $${cachedEntry.price.toFixed(2)}`);
                return cachedEntry.price;
            }
            
            // 5. If there's no cache and both APIs fail, this is a critical failure
            const finalErrorMsg = `Primary (Binance) Error: ${primaryError.message}. Backup (CoinGecko) Error: ${backupError.message}`;
            if(typeof notifyAdmin === 'function') {
                await notifyAdmin(`🚨 CRITICAL LTC PRICE FEED FAILURE 🚨\n\nUnable to fetch LTC/USD price from ALL sources and no cache is available. LTC deposits will fail to be credited.`);
            }
            throw new Error(`Critical: Could not retrieve LTC/USD price. ${finalErrorMsg}`);
        }
    }
}

function convertLamportsToUSDString(lamports, solUsdPrice, displayDecimals = 2) {
    if (typeof solUsdPrice !== 'number' || solUsdPrice <= 0) {
        return '⚠️ Price N/A';
    }
    let lamportsBigInt;
    try {
        lamportsBigInt = BigInt(lamports);
    } catch (e) {
        return '⚠️ Amount Error';
    }

    const solAmount = Number(lamportsBigInt) / Number(LAMPORTS_PER_SOL);
    const usdValue = solAmount * solUsdPrice;
    return `$${usdValue.toLocaleString('en-US', { minimumFractionDigits: displayDecimals, maximumFractionDigits: displayDecimals })}`;
}

function convertUSDToLamports(usdAmount, solUsdPrice) {
    if (typeof solUsdPrice !== 'number' || solUsdPrice <= 0) {
        throw new Error("SOL/USD price must be a positive number for USD to Lamports conversion.");
    }
    const parsedUsdAmount = parseFloat(String(usdAmount).replace(/[^0-9.-]+/g,""));
    if (isNaN(parsedUsdAmount)) {
        throw new Error("Invalid USD amount for conversion.");
    }
    const solAmount = parsedUsdAmount / solUsdPrice;
    return BigInt(Math.floor(solAmount * Number(LAMPORTS_PER_SOL)));
}

const payoutProcessorQueue = new PQueue({
    concurrency: parseInt(process.env.PAYOUT_QUEUE_CONCURRENCY, 10),
    timeout: parseInt(process.env.PAYOUT_QUEUE_TIMEOUT_MS, 10),
    throwOnTimeout: true
});
const depositProcessorQueue = new PQueue({
    concurrency: parseInt(process.env.DEPOSIT_PROCESS_QUEUE_CONCURRENCY, 10),
    timeout: parseInt(process.env.DEPOSIT_PROCESS_QUEUE_TIMEOUT_MS, 10),
    throwOnTimeout: true
});

const SLOT_PAYOUTS = {
    64: { multiplier: 25, symbols: "7️⃣7️⃣7️⃣", label: "TRIPLE SEVEN!" },
    1:  { multiplier: 15, symbols: "BAR-BAR-BAR", label: "Triple Bar!" },
    22: { multiplier: 10, symbols: "🍋🍋🍋", label: "Triple Lemon!" },
    43: { multiplier: 5, symbols: "🍒🍒🍒", label: "Triple Cherry!" }
};
const SLOT_DEFAULT_LOSS_MULTIPLIER = -1;
// --- End of Part 1 (FINAL CORRECTION - WITH JACKPOT POLLER VARS INTEGRATED) ---
// --- Start of Part 2 (Modified for dice_roll_requests table, and with NEW initializeLevelsDB and checkAndUpdateUserLevel functions) ---
// index.js - Part 2: Database Schema Initialization & Core User Management
//---------------------------------------------------------------------------
// Assumed necessary functions and constants from Part 1 are available.
// Specifically: pool, DEFAULT_STARTING_BALANCE_LAMPORTS, escapeMarkdownV2,
// MAIN_JACKPOT_ID, PublicKey (from @solana/web3.js), walletCache,
// activeGames, userCooldowns, groupGameSessions, activeDepositAddresses,
// pendingReferrals, userStateCache, GAME_IDS (if used for activeGames clearing).
// notifyAdmin and ADMIN_USER_ID are used for critical error reporting.
// LEVEL_CONFIG, getSolUsdPrice, LAMPORTS_PER_SOL, convertUSDToLamports, safeSendMessage, getPlayerDisplayReference (for checkAndUpdateUserLevel)

// --- Helper function for referral code generation ---
const generateReferralCode = (length = 8) => {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return result;
};

//---------------------------------------------------------------------------
// Database Schema Initialization
//---------------------------------------------------------------------------
// FINAL CORRECTED initializeDatabaseSchema (with all fixes)
async function initializeDatabaseSchema() {
    console.log("⚙️ Initializing FULL database schema (All Tables & Triggers - Cleaned)...");
    const client = await pool.connect();
    try {
        await client.query('BEGIN');
        console.log("DB Schema: BEGIN executed.");

        // Users Table
        await client.query(`
CREATE TABLE IF NOT EXISTS users (
    telegram_id BIGINT PRIMARY KEY,
    username VARCHAR(255),
    first_name VARCHAR(255),
    last_name VARCHAR(255),
    balance BIGINT DEFAULT ${DEFAULT_STARTING_BALANCE_LAMPORTS.toString()},
    last_active_timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    is_banned BOOLEAN DEFAULT FALSE,
    ban_reason TEXT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    solana_wallet_address VARCHAR(44) UNIQUE,
    referral_code VARCHAR(12) UNIQUE,
    referrer_telegram_id BIGINT REFERENCES users(telegram_id) ON DELETE SET NULL,
    can_generate_deposit_address BOOLEAN DEFAULT TRUE,
    last_deposit_address VARCHAR(44),
    last_deposit_address_generated_at TIMESTAMPTZ,
    total_deposited_lamports BIGINT DEFAULT 0,
    total_withdrawn_lamports BIGINT DEFAULT 0,
    total_wagered_lamports BIGINT DEFAULT 0,
    total_won_lamports BIGINT DEFAULT 0,
    notes TEXT
);`);

        // Jackpots Table
        await client.query(`
CREATE TABLE IF NOT EXISTS jackpots (
    jackpot_id VARCHAR(255) PRIMARY KEY,
    current_amount BIGINT DEFAULT 0,
    last_won_by_telegram_id BIGINT REFERENCES users(telegram_id) ON DELETE SET NULL,
    last_won_timestamp TIMESTAMPTZ,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);`);
        await client.query(`INSERT INTO jackpots (jackpot_id, current_amount) VALUES ($1, 0) ON CONFLICT (jackpot_id) DO NOTHING;`, [MAIN_JACKPOT_ID]);

        // Games Table (Game Log)
        await client.query(`
CREATE TABLE IF NOT EXISTS games (
    game_log_id SERIAL PRIMARY KEY,
    game_type VARCHAR(50) NOT NULL,
    chat_id BIGINT,
    initiator_telegram_id BIGINT REFERENCES users(telegram_id) ON DELETE SET NULL,
    participants_ids BIGINT[],
    bet_amount_lamports BIGINT,
    outcome TEXT,
    jackpot_contribution_lamports BIGINT,
    game_timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);`);

        // User Deposit Wallets Table
        await client.query(`
CREATE TABLE IF NOT EXISTS user_deposit_wallets (
    wallet_id SERIAL PRIMARY KEY,
    user_telegram_id BIGINT NOT NULL REFERENCES users(telegram_id) ON DELETE CASCADE,
    public_key VARCHAR(44) NOT NULL UNIQUE,
    derivation_path VARCHAR(255) NOT NULL UNIQUE,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMPTZ,
    swept_at TIMESTAMPTZ,
    balance_at_sweep BIGINT,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);`);
        await client.query(`CREATE INDEX IF NOT EXISTS idx_user_deposit_wallets_user_id ON user_deposit_wallets(user_telegram_id);`);

        // Deposits Table
        await client.query(`
CREATE TABLE IF NOT EXISTS deposits (
    deposit_id SERIAL PRIMARY KEY,
    user_telegram_id BIGINT NOT NULL REFERENCES users(telegram_id) ON DELETE CASCADE,
    user_deposit_wallet_id INT REFERENCES user_deposit_wallets(wallet_id) ON DELETE SET NULL,
    transaction_signature VARCHAR(88) NOT NULL UNIQUE,
    source_address VARCHAR(44),
    deposit_address VARCHAR(44) NOT NULL,
    amount_lamports BIGINT NOT NULL,
    confirmation_status VARCHAR(20) DEFAULT 'pending',
    block_time BIGINT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    processed_at TIMESTAMPTZ,
    notes TEXT,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);`);

        // Withdrawals Table
        await client.query(`
CREATE TABLE IF NOT EXISTS withdrawals (
    withdrawal_id SERIAL PRIMARY KEY,
    user_telegram_id BIGINT NOT NULL REFERENCES users(telegram_id) ON DELETE CASCADE,
    destination_address VARCHAR(44) NOT NULL,
    amount_lamports BIGINT NOT NULL,
    fee_lamports BIGINT NOT NULL,
    transaction_signature VARCHAR(88) UNIQUE,
    status VARCHAR(30) DEFAULT 'pending_verification',
    error_message TEXT,
    requested_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    processed_at TIMESTAMPTZ,
    block_time BIGINT,
    priority_fee_microlamports INT,
    compute_unit_price_microlamports INT,
    compute_unit_limit INT,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);`);
        
        // Referrals Table (with corrected column sizes)
        await client.query(`
CREATE TABLE IF NOT EXISTS referrals (
    referral_id SERIAL PRIMARY KEY,
    referrer_telegram_id BIGINT NOT NULL REFERENCES users(telegram_id) ON DELETE CASCADE,
    referred_telegram_id BIGINT NOT NULL REFERENCES users(telegram_id) ON DELETE CASCADE UNIQUE,
    commission_type VARCHAR(50),
    commission_amount_lamports BIGINT,
    transaction_signature VARCHAR(88),
    status VARCHAR(50) DEFAULT 'pending_criteria',
    notes TEXT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT uq_referral_pair UNIQUE (referrer_telegram_id, referred_telegram_id)
);`);

        // Processed Sweeps Table
        await client.query(`
CREATE TABLE IF NOT EXISTS processed_sweeps (
    sweep_id SERIAL PRIMARY KEY,
    source_deposit_address VARCHAR(44) NOT NULL,
    destination_main_address VARCHAR(44) NOT NULL,
    amount_lamports BIGINT NOT NULL,
    transaction_signature VARCHAR(88) UNIQUE NOT NULL,
    swept_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);`);

        // Ledger Table
        await client.query(`
CREATE TABLE IF NOT EXISTS ledger (
    ledger_id SERIAL PRIMARY KEY,
    user_telegram_id BIGINT NOT NULL REFERENCES users(telegram_id) ON DELETE CASCADE,
    transaction_type VARCHAR(50) NOT NULL,
    amount_lamports BIGINT NOT NULL,
    balance_before_lamports BIGINT NOT NULL,
    balance_after_lamports BIGINT NOT NULL,
    deposit_id INTEGER REFERENCES deposits(deposit_id) ON DELETE SET NULL,
    withdrawal_id INTEGER REFERENCES withdrawals(withdrawal_id) ON DELETE SET NULL,
    game_log_id INTEGER REFERENCES games(game_log_id) ON DELETE SET NULL,
    referral_id INTEGER REFERENCES referrals(referral_id) ON DELETE SET NULL,
    related_sweep_id INTEGER REFERENCES processed_sweeps(sweep_id) ON DELETE SET NULL,
    notes TEXT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);`);

        // Dice Roll Requests Table
        await client.query(`
CREATE TABLE IF NOT EXISTS dice_roll_requests (
    request_id SERIAL PRIMARY KEY,
    game_id VARCHAR(255) NULL,
    chat_id BIGINT NOT NULL,
    user_id BIGINT NULL,
    emoji_type VARCHAR(50) DEFAULT '🎲',
    status VARCHAR(50) DEFAULT 'pending',
    roll_value INTEGER NULL,
    requested_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    processed_at TIMESTAMPTZ NULL,
    notes TEXT NULL,
    handler_type VARCHAR(50) NULL,
    helper_id VARCHAR(100) NULL
);`);

        // Dice Escalator Jackpot Sessions Table
        await client.query(`
CREATE TABLE IF NOT EXISTS de_jackpot_sessions (
    session_id SERIAL PRIMARY KEY,
    main_bot_game_id VARCHAR(255) NOT NULL,
    user_id BIGINT NOT NULL REFERENCES users(telegram_id) ON DELETE CASCADE,
    chat_id BIGINT NOT NULL,
    initial_score INTEGER NOT NULL,
    initial_rolls_json TEXT,
    bet_amount_lamports BIGINT NOT NULL,
    target_jackpot_score INTEGER NOT NULL,
    bust_on_value INTEGER NOT NULL,
    jackpot_pool_at_session_start BIGINT NOT NULL,
    status VARCHAR(50) DEFAULT 'pending_pickup',
    final_score INTEGER,
    final_rolls_json TEXT,
    outcome_notes TEXT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    helper_bot_id VARCHAR(100) NULL
);`);

        // --- Background Jobs Queue ---
        console.log("DB Schema: Creating background_jobs table...");
        await client.query(`
CREATE TABLE IF NOT EXISTS background_jobs (
    job_id SERIAL PRIMARY KEY,
    job_type VARCHAR(50) NOT NULL,
    payload JSONB NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    attempts INT DEFAULT 0,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    process_after TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);`);
        await client.query(`CREATE INDEX IF NOT EXISTS idx_background_jobs_status_process_after ON background_jobs(status, process_after);`);
        console.log("DB Schema: background_jobs table created or verified.");
        // --- END OF NEW TABLE ---

        // --- NEW: Table for Idempotent Job Processing ---
        console.log("DB Schema: Creating processed_job_actions table for idempotency...");
        await client.query(`
CREATE TABLE IF NOT EXISTS processed_job_actions (
    action_id VARCHAR(255) PRIMARY KEY, -- A unique ID for the specific action, e.g., 'credit-level-bonus-userid-levelid'
    job_id INTEGER REFERENCES background_jobs(job_id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);`);
        await client.query(`CREATE INDEX IF NOT EXISTS idx_processed_job_actions_job_id ON processed_job_actions(job_id);`);
        console.log("DB Schema: processed_job_actions table created or verified.");

        // --- NEW: Table for Dead-Letter Queue (Failed Jobs) ---
        console.log("DB Schema: Creating failed_jobs table for dead-letter queue...");
        await client.query(`
CREATE TABLE IF NOT EXISTS failed_jobs (
    job_id INTEGER PRIMARY KEY,
    job_type VARCHAR(50) NOT NULL,
    payload JSONB NOT NULL,
    status VARCHAR(20),
    attempts INT,
    last_attempt_at TIMESTAMPTZ,
    final_error_message TEXT,
    created_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);`);
        console.log("DB Schema: failed_jobs table created or verified.");

        // --- NEW: Tables for Litecoin Payment System ---
      console.log("DB Schema: Creating tables for Litecoin payment system...");

      // NEW: Litecoin User Deposit Wallets Table
      await client.query(`
CREATE TABLE IF NOT EXISTS ltc_user_deposit_wallets (
    wallet_id SERIAL PRIMARY KEY,
    user_telegram_id BIGINT NOT NULL REFERENCES users(telegram_id) ON DELETE CASCADE,
    address VARCHAR(100) NOT NULL UNIQUE,
    derivation_path VARCHAR(255) NOT NULL UNIQUE,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMPTZ,
    swept_at TIMESTAMPTZ,
    balance_at_sweep BIGINT, -- Stored in Litoshis
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);`);
      await client.query(`CREATE INDEX IF NOT EXISTS idx_ltc_deposit_wallets_user_id ON ltc_user_deposit_wallets(user_telegram_id);`);

      // NEW: Litecoin Deposits Table
      await client.query(`
CREATE TABLE IF NOT EXISTS ltc_deposits (
    deposit_id SERIAL PRIMARY KEY,
    user_telegram_id BIGINT NOT NULL REFERENCES users(telegram_id) ON DELETE CASCADE,
    ltc_user_deposit_wallet_id INT REFERENCES ltc_user_deposit_wallets(wallet_id) ON DELETE SET NULL,
    transaction_hash VARCHAR(64) NOT NULL UNIQUE,
    source_address VARCHAR(100),
    deposit_address VARCHAR(100) NOT NULL,
    amount_litoshis BIGINT NOT NULL, -- 1 LTC = 100,000,000 Litoshis
    confirmations INT DEFAULT 0,
    block_time BIGINT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    processed_at TIMESTAMPTZ,
    notes TEXT
);`);
      console.log("DB Schema: Litecoin payment system tables created or verified.");
      // --- END OF LITECOIN TABLES ---


        // Schema modifications for Referral System
        await client.query(`
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='users' AND column_name='referral_count') THEN
        ALTER TABLE users ADD COLUMN referral_count INT DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='users' AND column_name='total_referral_earnings_paid_lamports') THEN
        ALTER TABLE users ADD COLUMN total_referral_earnings_paid_lamports BIGINT DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='users' AND column_name='first_bet_placed_at') THEN
        ALTER TABLE users ADD COLUMN first_bet_placed_at TIMESTAMPTZ;
    END IF;
END $$;`);

        await client.query(`
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='referrals' AND column_name='qualifying_bet_processed_at') THEN
        ALTER TABLE referrals ADD COLUMN qualifying_bet_processed_at TIMESTAMPTZ;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='referrals' AND column_name='referred_user_wager_milestones_achieved') THEN
        ALTER TABLE referrals ADD COLUMN referred_user_wager_milestones_achieved JSONB DEFAULT '{}'::jsonb;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='referrals' AND column_name='last_milestone_bonus_check_wager_lamports') THEN
        ALTER TABLE referrals ADD COLUMN last_milestone_bonus_check_wager_lamports BIGINT DEFAULT 0;
    END IF;
END $$;`);

        // Schema modifications for Level Up Bonus System
        await client.query(`
CREATE TABLE IF NOT EXISTS user_levels (
    level_id SERIAL PRIMARY KEY,
    level_name VARCHAR(50) NOT NULL UNIQUE,
    wager_threshold_usd DECIMAL(12, 2) NOT NULL,
    bonus_amount_usd DECIMAL(10, 2) NOT NULL DEFAULT 0,
    order_index INT UNIQUE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);`);
        
        await client.query(`
CREATE TABLE IF NOT EXISTS user_claimed_level_bonuses (
    claim_id SERIAL PRIMARY KEY,
    user_telegram_id BIGINT NOT NULL REFERENCES users(telegram_id) ON DELETE CASCADE,
    level_id INT NOT NULL REFERENCES user_levels(level_id) ON DELETE CASCADE,
    claimed_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    bonus_amount_claimed_lamports BIGINT DEFAULT 0,
    status VARCHAR(30) DEFAULT 'claimed_pending_payout',
    transaction_signature VARCHAR(88),
    notes TEXT,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT uq_user_level_claim UNIQUE (user_telegram_id, level_id)
);`);
        await client.query(`CREATE INDEX IF NOT EXISTS idx_user_claimed_level_bonuses_status ON user_claimed_level_bonuses(status);`);

        await client.query(`
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='users' AND column_name='current_level_id') THEN
        ALTER TABLE users ADD COLUMN current_level_id INT REFERENCES user_levels(level_id) DEFAULT NULL;
    END IF;
END $$;`);
        
        await client.query(`
CREATE OR REPLACE FUNCTION trigger_set_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;`);

        const tablesWithUpdatedAt = ['users', 'jackpots', 'user_deposit_wallets', 'deposits', 'withdrawals', 'referrals', 'de_jackpot_sessions', 'user_levels', 'user_claimed_level_bonuses'];
        for (const tableName of tablesWithUpdatedAt) {
            const triggerExistsQuery = `SELECT 1 FROM pg_trigger WHERE tgname = 'set_timestamp' AND tgrelid = $1::regclass;`;
            const triggerExistsRes = await client.query(triggerExistsQuery, [tableName]);
            if (triggerExistsRes.rowCount === 0) {
                const createTriggerQuery = `CREATE TRIGGER set_timestamp BEFORE UPDATE ON ${tableName} FOR EACH ROW EXECUTE FUNCTION trigger_set_timestamp();`;
                await client.query(createTriggerQuery).catch(err => console.warn(`[DB Schema] Could not set update trigger for ${tableName}: ${err.message}`));
            }
        }

        await client.query('COMMIT');
        console.log("✅ DB Schema: Database schema initialization complete (ALL TABLES & TRIGGERS).");

    } catch (e) {
        try { await client.query('ROLLBACK'); } catch (rbError) { console.error("DB Schema: Error during ROLLBACK attempt:", rbError); }
        console.error('❌ DB Schema: Error during database schema initialization:', e);
        throw e;
    } finally {
        client.release();
    }
}

//---------------------------------------------------------------------------
// Core User Management Functions
//---------------------------------------------------------------------------

// FINAL CORRECTED getOrCreateUser with Referral Linking Fix
async function getOrCreateUser(telegramId, username = '', firstName = '', lastName = '', referrerIdInput = null) {
    if (typeof telegramId === 'undefined' || telegramId === null || String(telegramId).trim() === "" || String(telegramId).toLowerCase() === "undefined") {
        console.error(`[GetCreateUser CRITICAL] Invalid telegramId: '${telegramId}'. Aborting.`);
        return null;
    }

    const stringTelegramId = String(telegramId).trim();
    const LOG_PREFIX_GOCU = `[GetCreateUser_V7_FinalRefFix TG:${stringTelegramId}]`;

    const sanitizeString = (str) => {
        if (typeof str !== 'string') return null;
        return str.replace(/[^\w\s.,!?\-#@_]/g, '').trim().substring(0, 255);
    };

    const sUsername = username ? sanitizeString(username) : null;
    const sFirstName = firstName ? sanitizeString(firstName) : null;
    const sLastName = lastName ? sanitizeString(lastName) : null;

    const client = await pool.connect();
    try {
        await client.query('BEGIN');

        let referrerId = null;
        if (referrerIdInput) {
            try { referrerId = BigInt(referrerIdInput); } catch (e) { referrerId = null; }
        }

        let userResult = await client.query('SELECT * FROM users WHERE telegram_id = $1 FOR UPDATE', [stringTelegramId]);
        let user;

        if (userResult.rows.length > 0) {
            // --- USER EXISTS ---
            user = userResult.rows[0];

            // *** THIS IS THE CRITICAL FIX ***
            // If user exists but has no referrer, AND a referrerId was passed in this call...
            if (!user.referrer_telegram_id && referrerId) {
                console.log(`${LOG_PREFIX_GOCU} Existing user detected. Assigning referrer: ${referrerId}`);
                // 1. Update the user record with the referrer ID
                await client.query('UPDATE users SET referrer_telegram_id = $1 WHERE telegram_id = $2', [referrerId.toString(), stringTelegramId]);
                // 2. Create the permanent link in the referrals table
                await client.query(
                    `INSERT INTO referrals (referrer_telegram_id, referred_telegram_id, status) VALUES ($1, $2, 'pending_qual_bet') ON CONFLICT (referred_telegram_id) DO NOTHING;`,
                    [referrerId.toString(), stringTelegramId]
                );
                console.log(`${LOG_PREFIX_GOCU} SUCCESS: Referral link created in DB for existing user.`);
            }
            // *** END OF CRITICAL FIX ***

            // Standard update logic for username/name changes
            const detailsChanged = (sUsername && user.username !== sUsername) || (sFirstName && user.first_name !== sFirstName) || (sLastName && user.last_name !== sLastName);
            if (detailsChanged) {
                await client.query(
                    'UPDATE users SET last_active_timestamp = CURRENT_TIMESTAMP, username = $2, first_name = $3, last_name = $4, updated_at = CURRENT_TIMESTAMP WHERE telegram_id = $1',
                    [stringTelegramId, sUsername || user.username, sFirstName || user.first_name, sLastName || user.last_name]
                );
            } else {
                await client.query('UPDATE users SET last_active_timestamp = CURRENT_TIMESTAMP WHERE telegram_id = $1', [stringTelegramId]);
            }
            
        } else {
            // --- NEW USER ---
            console.log(`${LOG_PREFIX_GOCU} New user detected. Referrer ID to process: ${referrerId}`);
            const newReferralCode = generateReferralCode();
            const insertQuery = `INSERT INTO users (telegram_id, username, first_name, last_name, balance, referral_code, referrer_telegram_id, last_active_timestamp, created_at, updated_at, referral_count, total_referral_earnings_paid_lamports, first_bet_placed_at, current_level_id) VALUES ($1, $2, $3, $4, $5, $6, $7, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, 0, 0, NULL, NULL) RETURNING *;`;
            const values = [stringTelegramId, sUsername, sFirstName, sLastName, DEFAULT_STARTING_BALANCE_LAMPORTS.toString(), newReferralCode, referrerId ? referrerId.toString() : null];
            const insertResult = await client.query(insertQuery, values);
            user = insertResult.rows[0];

            if (referrerId) {
                console.log(`${LOG_PREFIX_GOCU} New user created with referrer. Inserting into 'referrals' table.`);
                await client.query(
                    `INSERT INTO referrals (referrer_telegram_id, referred_telegram_id, status) VALUES ($1, $2, 'pending_qual_bet') ON CONFLICT (referred_telegram_id) DO NOTHING;`,
                    [referrerId.toString(), stringTelegramId]
                );
            }
        }
        
        await client.query('COMMIT');
        
        // Return a fresh, complete user object
        const finalUserResult = await client.query('SELECT * FROM users WHERE telegram_id = $1', [stringTelegramId]);
        const finalUser = finalUserResult.rows[0];
        // Re-parse all BigInt fields before returning
        Object.keys(finalUser).forEach(key => {
            if (key.includes('lamports') || key === 'balance') {
                finalUser[key] = BigInt(finalUser[key] || '0');
            }
        });
        return finalUser;

    } catch (error) {
        await client.query('ROLLBACK').catch(rbErr => console.error(`${LOG_PREFIX_GOCU} Rollback error: ${rbErr.message}`));
        console.error(`${LOG_PREFIX_GOCU} Error in getOrCreateUser: ${error.message} (SQL State: ${error.code})`, error.stack);
        return null;
    } finally {
        client.release();
    }
}

async function updateUserActivity(telegramId) {
    const stringTelegramId = String(telegramId);
    try {
        await pool.query('UPDATE users SET last_active_timestamp = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP WHERE telegram_id = $1', [stringTelegramId]);
    } catch (error) {
        // console.error(`[UpdateUserActivity TG:${stringTelegramId}] Error updating last active timestamp:`, error); // Reduced: log only if it's a persistent problem
    }
}

async function getUserBalance(telegramId) {
    const stringTelegramId = String(telegramId);
    try {
        const result = await pool.query('SELECT balance FROM users WHERE telegram_id = $1', [stringTelegramId]);
        if (result.rows.length > 0) {
            return BigInt(result.rows[0].balance);
        }
        return null;
    } catch (error) {
        console.error(`[GetUserBalance TG:${stringTelegramId}] Error retrieving balance:`, error);
        return null;
    }
}

// This updateUserBalance is a direct DB update without ledger, use with extreme caution (admin corrections only).
// For regular balance changes, use updateUserBalanceAndLedger (from Part P2).
async function updateUserBalance(telegramId, newBalanceLamports, client = pool) {
    const stringTelegramId = String(telegramId);
    const LOG_PREFIX_UUB = `[UpdateUserBal TG:${stringTelegramId}]`;
    try {
        if (typeof newBalanceLamports !== 'bigint') {
            console.error(`${LOG_PREFIX_UUB} Invalid newBalanceLamports type: ${typeof newBalanceLamports}. Must be BigInt.`);
            return false;
        }
        
        if (newBalanceLamports < 0n) {
            console.warn(`${LOG_PREFIX_UUB} 🚨 CAUTION: Attempt to set negative balance (${newBalanceLamports.toString()}). This bypasses ledger and is for admin corrections ONLY.`);
        }

        const result = await client.query(
            'UPDATE users SET balance = $1, updated_at = CURRENT_TIMESTAMP WHERE telegram_id = $2',
            [newBalanceLamports.toString(), stringTelegramId]
        );
        if (result.rowCount > 0) {
            console.warn(`${LOG_PREFIX_UUB} ⚠️ Balance directly set to ${newBalanceLamports.toString()} lamports. LEDGER NOT UPDATED. Admin use ONLY.`);
            return true;
        } else {
            return false;
        }
    } catch (error) {
        console.error(`${LOG_PREFIX_UUB} Error updating balance for ${stringTelegramId} to ${newBalanceLamports.toString()}:`, error);
        return false;
    }
}

async function linkUserWallet(telegramId, solanaAddress) {
    const stringTelegramId = String(telegramId);
    const LOG_PREFIX_LUW = `[LinkUserWallet TG:${stringTelegramId}]`;
    const client = await pool.connect();
    try {
        await client.query('BEGIN');
        try {
            new PublicKey(solanaAddress); 
        } catch (e) {
            await client.query('ROLLBACK');
            // Escaped period in user-facing message
            return { success: false, error: "Invalid Solana address format\\. Please provide a valid Base58 encoded public key\\." };
        }

        const existingLink = await client.query('SELECT telegram_id FROM users WHERE solana_wallet_address = $1 AND telegram_id != $2', [solanaAddress, stringTelegramId]);
        if (existingLink.rows.length > 0) {
            const linkedToExistingUserId = existingLink.rows[0].telegram_id;
            console.warn(`${LOG_PREFIX_LUW} Wallet ${solanaAddress} already linked to user ID ${linkedToExistingUserId}.`);
            await client.query('ROLLBACK');
            // Escaped period in user-facing message
            return { success: false, error: `This wallet address is already associated with another player (ID ending with ${String(linkedToExistingUserId).slice(-4)})\\. Please use a different address\\.` };
        }

        const result = await client.query(
            'UPDATE users SET solana_wallet_address = $1, updated_at = CURRENT_TIMESTAMP WHERE telegram_id = $2 RETURNING solana_wallet_address',
            [solanaAddress, stringTelegramId]
        );

        if (result.rowCount > 0) {
            await client.query('COMMIT');
            if (walletCache) walletCache.set(stringTelegramId, { solanaAddress, timestamp: Date.now() }); 
            // Escaped !, .
            return { success: true, message: `Your Solana wallet \`${escapeMarkdownV2(solanaAddress)}\` has been successfully linked\\!` }; 
        } else {
            const currentUserState = await client.query('SELECT solana_wallet_address FROM users WHERE telegram_id = $1', [stringTelegramId]);
            await client.query('ROLLBACK'); 
            if (currentUserState.rowCount === 0) {
                console.error(`${LOG_PREFIX_LUW} User ${stringTelegramId} not found. Cannot link wallet.`);
                // Escaped period
                return { success: false, error: "Your player profile was not found\\. Please try \`/start\` again\\." };
            }
            if (currentUserState.rows[0].solana_wallet_address === solanaAddress) {
                if (walletCache) walletCache.set(stringTelegramId, { solanaAddress, timestamp: Date.now() });
                // Escaped period
                return { success: true, message: `Your wallet \`${escapeMarkdownV2(solanaAddress)}\` was already linked to your account\\.` };
            }
            console.warn(`${LOG_PREFIX_LUW} User ${stringTelegramId} found, but wallet not updated. DB wallet: ${currentUserState.rows[0].solana_wallet_address}, Attempted: ${solanaAddress}.`);
            // Escaped period
            return { success: false, error: "Failed to update wallet in DB\\. It might be the same, or an unknown issue occurred\\." };
        }
    } catch (error) {
        await client.query('ROLLBACK').catch(rbErr => console.error(`${LOG_PREFIX_LUW} Rollback error: ${rbErr.message}`));
        if (error.code === '23505') { 
            console.warn(`${LOG_PREFIX_LUW} Wallet ${solanaAddress} already linked to another user (unique constraint).`);
            // Escaped period
            return { success: false, error: "This wallet address is already in use by another player\\. Please choose a different one\\." };
        }
        console.error(`${LOG_PREFIX_LUW} Error linking wallet ${solanaAddress}:`, error);
        // Escaped period
        return { success: false, error: escapeMarkdownV2(error.message || "An unexpected server error occurred while linking your wallet\\.") };
    } finally {
        client.release();
    }
}

async function getUserLinkedWallet(telegramId) {
    const stringTelegramId = String(telegramId);
    const cacheTTL = parseInt(process.env.WALLET_CACHE_TTL_MS || (15 * 60 * 1000).toString(), 10);
    
    if (walletCache) { 
        const cachedData = walletCache.get(stringTelegramId);
        if (cachedData && cachedData.solanaAddress && (Date.now() - (cachedData.timestamp || 0) < cacheTTL)) {
            return cachedData.solanaAddress;
        }
    }

    try {
        const result = await pool.query('SELECT solana_wallet_address FROM users WHERE telegram_id = $1', [stringTelegramId]);
        if (result.rows.length > 0 && result.rows[0].solana_wallet_address) {
            if (walletCache) walletCache.set(stringTelegramId, { solanaAddress: result.rows[0].solana_wallet_address, timestamp: Date.now() });
            return result.rows[0].solana_wallet_address;
        }
        return null; 
    } catch (error) {
        console.error(`[GetUserWallet TG:${stringTelegramId}] Error getting linked wallet:`, error);
        return null;
    }
}

// --- Start of new findRecipientUser function ---
/**
 * Finds a user by their Telegram ID or username.
 * @param {string} identifier - The user's Telegram ID or @username.
 * @param {import('pg').PoolClient} [dbClient=pool] - Optional database client.
 * @returns {Promise<object|null>} User object from getOrCreateUser if found, otherwise null.
 */
async function findRecipientUser(identifier, dbClient = pool) {
    const logPrefix = `[FindRecipientUser Ident:${identifier}]`;
    let recipientUser = null;

    if (!identifier || typeof identifier !== 'string') {
        console.warn(`${logPrefix} Invalid identifier provided.`);
        return null;
    }

    try {
        if (identifier.startsWith('@')) {
            const usernameToFind = identifier.substring(1);
            if (!usernameToFind) {
                console.warn(`${logPrefix} Empty username provided after @ symbol.`);
                return null;
            }
            // Ensure queryDatabase is available in this scope
            const userRes = await queryDatabase('SELECT telegram_id, username, first_name, last_name FROM users WHERE LOWER(username) = LOWER($1)', [usernameToFind], dbClient);
            if (userRes.rows.length > 0) {
                // Ensure getOrCreateUser is available in this scope
                recipientUser = await getOrCreateUser(userRes.rows[0].telegram_id, userRes.rows[0].username, userRes.rows[0].first_name, userRes.rows[0].last_name);
            } else {
                console.log(`${logPrefix} User with username "${usernameToFind}" not found.`);
            }
        } else if (/^\d+$/.test(identifier)) {
            // Ensure getOrCreateUser is available in this scope
            // Attempt to fetch the user. If they don't exist, getOrCreateUser will return null if it can't create based on ID alone (which is fine for tipping, recipient should exist).
            recipientUser = await getOrCreateUser(identifier); // Pass only ID, other params are for creation if needed
            if (!recipientUser) {
                 console.log(`${logPrefix} User with ID "${identifier}" not found (getOrCreateUser returned null).`);
            }
        } else {
            console.warn(`${logPrefix} Identifier "${identifier}" is not a valid Telegram ID or @username format.`);
        }
    } catch (error) {
        console.error(`${logPrefix} Error finding recipient user: ${error.message}`, error.stack?.substring(0, 500));
        return null; // Return null on error
    }

    if (!recipientUser) {
         console.log(`${logPrefix} No recipient user found for identifier: ${identifier}`);
    }
    return recipientUser;
}
// --- End of new findRecipientUser function ---

// From Part 2: Database Schema Initialization & Core User Management

async function getNextAddressIndexForUserDB(userId, dbClient = pool) {
    const stringUserId = String(userId);
    const LOG_PREFIX_GNAI = `[NextAddrIdx TG:${stringUserId}]`;
    try {
        // SQL query (ensure this is also clean from previous fix)
        const query = `SELECT derivation_path FROM user_deposit_wallets WHERE user_telegram_id = $1 ORDER BY created_at DESC;`;

        const res = await queryDatabase(query, [stringUserId], dbClient);
        let maxIndex = -1;

        if (res.rows.length > 0) {
            for (const row of res.rows) {
                const path = row.derivation_path;
                const parts = path.split('/');
                if (parts.length >= 6) { 
                    const lastPart = parts[parts.length - 1];
                    if (lastPart.endsWith("'")) {
                        const indexStr = lastPart.substring(0, lastPart.length - 1);
                        const currentIndex = parseInt(indexStr, 10);
                        if (!isNaN(currentIndex) && currentIndex > maxIndex) {
                            maxIndex = currentIndex;
                        }
                    }
                }
            }
        }
        const nextIndex = maxIndex + 1;
        return nextIndex;
    } catch (error) {
        // CORRECTED LINE: Ensure this uses backticks (`) for the template literal
        console.error(`${LOG_PREFIX_GNAI} Error calculating next address index: ${error.message}`, error.stack?.substring(0,300));
        throw error; 
    }
}

async function deleteUserAccount(telegramId) {
    const stringTelegramId = String(telegramId);
    const LOG_PREFIX_DUA = `[DeleteUser TG:${stringTelegramId}]`;
    console.warn(`${LOG_PREFIX_DUA} CRITICAL ACTION: Attempting to delete user account and associated data for Telegram ID: ${stringTelegramId}.`);
    const client = await pool.connect();
    try {
        await client.query('BEGIN');

        await client.query('UPDATE jackpots SET last_won_by_telegram_id = NULL WHERE last_won_by_telegram_id = $1', [stringTelegramId]);
        await client.query('UPDATE games SET initiator_telegram_id = NULL WHERE initiator_telegram_id = $1', [stringTelegramId]);
        
        console.log(`${LOG_PREFIX_DUA} Preparing to delete user from 'users' table (CASCADE to related tables).`);
        const result = await client.query('DELETE FROM users WHERE telegram_id = $1', [stringTelegramId]);
        await client.query('COMMIT');

        if (result.rowCount > 0) {
            console.log(`${LOG_PREFIX_DUA} User account ${stringTelegramId} and cascaded data deleted successfully from database.`);
            
            // Clear in-memory caches - ensure GAME_IDS is defined/imported if used here
            const GAME_IDS_INTERNAL = typeof GAME_IDS !== 'undefined' ? GAME_IDS : { DICE_ESCALATOR: 'dice_escalator', DICE_21: 'dice21' }; // Fallback if GAME_IDS not in scope

            if (activeGames && activeGames instanceof Map) {
                activeGames.forEach((game, gameId) => {
                    if (game && game.participants && Array.isArray(game.participants)) {
                        game.participants = game.participants.filter(p => String(p.userId) !== stringTelegramId);
                        // Check GAME_IDS_INTERNAL definition if this part is critical
                        if (game.participants.length === 0 && game.type !== GAME_IDS_INTERNAL.DICE_ESCALATOR && game.type !== GAME_IDS_INTERNAL.DICE_21) {
                            activeGames.delete(gameId);
                        }
                    }
                    if (game && String(game.initiatorId) === stringTelegramId) activeGames.delete(gameId);
                    if (game && String(game.userId) === stringTelegramId) activeGames.delete(gameId); // For single player games
                });
            }
            if (userCooldowns && userCooldowns instanceof Map) userCooldowns.delete(stringTelegramId);
            if (groupGameSessions && groupGameSessions instanceof Map) {
                groupGameSessions.forEach((session, chatId) => {
                    if (session.players && session.players[stringTelegramId]) delete session.players[stringTelegramId];
                    if (session.initiator === stringTelegramId && Object.keys(session.players || {}).length === 0) groupGameSessions.delete(chatId);
                });
            }
            if (walletCache && walletCache instanceof Map) walletCache.delete(stringTelegramId);
            if (activeDepositAddresses && activeDepositAddresses instanceof Map) {
                activeDepositAddresses.forEach((value, key) => {
                    if (String(value.userId) === stringTelegramId) activeDepositAddresses.delete(key);
                });
            }
            if (pendingReferrals && pendingReferrals instanceof Map) { 
                pendingReferrals.forEach((value, key) => {
                    if (String(key) === stringTelegramId) pendingReferrals.delete(key); 
                    if (value && String(value.referrerId) === stringTelegramId) pendingReferrals.delete(key); 
                });
            }
            if (userStateCache && userStateCache instanceof Map) userStateCache.delete(stringTelegramId);
            
            console.log(`${LOG_PREFIX_DUA} Relevant in-memory caches cleared for user ${stringTelegramId}.`);
            return true;
        } else {
            console.log(`${LOG_PREFIX_DUA} User ${stringTelegramId} not found in 'users' table, no account deleted.`);
            return false;
        }
    } catch (error) {
        await client.query('ROLLBACK').catch(rbErr => console.error(`${LOG_PREFIX_DUA} Rollback error: ${rbErr.message}`));
        console.error(`${LOG_PREFIX_DUA} Error deleting user account ${stringTelegramId}:`, error);
        if(typeof notifyAdmin === 'function' && ADMIN_USER_ID) {
            notifyAdmin(`🚨 User Account Deletion FAILED for ${stringTelegramId} 🚨\nError: ${escapeMarkdownV2(error.message)}`, {parse_mode:'MarkdownV2'});
        }
        return false;
    } finally {
        client.release();
    }
}

// --- NEW Function to Initialize/Update User Levels from Config ---
/**
 * Populates or updates the user_levels table from the LEVEL_CONFIG.
 * Should be called once during bot initialization after DB schema is ready.
 * @param {import('pg').PoolClient} [extClient=null] - Optional external DB client.
 */
async function initializeLevelsDB(extClient = null) {
    const LOG_PREFIX_INIT_LVL = "[InitLevelsDB]";
    console.log(`${LOG_PREFIX_INIT_LVL} ⚙️ Starting population/verification of 'user_levels' table from LEVEL_CONFIG...`);

    const client = extClient || await pool.connect();

    try {
        if (!extClient) { // Only begin/commit if we connected our own client
            await client.query('BEGIN');
        }

        if (!LEVEL_CONFIG || LEVEL_CONFIG.length === 0) {
            console.warn(`${LOG_PREFIX_INIT_LVL} LEVEL_CONFIG is empty or not defined. No levels to populate.`);
            if (!extClient) await client.query('COMMIT'); // Commit if no levels, table is just empty
            return;
        }

        let levelsProcessed = 0;

        for (const level of LEVEL_CONFIG) {
            if (typeof level.order_index !== 'number' || !level.name || typeof level.wager_threshold_usd !== 'number' || typeof level.bonus_amount_usd !== 'number') {
                console.warn(`${LOG_PREFIX_INIT_LVL} ⚠️ Skipping invalid level config entry: ${JSON.stringify(level)}`);
                continue;
            }

            const upsertQuery = `
                INSERT INTO user_levels (order_index, level_name, wager_threshold_usd, bonus_amount_usd, created_at, updated_at)
                VALUES ($1, $2, $3, $4, NOW(), NOW())
                ON CONFLICT (order_index) DO UPDATE SET
                    level_name = EXCLUDED.level_name,
                    wager_threshold_usd = EXCLUDED.wager_threshold_usd,
                    bonus_amount_usd = EXCLUDED.bonus_amount_usd,
                    updated_at = NOW()
                RETURNING xmax;
            `;
            
            await client.query(upsertQuery, [
                level.order_index,
                level.name,
                level.wager_threshold_usd.toFixed(2),
                level.bonus_amount_usd.toFixed(2)
            ]);
            levelsProcessed++;
        }

        console.log(`${LOG_PREFIX_INIT_LVL} ✅ Processed ${levelsProcessed} level configurations. 'user_levels' table synchronized with LEVEL_CONFIG.`);

        if (!extClient) {
            await client.query('COMMIT');
        }
    } catch (error) {
        if (!extClient) {
            await client.query('ROLLBACK').catch(rbErr => console.error(`${LOG_PREFIX_INIT_LVL} Rollback error: ${rbErr.message}`));
        }
        console.error(`${LOG_PREFIX_INIT_LVL} ❌ Error initializing/updating user_levels table: ${error.message}`, error.stack);
        if (typeof notifyAdmin === 'function' && typeof escapeMarkdownV2 === 'function') { // Added escapeMarkdownV2 check
            notifyAdmin(`🚨 CRITICAL DB Error: Failed to initialize user_levels table from config. Leveling system may be broken.\nError: ${escapeMarkdownV2(error.message)}`, { parse_mode: 'MarkdownV2' });
        }
    } finally {
        if (!extClient) {
            client.release();
        }
    }
}

// --- NEW Function to Check and Update User Level ---
/**
 * Checks if a user has reached a new level based on their total wagers
 * and updates their current_level_id in the users table.
 * This should be called within the same DB transaction as wager updates.
 * @param {import('pg').PoolClient} dbClient - The active database client for the transaction.
 * @param {string} userId - The user's Telegram ID.
 * @param {bigint} newTotalWageredLamports - The user's new total wagered amount in lamports.
 */
async function checkAndUpdateUserLevel(dbClient, userId, newTotalWageredLamports, solUsdPrice, originalGameChatId = null) {
    const LOG_PREFIX_CHECK_LVL = `[CheckUserLevel UID:${userId} GameChat:${originalGameChatId || 'N/A'}]`;
    const notifications = []; // Array to hold notification payloads

    try {
        if (!solUsdPrice || solUsdPrice <= 0) {
            console.error(`${LOG_PREFIX_CHECK_LVL} Invalid solUsdPrice (${solUsdPrice}) passed. Cannot calculate level progress.`);
            return notifications;
        }
        
        // This is the corrected calculation from our previous discussion
        const totalWageredUSD = Number(newTotalWageredLamports) / Number(LAMPORTS_PER_SOL) * solUsdPrice;

        // THIS IS THE CRITICAL FIX: The "FOR UPDATE OF u" clause has been removed.
        // The user row is already locked by the calling function's transaction context (via updateUserBalanceAndLedger).
        const currentUserDetailsQueryText = `
            SELECT u.current_level_id, u.username, u.first_name, u.last_name, 
                   ul.order_index AS current_level_order_index, ul.level_name AS current_level_name 
            FROM users u 
            LEFT JOIN user_levels ul ON u.current_level_id = ul.level_id 
            WHERE u.telegram_id = $1`;
        
        const currentUserDataRes = await queryDatabase(
            currentUserDetailsQueryText,
            [userId],
            dbClient
        );

        if (currentUserDataRes.rowCount === 0) {
            console.warn(`${LOG_PREFIX_CHECK_LVL} User not found. Cannot update level.`);
            return notifications;
        }
        const userFromDb = currentUserDataRes.rows[0];
        const currentLevelOrderIndex = userFromDb.current_level_order_index || 0;
        const currentLevelName = userFromDb.current_level_name || "Newcomer";

        const allLevelsRes = await dbClient.query(
            `SELECT level_id, level_name, wager_threshold_usd, bonus_amount_usd, order_index
             FROM user_levels
             ORDER BY order_index ASC`
        );

        let newPotentialLevelId = userFromDb.current_level_id;
        let newPotentialLevelName = currentLevelName;
        let newPotentialOrderIndex = currentLevelOrderIndex;
        let newLevelDataForNotification = null;

        for (const level of allLevelsRes.rows) {
            if (totalWageredUSD >= parseFloat(level.wager_threshold_usd)) {
                if (level.order_index > newPotentialOrderIndex) {
                    newPotentialLevelId = level.level_id;
                    newPotentialLevelName = level.level_name;
                    newPotentialOrderIndex = level.order_index;
                    newLevelDataForNotification = level;
                }
            } else {
                break;
            }
        }

        if (newPotentialLevelId !== userFromDb.current_level_id && newPotentialOrderIndex > currentLevelOrderIndex) {
            await dbClient.query(
                `UPDATE users SET current_level_id = $1, updated_at = NOW() WHERE telegram_id = $2`,
                [newPotentialLevelId, userId]
            );
            console.log(`${LOG_PREFIX_CHECK_LVL} 🎉 User ${userId} LEVELED UP! From '${currentLevelName}' to '${newPotentialLevelName}'! Wagered: $${totalWageredUSD.toFixed(2)}`);

            const userObjectForDisplay = { telegram_id: userId, username: userFromDb.username, first_name: userFromDb.first_name, last_name: userFromDb.last_name };
            const playerRefHTML = escapeHTML(getPlayerDisplayReference(userObjectForDisplay));

            let dmNotificationTextHTML = `🎉✨ <b>LEVEL UP!</b> ✨🎉\n\n` +
                                         `Huge congrats, ${playerRefHTML}! You've climbed the ranks and reached:\n\n` +
                                         `🏅 <b>${escapeHTML(newPotentialLevelName)}</b> (Level ${newPotentialOrderIndex}) 🏅\n\n`;
            const keyboardRowsDM = [];

            if (newLevelDataForNotification && parseFloat(newLevelDataForNotification.bonus_amount_usd) > 0) {
                const bonusAmountUSD = parseFloat(newLevelDataForNotification.bonus_amount_usd).toFixed(2);
                dmNotificationTextHTML += `As a reward, a sparkling bonus of approx. <b>$${bonusAmountUSD} USD</b> is now available for you to claim!\n\n`;
                keyboardRowsDM.push([{ text: `💰 Claim $${bonusAmountUSD} Bonus! (${escapeHTML(newPotentialLevelName)})`, callback_data: `claim_level_bonus:${newLevelDataForNotification.level_id}` }]);
            } else {
                dmNotificationTextHTML += `Keep up the great work and climb higher for more rewards!\n\n`;
            }
            
            dmNotificationTextHTML += `🚀 Check your \`/bonus\` dashboard for all available rewards and your next level!`;
            keyboardRowsDM.push([{ text: "📊 View My Bonus Dashboard", callback_data: "menu:bonus_dashboard_back" }]);
            keyboardRowsDM.push([{ text: "⬅️ Back to Main Menu", callback_data: "menu:main" }]);

            notifications.push({
                to: userId,
                text: dmNotificationTextHTML,
                options: {
                    parse_mode: 'HTML',
                    reply_markup: { inline_keyboard: keyboardRowsDM }
                }
            });

            if (originalGameChatId && String(originalGameChatId) !== String(userId)) {
                const groupNotificationHTML = `🎉🥳 Level Up Alert! 🥳🎉\n\n` +
                                              `Congratulations to ${playerRefHTML} for achieving a new rank: 🏅 <b>${escapeHTML(newPotentialLevelName)}</b>!\n\n` +
                                              `Keep an eye on your DMs for any new bonus rewards!`;
                
                notifications.push({
                    to: originalGameChatId,
                    text: groupNotificationHTML,
                    options: { parse_mode: 'HTML' }
                });
            }
        }
    } catch (error) {
        console.error(`${LOG_PREFIX_CHECK_LVL} ❌ Error checking/updating user level: ${error.message}`, error.stack);
        if (typeof notifyAdmin === 'function' && typeof escapeMarkdownV2 === 'function') {
            const adminNote = `⚠️ Error in Level Up Check for User ${userId}: ${escapeMarkdownV2(error.message)}. Balance update likely succeeded, but level up process may have failed.`;
            notifications.push({
                to: ADMIN_USER_ID,
                text: adminNote,
                options: { parse_mode: 'MarkdownV2' }
            });
        }
    }
    
    return notifications;
}


// --- End of Part 2 ---
// --- Start of Part 3 (REVISED for new Group Session Lock Management) ---
// index.js - Part 3: Telegram Helpers, Currency Formatting & Basic Game Utilities (with Group Session Management)
//---------------------------------------------------------------------------
// Assumed escapeMarkdownV2, LAMPORTS_PER_SOL, SOL_DECIMALS, getSolUsdPrice,
// convertLamportsToUSDString, crypto (module), BOT_NAME are available from Part 1.
// Assumed groupGameSessions and activeGames (Maps) are defined globally (e.g., in Part 1).

// --- Telegram Specific Helper Functions ---

/**
 * Gets a display name from a user object and escapes it for MarkdownV2.
 * @param {object} userObject - msg.from or a fetched user object.
 * @returns {string} MarkdownV2 escaped display name.
 */
function getEscapedUserDisplayName(userObject) {
    if (!userObject) return escapeMarkdownV2("Valued Player");

    const firstName = userObject.first_name || userObject.firstName;
    const username = userObject.username;
    const id = userObject.id || userObject.telegram_id;

    let name = "Player";
    if (firstName) {
        name = firstName;
    } else if (username) {
        name = `@${username}`;
    } else if (id) {
        name = `Player ${String(id).slice(-4)}`;
    } else {
        name = "Valued Player";
    }
    return escapeMarkdownV2(name);
}

/**
 * Creates a MarkdownV2 mention link for a user object.
 * @param {object} userObject - msg.from or a fetched user object.
 * @returns {string} MarkdownV2 mention string.
 */
function createUserMention(userObject) {
    if (!userObject) return escapeMarkdownV2("Esteemed Guest");

    const id = userObject.id || userObject.telegram_id;
    if (!id) return escapeMarkdownV2("Unknown Player");

    const simpleName = userObject.first_name || userObject.firstName || userObject.username || `Player ${String(id).slice(-4)}`;
    return `[${escapeMarkdownV2(simpleName)}](tg://user?id=${id})`;
}

/**
 * Gets a player's display reference, preferring @username, falls back to name. Escapes for MarkdownV2.
 * @param {object} userObject - msg.from or a fetched user object.
 * @param {boolean} [preferUsernameTag=true] - Whether to prefer @username.
 * @returns {string} MarkdownV2 escaped player reference.
 */
function getPlayerDisplayReference(userObject, preferUsernameTag = true) {
    if (!userObject) return escapeMarkdownV2("Mystery Player");

    const username = userObject.username;
    if (preferUsernameTag && username) {
        return `@${escapeMarkdownV2(username)}`;
    }
    return getEscapedUserDisplayName(userObject); // This already escapes for MarkdownV2
}

// Helper function to escape characters for HTML content
function escapeHTML(text) {
    if (text === null || typeof text === 'undefined') return '';
    return String(text)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}

// --- START OF NEW UTILITY FUNCTIONS (to be placed in Part 3) ---

/**
 * Gets a raw display name from a user object (unescaped).
 * @param {object} userObject - msg.from or a fetched user object.
 * @returns {string} Raw display name.
 */
function getRawUserDisplayName(userObject) {
    if (!userObject) return "Valued Player"; // Default raw name
    const firstName = userObject.first_name || userObject.firstName;
    const username = userObject.username;
    const id = userObject.id || userObject.telegram_id;
    let name = "Player"; // Default raw name
    if (firstName) {
        name = firstName;
    } else if (username) {
        name = `@${username}`; // Keep @ symbol as it's part of the convention
    } else if (id) {
        name = `Player ${String(id).slice(-4)}`;
    } else {
        name = "Valued Player"; // Default raw name
    }
    return name; // Return raw name
}

/**
 * Gets a player's raw display reference (unescaped), preferring @username.
 * @param {object} userObject - msg.from or a fetched user object.
 * @param {boolean} [preferUsernameTag=true] - Whether to prefer @username.
 * @returns {string} Raw player reference.
 */
function getRawPlayerDisplayReference(userObject, preferUsernameTag = true) {
    if (!userObject) return "Mystery Player"; // Default raw name
    const username = userObject.username;
    if (preferUsernameTag && username) {
        return `@${username}`; // Keep @ symbol
    }
    return getRawUserDisplayName(userObject); // Returns raw name
}

// --- END OF NEW UTILITY FUNCTIONS ---

/**
 * Gets a user-friendly clean game name from a technical game ID string.
 * @param {string} technicalGameId - The internal game ID (e.g., GAME_IDS.COINFLIP_PVP).
 * @returns {string} A clean, user-friendly game name.
 */
function getCleanGameName(technicalGameId) {
    if (!technicalGameId) return "an unknown game";

    const lowerCaseId = String(technicalGameId).toLowerCase();

    if (lowerCaseId.startsWith("coinflip")) return "Coinflip";
    if (lowerCaseId.startsWith("rps")) return "Rock Paper Scissors";
    if (lowerCaseId.startsWith("dice_escalator")) return "Dice Escalator";
    if (lowerCaseId.startsWith("dice21")) return "Dice 21";
    if (lowerCaseId.startsWith("duel")) return "Duel";
    if (lowerCaseId.startsWith("mines")) return "Mines";
    if (lowerCaseId.startsWith("ou7") || lowerCaseId.includes("over_under_7")) return "Over/Under 7";
    if (lowerCaseId.startsWith("ladder")) return "Ladder";
    if (lowerCaseId.startsWith("sevenout") || lowerCaseId.includes("lucky_sum")) return "Lucky Sum";
    if (lowerCaseId.startsWith("slotfrenzy")) return "Slot Frenzy";
    if (lowerCaseId === GAME_IDS.DIRECT_PVP_CHALLENGE.toLowerCase()) return "a direct challenge";

    // Fallback for other cases, try to make it somewhat readable
    let cleaned = lowerCaseId.replace(/_/g, ' ');
    if (cleaned.includes("unified offer")) cleaned = cleaned.replace("unified offer", "").trim();
    if (cleaned.includes("direct challenge offer")) cleaned = cleaned.replace("direct challenge offer", "").trim();
    if (cleaned.includes("pvp from unified")) cleaned = cleaned.replace("pvp from unified", "PvP").trim();
    if (cleaned.includes("pvp")) cleaned = cleaned.replace("pvp", "PvP").trim();
    if (cleaned.includes("pvb")) cleaned = cleaned.replace("pvb", "PvB").trim();
    
    return cleaned.replace(/\b\w/g, l => l.toUpperCase());
}
// --- General Utility Functions ---

/**
 * Formats a BigInt lamports amount into a SOL string representation or raw lamports.
 * @param {bigint|string|number} amountLamports - The amount in lamports.
 * @param {string} [currencyName='SOL'] - The currency to display ('SOL' or 'lamports').
 * @param {boolean} [displayRawLamportsOverride=false] - If true, forces raw lamports.
 * @param {number} [solDecimals=SOL_DECIMALS] - Decimal places for SOL.
 * @returns {string} Formatted currency string.
 */
function formatCurrency(amountLamports, currencyName = 'SOL', displayRawLamportsOverride = false, solDecimals = SOL_DECIMALS) {
    let lamportsAsBigInt;
    try {
        lamportsAsBigInt = BigInt(amountLamports);
    } catch (e) {
        // console.warn(`[formatCurrency] Invalid amount: '${amountLamports}'. Error: ${e.message}`); // Reduced log
        return '⚠️ Amount Invalid';
    }

    if (displayRawLamportsOverride || String(currencyName).toLowerCase() === 'lamports') {
        return `${lamportsAsBigInt.toLocaleString('en-US')} lamports`;
    }

    if (typeof LAMPORTS_PER_SOL === 'undefined' || Number(LAMPORTS_PER_SOL) <= 0) {
        console.error("[formatCurrency] LAMPORTS_PER_SOL not defined or invalid. Cannot format SOL.");
        return `${lamportsAsBigInt.toLocaleString('en-US')} lamports (⚠️ SOL Config Err)`;
    }

    const solValue = Number(lamportsAsBigInt) / Number(LAMPORTS_PER_SOL);
    let effectiveDecimals = solDecimals;

    if (solValue === Math.floor(solValue)) {
        effectiveDecimals = 0;
    } else {
        const stringValue = solValue.toString();
        const decimalPart = stringValue.split('.')[1];
        if (decimalPart) {
            effectiveDecimals = Math.min(decimalPart.length, solDecimals);
        } else {
            effectiveDecimals = 0;
        }
    }
    if (effectiveDecimals > 0 && effectiveDecimals < 2 && solDecimals >= 2) {
        effectiveDecimals = 2;
    }
    if (effectiveDecimals > 0 && solDecimals < 2) {
        effectiveDecimals = solDecimals;
    }

    try {
        return `${solValue.toLocaleString('en-US', {
            minimumFractionDigits: effectiveDecimals,
            maximumFractionDigits: effectiveDecimals
        })} SOL`;
    } catch (e) {
        console.error(`[formatCurrency] Error formatting SOL for ${lamportsAsBigInt} lamports: ${e.message}`);
        return `${lamportsAsBigInt.toLocaleString('en-US')} lamports (⚠️ Format Err)`;
    }
}

/**
 * Formats a BigInt lamports amount for display, defaulting to USD, with fallbacks.
 * @param {bigint|string|number} lamports - The amount in lamports.
 * @param {string} [targetCurrency='USD'] - Target currency ('USD', 'SOL', or 'lamports').
 * @returns {Promise<string>} Formatted currency string.
 */
async function formatBalanceForDisplay(lamports, targetCurrency = 'USD') {
    let lamportsAsBigInt;
    try {
        lamportsAsBigInt = BigInt(lamports);
    } catch (e) {
        // console.warn(`[formatBalanceForDisplay] Invalid lamport amount: '${lamports}'. Error: ${e.message}`); // Reduced log
        return '⚠️ Amount Invalid';
    }

    const upperTargetCurrency = String(targetCurrency).toUpperCase();

    if (upperTargetCurrency === 'USD') {
        try {
            if (typeof getSolUsdPrice !== 'function' || typeof convertLamportsToUSDString !== 'function') {
                console.error("[formatBalanceForDisplay] Price conversion functions not available. Falling back to SOL.");
                return formatCurrency(lamportsAsBigInt, 'SOL');
            }
            const price = await getSolUsdPrice();
            return convertLamportsToUSDString(lamportsAsBigInt, price);
        } catch (e) {
            console.error(`[formatBalanceForDisplay] Failed to get SOL/USD price for USD display: ${e.message}. Falling back to SOL.`);
            return formatCurrency(lamportsAsBigInt, 'SOL');
        }
    } else if (upperTargetCurrency === 'LAMPORTS') {
        return formatCurrency(lamportsAsBigInt, 'lamports', true);
    }
    // Default to SOL
    return formatCurrency(lamportsAsBigInt, 'SOL');
}

/**
 * Generates a unique-ish ID for game instances.
 * @param {string} [prefix="game"] - Prefix for the game ID.
 * @returns {string} A game ID.
 */
function generateGameId(prefix = "game") {
  const timestamp = Date.now().toString(36);
  const randomSuffix = Math.random().toString(36).substring(2, 10);
  return `${prefix}_${timestamp}_${randomSuffix}`;
}

// --- Dice Display Utilities ---

/**
 * Formats an array of dice roll numbers into a string with emoji and number.
 * @param {number[]} rollsArray - Array of dice roll numbers.
 * @param {string} [diceEmoji='🎲'] - Emoji to use for dice.
 * @returns {string} Formatted dice rolls string.
 */
function formatDiceRolls(rollsArray, diceEmoji = '🎲') {
  if (!Array.isArray(rollsArray) || rollsArray.length === 0) return '';
  const diceVisuals = rollsArray.map(roll => {
      const rollValue = Number(roll);
      return `${diceEmoji} ${isNaN(rollValue) ? '?' : rollValue}`;
  });
  return diceVisuals.join(' \u00A0 '); // Non-breaking spaces for better layout
}

/**
 * Generates an internal dice roll.
 * @param {number} [sides=6] - Number of sides on the die.
 * @returns {number} Result of the die roll.
 */
function rollDie(sides = 6) {
  sides = Number.isInteger(sides) && sides > 1 ? sides : 6;
  return Math.floor(Math.random() * sides) + 1;
}

// --- Payment Transaction ID Generation (Optional Utility) ---
/**
 * Generates a unique transaction ID for internal tracking of payments/ledger entries.
 * @param {string} type - Type of payment/ledger entry.
 * @param {string} [userId='system'] - Optional user ID.
 * @returns {string} A unique-ish transaction ID.
 */
function generateInternalPaymentTxId(type, userId = 'system') {
    const now = Date.now().toString(36);
    let randomPart;
    if (typeof crypto !== 'undefined' && typeof crypto.randomBytes === 'function') {
        randomPart = crypto.randomBytes(4).toString('hex');
    } else {
        // console.warn('[GenInternalTxId] Crypto module not available for random part. Using Math.random.'); // Reduced log
        randomPart = Math.random().toString(36).substring(2, 10);
    }

    const userPartCleaned = String(userId).replace(/[^a-zA-Z0-9_]/g, '').slice(0, 10) || 'sys';
    let prefix = String(type).toLowerCase().substring(0, 6).replace(/[^a-z0-9_]/g, '') || 'gen';

    return `${prefix}_${userPartCleaned}_${now}_${randomPart}`;
}

// --- REVISED Group Game Session Management Functions ---

/**
 * Retrieves or creates a game session for a specific group chat.
 * Interacts with the global `groupGameSessions` Map.
 * `activeGamesByTypeInGroup` now stores an array of game IDs for each family/activity key.
 * @param {string} chatId - The ID of the Telegram group chat.
 * @param {string | null} chatTitle - The title of the group chat (can be null if just updating).
 * @returns {Promise<object>} The group session object.
 */
async function getGroupSession(chatId, chatTitle = null) {
    const stringChatId = String(chatId);
    const logPrefix = `[GetGroupSession CH:${stringChatId} V2_ArrayStore]`;

    if (groupGameSessions.has(stringChatId)) {
        const session = groupGameSessions.get(stringChatId);
        if (chatTitle && (!session.title || session.title.startsWith("Group Chat"))) {
            session.title = chatTitle;
        }
        // Ensure activeGamesByTypeInGroup exists and is a Map (it should be if initialized correctly)
        if (!(session.activeGamesByTypeInGroup instanceof Map)) {
            console.warn(`${logPrefix} activeGamesByTypeInGroup was not a Map for existing session. Re-initializing.`);
            session.activeGamesByTypeInGroup = new Map(); // Key: familyActivityKey, Value: Array<gameId>
        }
        return session;
    } else {
        const newSession = {
            id: stringChatId,
            title: chatTitle || `Group Chat ${stringChatId}`,
            activeGamesByTypeInGroup: new Map(), // Key: familyActivityKey, Value: Array<gameId>
            lastActivity: Date.now(),
            activePlayers: {}, // Kept for now, usage might need review based on game logic
        };
        groupGameSessions.set(stringChatId, newSession);
        console.log(`${logPrefix} New session created with activeGamesByTypeInGroup (Map of arrays).`);
        return newSession;
    }
}

/**
 * Updates the list of active games/offers for a specific family/activity type in a group session.
 * If gameIdToAddOrRemove is a string, it's added to the list for familyActivityKey.
 * If gameIdToAddOrRemove is an object like { removeThisId: 'someGameId' }, that ID is removed.
 * If gameIdToAddOrRemove is null, a warning is logged as removal requires a specific ID.
 * @param {string} chatId - The ID of the Telegram group chat.
 * @param {string | { removeThisId: string } | null} gameIdToAddOrRemove - The ID of the game/offer to add, or an object specifying an ID to remove, or null (which does nothing for removal).
 * @param {string | null} familyActivityKey - The key representing the game family and activity type (e.g., 'UNIFIED_OFFER_COINFLIP', 'ACTIVE_GAME_RPS').
 * @param {bigint | number | null} betAmount - The bet amount (optional, primarily for logging or if needed by other logic).
 */
async function updateGroupGameDetails(chatId, gameIdToAddOrRemove, familyActivityKey, betAmount) {
    const stringChatId = String(chatId);
    const logPrefix = `[UpdateGroupGameDetails CH:${stringChatId} FamKey:${familyActivityKey || 'N/A'} V2_ArrayStore_DebugLog]`; // Added DebugLog to version

    console.log(`${logPrefix} Entry. gameIdToAddOrRemove: ${typeof gameIdToAddOrRemove === 'object' ? JSON.stringify(gameIdToAddOrRemove) : gameIdToAddOrRemove}, familyActivityKey: ${familyActivityKey}`);

    const session = await getGroupSession(stringChatId, null); // Ensures session and activeGamesByTypeInGroup map exist

    if (!familyActivityKey) {
        console.warn(`${logPrefix} Attempted to update/clear game details without specifying a familyActivityKey. Action skipped.`);
        session.lastActivity = Date.now();
        return;
    }

    // Ensure an array exists for this familyActivityKey
    if (!session.activeGamesByTypeInGroup.has(familyActivityKey)) {
        console.log(`${logPrefix} Initializing new empty array for FamilyKey=${familyActivityKey}.`);
        session.activeGamesByTypeInGroup.set(familyActivityKey, []);
    }
    
    const activeIdsForFamily = session.activeGamesByTypeInGroup.get(familyActivityKey);
    console.log(`${logPrefix} List for FamilyKey='${familyActivityKey}' BEFORE operation: [${activeIdsForFamily.join(', ')}] (Length: ${activeIdsForFamily.length})`);

    if (typeof gameIdToAddOrRemove === 'string') {
        // Add a new game/offer ID
        const gameIdToAdd = gameIdToAddOrRemove;
        if (!activeIdsForFamily.includes(gameIdToAdd)) {
            activeIdsForFamily.push(gameIdToAdd);
            console.log(`${logPrefix} Added GameID='${gameIdToAdd}' to FamilyKey='${familyActivityKey}'. New list: [${activeIdsForFamily.join(', ')}]. Current count: ${activeIdsForFamily.length}.`);
        } else {
            console.warn(`${logPrefix} Attempted to add already existing GameID='${gameIdToAdd}' to FamilyKey='${familyActivityKey}'. No change to list.`);
        }
    } else if (gameIdToAddOrRemove && typeof gameIdToAddOrRemove.removeThisId === 'string') {
        // Remove a specific game/offer ID
        const gameIdToRemove = gameIdToAddOrRemove.removeThisId;
        console.log(`${logPrefix} Attempting to remove GameID='${gameIdToRemove}' from FamilyKey='${familyActivityKey}'.`);
        const index = activeIdsForFamily.indexOf(gameIdToRemove);
        console.log(`${logPrefix} Index of '${gameIdToRemove}' in list: ${index}.`);

        if (index > -1) {
            activeIdsForFamily.splice(index, 1);
            console.log(`${logPrefix} Successfully removed GameID='${gameIdToRemove}' from FamilyKey='${familyActivityKey}'. New list: [${activeIdsForFamily.join(', ')}]. Current count: ${activeIdsForFamily.length}.`);
        } else {
            console.warn(`${logPrefix} Attempted to remove GameID='${gameIdToRemove}' from FamilyKey='${familyActivityKey}', but it was NOT FOUND in current list: [${activeIdsForFamily.join(', ')}]. List remains unchanged.`);
        }
    } else if (gameIdToAddOrRemove === null) {
        // This case is now problematic for removal if multiple games of the same type exist.
        // The calling code MUST be updated to pass a specific gameId for removal.
        console.warn(`${logPrefix} Received null gameId for FamilyKey=${familyActivityKey}. ` +
                     `Cannot determine which game to remove if multiple exist for this key. ` +
                     `No change made to the list. Current list: [${activeIdsForFamily.join(', ')}]. ` +
                     `Ensure calling code provides a specific ID for removal.`);
    } else {
        console.warn(`${logPrefix} Invalid gameIdToAddOrRemove parameter type: ${typeof gameIdToAddOrRemove}. Expected string or { removeThisId: string }. Value: ${JSON.stringify(gameIdToAddOrRemove)}`);
    }

    console.log(`${logPrefix} List for FamilyKey='${familyActivityKey}' AFTER operation: [${activeIdsForFamily.join(', ')}] (Length: ${activeIdsForFamily.length})`);
    session.lastActivity = Date.now();
    // groupGameSessions.set(stringChatId, session); // Not strictly necessary if session is a direct reference and activeGamesByTypeInGroup is mutated in place.
}
// --- End of REVISED Group Game Session Management Functions ---

// --- NEW Referral System Core Logic Functions ---
// (Place these in a suitable section, e.g., after database utilities or before command handlers)

/**
 * Counts the number of successful referrals for a user.
 * A successful referral is one where the referred user has placed their first qualifying bet.
 * @param {string|number} referrerUserId - The Telegram ID of the referrer.
 * @param {import('pg').PoolClient} [dbClient=pool] - Optional database client.
 * @returns {Promise<number>} The count of successful referrals.
 */
async function getReferralCount(referrerUserId, dbClient = pool) {
    const LOG_PREFIX_GRC = `[GetReferralCount UID:${referrerUserId}]`;
    try {
        // Counts referrals where the qualifying bet has been processed.
        // This assumes 'qualifying_bet_processed_at' is set when the initial bonus is handled.
        const query = `SELECT COUNT(*) AS referral_count FROM referrals WHERE referrer_telegram_id = $1 AND qualifying_bet_processed_at IS NOT NULL;`;
        const result = await queryDatabase(query, [String(referrerUserId)], dbClient);
        if (result.rows.length > 0) {
            return parseInt(result.rows[0].referral_count, 10) || 0;
        }
        return 0;
    } catch (error) {
        console.error(`${LOG_PREFIX_GRC} Error fetching referral count: ${error.message}`);
        return 0; // Return 0 on error to prevent issues in calling functions
    }
}

/**
 * Calculates the Initial Bet Bonus percentage based on the referrer's referral count.
 * @param {number} referralCount - The number of successful referrals the referrer has.
 * @param {Array<object>} referralTiersConfig - The configuration for referral tiers (e.g., REFERRAL_INITIAL_BET_TIERS_CONFIG).
 * @returns {number} The bonus percentage (e.g., 0.05 for 5%).
 */
function calculateInitialBetBonusPercentage(referralCount, referralTiersConfig) {
    let applicablePercentage = 0;
    // Iterate through tiers to find the highest applicable one
    for (const tier of referralTiersConfig) {
        if (referralCount <= tier.upToReferrals) {
            applicablePercentage = tier.percentage;
            break; // Found the correct tier
        }
    }
    // If referralCount exceeds all defined 'upToReferrals' (except Infinity), use the last tier's percentage
    if (applicablePercentage === 0 && referralTiersConfig.length > 0) {
         const highestFiniteTier = referralTiersConfig.filter(t => t.upToReferrals !== Infinity).pop();
         const infiniteTier = referralTiersConfig.find(t => t.upToReferrals === Infinity);
         if (referralCount > (highestFiniteTier?.upToReferrals || 0) && infiniteTier) {
            applicablePercentage = infiniteTier.percentage;
         } else if (highestFiniteTier) {
             applicablePercentage = highestFiniteTier.percentage; // Fallback to highest defined finite tier if something went wrong
         }
    }
    return applicablePercentage;
}

/**
 * REFACTORED to queue a job for the Initial Bet Bonus instead of paying directly.
 * @param {import('pg').PoolClient} dbClient - The active database client for the transaction.
 * @param {string|number} referredUserTelegramId - The Telegram ID of the user who placed the bet.
 * @param {bigint} referredUserBetAmountLamports - The amount of the bet in lamports.
 * @param {string} gameIdForBet - The game ID for which the bet was placed (for ledger notes).
 * @returns {Promise<{success: boolean, jobQueued?: boolean, error?: string}>}
 */
// CORRECTED processQualifyingBetAndInitialBonus (Fixes referral tracking)
async function processQualifyingBetAndInitialBonus(dbClient, referredUserTelegramId, referredUserBetAmountLamports, gameIdForBet) {
    const stringReferredUserId = String(referredUserTelegramId);
    const LOG_PREFIX_PQB = `[ProcessQualifyingBet_V4_LogicFix UID:${stringReferredUserId}]`;

    try {
        const referredUserDetails = await dbClient.query(
            `SELECT telegram_id, referrer_telegram_id, first_bet_placed_at FROM users WHERE telegram_id = $1 FOR UPDATE`,
            [stringReferredUserId]
        );
        if (referredUserDetails.rowCount === 0 || !referredUserDetails.rows[0].referrer_telegram_id) {
            return { success: true, jobQueued: false, message: "Not a referred user." };
        }
        if (referredUserDetails.rows[0].first_bet_placed_at) {
            return { success: true, jobQueued: false, message: "Initial bonus already handled." };
        }
        
        const solPrice = await getSolUsdPrice();
        const betAmountUSD = Number(referredUserBetAmountLamports) / Number(LAMPORTS_PER_SOL) * solPrice;
        
        // --- LOGIC FIX IS HERE ---
        // First, check if the bet is large enough to qualify.
        if (betAmountUSD < REFERRAL_QUALIFYING_BET_USD_CONST) {
            // DO NOT set the timestamp here. The user can still make a qualifying "first bet" later.
            return { success: true, jobQueued: false, message: "Bet too small to qualify. User can try again." };
        }
        
        // If we get here, the bet IS a qualifying bet. NOW we set the timestamp.
        await dbClient.query(`UPDATE users SET first_bet_placed_at = NOW() WHERE telegram_id = $1 AND first_bet_placed_at IS NULL`, [stringReferredUserId]);
        // --- END OF LOGIC FIX ---

        const referrerId = String(referredUserDetails.rows[0].referrer_telegram_id);
        const referrerData = await dbClient.query(`SELECT referral_count FROM users WHERE telegram_id = $1 FOR UPDATE`, [referrerId]);
        const currentReferrerCount = referrerData.rows.length > 0 ? (referrerData.rows[0].referral_count || 0) : 0;
        
        const bonusPercentage = calculateInitialBetBonusPercentage(currentReferrerCount, REFERRAL_INITIAL_BET_TIERS_CONFIG);
        const initialBonusAmountLamports = BigInt(Math.floor(Number(referredUserBetAmountLamports) * bonusPercentage));

        if (initialBonusAmountLamports <= 0n) {
            console.log(`${LOG_PREFIX_PQB} Calculated initial bonus is zero. No commission created.`);
            return { success: true, jobQueued: false, message: "Bonus amount was zero." };
        }

        const commissionRecordResult = await dbClient.query(
            `UPDATE referrals SET commission_type = 'initial_bet_bonus', commission_amount_lamports = $1, status = 'bonus_queued', qualifying_bet_processed_at = NOW()
             WHERE referrer_telegram_id = $2 AND referred_telegram_id = $1 AND qualifying_bet_processed_at IS NULL
             RETURNING referral_id;`,
            [stringReferredUserId, referrerId]
        );

        if (commissionRecordResult.rowCount > 0) {
            const referralDbId = commissionRecordResult.rows[0].referral_id;
            await dbClient.query(`UPDATE users SET referral_count = referral_count + 1 WHERE telegram_id = $1`, [referrerId]);

            const jobPayload = {
                targetUserId: referrerId,
                amountLamports: initialBonusAmountLamports.toString(),
                transactionType: 'referral_commission_credit',
                notes: `Initial Bet Bonus from user ${stringReferredUserId}. Original Referral ID: ${referralDbId}`
            };

            await dbClient.query(
                `INSERT INTO background_jobs (job_type, payload) VALUES ('credit_user_balance', $1)`,
                [jobPayload]
            );
            
            console.log(`${LOG_PREFIX_PQB} Initial bet bonus of ${initialBonusAmountLamports} lamports for referrer ${referrerId} has been QUEUED.`);
            
            return { success: true, jobQueued: true };
        } else {
            console.warn(`${LOG_PREFIX_PQB} No pending referral found to update for initial bonus.`);
            return { success: true, jobQueued: false, message: "No pending referral link found." };
        }
    } catch (error) {
        console.error(`${LOG_PREFIX_PQB} Error processing qualifying bet and initial bonus: ${error.message}`, error.stack);
        return { success: false, jobQueued: false, error: error.message };
    }
}


/**
 * REFACTORED to queue a job for the Wager Milestone Bonus instead of paying directly.
 * @param {import('pg').PoolClient} dbClient - The active database client.
 * @param {string|number} referredUserTelegramId - The Telegram ID of the user whose wager is being checked.
 * @param {bigint} newTotalWageredLamportsByReferred - The new total wagered amount by the referred user.
 * @returns {Promise<{success: boolean, jobsQueued: number, error?: string}>}
 */
async function processWagerMilestoneBonus(dbClient, referredUserTelegramId, newTotalWageredLamportsByReferred, solPrice) {
    const stringReferredUserId = String(referredUserTelegramId);
    const LOG_PREFIX_PWM = `[ProcessWagerMilestone_V8_AsyncJob UID:${stringReferredUserId}]`;
    let jobsQueued = 0;

    try {
        // Lock the referral row to prevent concurrent milestone processing for the same user
        const referralLinkDetailsRes = await dbClient.query(
            `SELECT referral_id, referrer_telegram_id, referred_user_wager_milestones_achieved FROM referrals r WHERE r.referred_telegram_id = $1 FOR UPDATE`,
            [stringReferredUserId]
        );

        if (referralLinkDetailsRes.rowCount === 0) {
            return { success: true, jobsQueued: 0 }; // Not a referred user
        }

        const referralLink = referralLinkDetailsRes.rows[0];
        const referrerId = String(referralLink.referrer_telegram_id);
        let achievedMilestonesData = referralLink.referred_user_wager_milestones_achieved || {};
        
        if (!solPrice || solPrice <= 0) {
             console.warn(`${LOG_PREFIX_PWM} Invalid SOL price provided (${solPrice}). Skipping milestone check.`);
             return { success: true, jobsQueued: 0 };
        }

        const totalWageredUSD = Number(newTotalWageredLamportsByReferred) / Number(LAMPORTS_PER_SOL) * solPrice;
        let milestonesUpdated = false;

        for (const milestoneUSD of REFERRAL_WAGER_MILESTONES_USD_CONFIG) {
            const milestoneKey = `${milestoneUSD}_USD_WAGERED`;
            
            if (totalWageredUSD >= milestoneUSD && !achievedMilestonesData[milestoneKey]) {
                const milestoneBonusAmountLamports = BigInt(Math.floor(milestoneUSD * solPrice * REFERRAL_WAGER_MILESTONE_BONUS_PERCENTAGE_CONST));

                if (milestoneBonusAmountLamports > 0n) {
                    // --- THIS IS THE KEY CHANGE ---
                    // Queue a job instead of paying directly, now with more detailed payload.
                    const jobPayload = {
                        targetUserId: referrerId,
                        amountLamports: milestoneBonusAmountLamports.toString(),
                        transactionType: 'referral_milestone_bonus',
                            referralId: referralLink.referral_id, // Add unique referral ID
                            milestoneKey: milestoneKey, // Add unique milestone key
                        notes: `Wager Milestone Bonus ($${milestoneUSD}) from referred user ${stringReferredUserId}.`
                    };

                    await dbClient.query(
                        `INSERT INTO background_jobs (job_type, payload) VALUES ('credit_user_balance', $1)`,
                        [jobPayload]
                    );
                    jobsQueued++;
                    console.log(`${LOG_PREFIX_PWM} Queued $${milestoneUSD} milestone bonus job for referrer ${referrerId}.`);
                }

                achievedMilestonesData[milestoneKey] = new Date().toISOString();
                milestonesUpdated = true;
            }
        }

        if (milestonesUpdated) {
            await dbClient.query(
                `UPDATE referrals SET referred_user_wager_milestones_achieved = $1, last_milestone_bonus_check_wager_lamports = $2 WHERE referral_id = $3;`,
                [achievedMilestonesData, newTotalWageredLamportsByReferred.toString(), referralLink.referral_id]
            );
        }
        
        return { success: true, jobsQueued };

    } catch (error) {
        console.error(`${LOG_PREFIX_PWM} Error processing wager milestone bonuses: ${error.message}`, error.stack);
        // Do not throw; allow the main transaction to continue.
        return { success: false, jobsQueued: 0, error: error.message };
    }
}

// REVISED AND CORRECTED - handleClaimMilestoneBonus
async function handleClaimMilestoneBonus(userIdClicking, commissionReferralId, dbClient) {
    const LOG_PREFIX_HCMB = `[ClaimMilestoneBonus_V2_InternalCredit UID:${userIdClicking} CommID:${commissionReferralId}]`;

    try {
        // 1. Fetch and lock the specific milestone bonus record to prevent race conditions.
        const commissionRes = await dbClient.query(
            `SELECT * FROM referrals WHERE referral_id = $1 AND referrer_telegram_id = $2 AND status = 'milestone_bonus_claimable' FOR UPDATE`,
            [commissionReferralId, userIdClicking]
        );

        if (commissionRes.rowCount === 0) {
            return { success: false, error: "This milestone bonus is not available, already claimed, or does not belong to you." };
        }
        const commissionData = commissionRes.rows[0];
        const commissionAmountLamports = BigInt(commissionData.commission_amount_lamports);
        
        // --- THIS IS THE KEY CHANGE ---
        // Instead of queueing a job, we credit the balance and finalize the record.

        // 2. Credit the referrer's internal balance
        const creditResult = await updateUserBalanceAndLedger(
            dbClient,
            userIdClicking,
            commissionAmountLamports,
            'referral_commission_credit',
            { referral_id: commissionReferralId },
            `Milestone Bonus: ${commissionData.commission_type}`
        );

        if (!creditResult.success) {
            throw new Error(creditResult.error || "Failed to credit milestone bonus to user balance.");
        }

        // 3. Update its status to 'paid_out'.
        await dbClient.query(
            `UPDATE referrals SET status = 'paid_out', updated_at = NOW() WHERE referral_id = $1`,
            [commissionReferralId]
        );

        console.log(`${LOG_PREFIX_HCMB} Milestone bonus ${commissionReferralId} credited to internal balance. Amount: ${commissionAmountLamports}`);

        const bonusAmountUSDDisplay = await formatBalanceForDisplay(commissionAmountLamports, 'USD');
        return { success: true, messageForUser: `Milestone bonus of approx. ${escapeHTML(bonusAmountUSDDisplay)} claimed! It has been added to your casino balance.` };

    } catch (error) {
        console.error(`${LOG_PREFIX_HCMB} Error claiming milestone bonus: ${error.message}`);
        return { success: false, error: error.message || "Could not claim bonus at this time." };
    }
}

// --- End of NEW Referral System Core Logic Functions ---

// =================================================================================
// --- NEW: ROBUST BACKGROUND JOB PROCESSOR (IMPLEMENTING IDEMPOTENCY & DEAD-LETTER QUEUE) ---
// This system processes tasks like referral payouts asynchronously to prevent deadlocks.
// =================================================================================

let isJobProcessorRunning = false; // Prevents the processor from running concurrently
const JOB_PROCESSOR_INTERVAL_MS = 10000; // Run every 10 seconds
const MAX_JOB_ATTEMPTS = 3; // Max number of times a job will be attempted

async function processBackgroundJobs() {
    if (isShuttingDown) return;
    if (isJobProcessorRunning) return;

    isJobProcessorRunning = true;
    const LOG_PREFIX = '[JobProcessor_V2_Robust]';

    let jobsToProcess = [];
    let mainClient = null;

    try {
        mainClient = await pool.connect();
        const jobsResult = await mainClient.query(
            `SELECT job_id FROM background_jobs WHERE status = 'pending' AND process_after <= NOW() ORDER BY created_at ASC LIMIT 5 FOR UPDATE SKIP LOCKED`
        );
        if (jobsResult.rows.length > 0) {
            jobsToProcess = jobsResult.rows.map(r => r.job_id);
            await mainClient.query(`UPDATE background_jobs SET status = 'running', attempts = attempts + 1, last_attempt_at = NOW() WHERE job_id = ANY($1::int[])`, [jobsToProcess]);
        }
    } catch (e) {
        console.error(`${LOG_PREFIX} Error fetching jobs:`, e);
    } finally {
        if (mainClient) mainClient.release();
    }

    if (jobsToProcess.length === 0) {
        isJobProcessorRunning = false;
        return;
    }

    console.log(`${LOG_PREFIX} Picked up ${jobsToProcess.length} jobs to process.`);

    for (const jobId of jobsToProcess) {
        if (isShuttingDown) break;

        let jobClient = null;
        let job = null;

        try {
            const jobDataRes = await queryDatabase('SELECT * FROM background_jobs WHERE job_id = $1', [jobId]);
            if (jobDataRes.rows.length === 0) continue;
            job = jobDataRes.rows[0];

            jobClient = await pool.connect();
            await jobClient.query('BEGIN');

            if (job.job_type === 'credit_user_balance') {
                const { targetUserId, amountLamports, transactionType, notes, referralId, milestoneKey } = job.payload;

                if (!targetUserId || !amountLamports || !transactionType) {
                    throw new Error(`Invalid payload for job ${jobId}: Missing required fields.`);
                }
                
                // --- IDEMPOTENCY CHECK ---
                let uniqueActionId;
                if (transactionType === 'referral_commission_credit' && notes.includes('Initial Bet Bonus')) {
                    const parsedReferralId = notes.match(/Referral ID: (\d+)/)[1];
                    uniqueActionId = `credit-initial-bonus-${parsedReferralId}`;
                } else if (transactionType === 'referral_milestone_bonus' && referralId && milestoneKey) {
                    uniqueActionId = `credit-milestone-${referralId}-${milestoneKey}`;
                } else {
                    // Fallback for other credit types - may not be idempotent without a unique key in payload
                    uniqueActionId = `credit-${transactionType}-${targetUserId}-${Date.now()}`; // Non-deterministic, less safe
                    console.warn(`${LOG_PREFIX} Job ${jobId} of type ${transactionType} does not have a deterministic unique ID. Idempotency not guaranteed.`);
                }

                try {
                    await jobClient.query(
                        'INSERT INTO processed_job_actions (action_id, job_id) VALUES ($1, $2)',
                        [uniqueActionId, jobId]
                    );
                } catch (e) {
                    if (e.code === '23505') { // Unique violation
                        console.warn(`${LOG_PREFIX} Action ${uniqueActionId} for job ${jobId} has already been processed. Skipping duplicate execution and deleting job.`);
                        await jobClient.query('DELETE FROM background_jobs WHERE job_id = $1', [jobId]);
                        await jobClient.query('COMMIT');
                        continue; // Move to the next job
                    }
                    throw e; // Re-throw other errors
                }
                // --- END OF IDEMPOTENCY CHECK ---

                const creditResult = await updateUserBalanceAndLedger(
                    jobClient,
                    targetUserId,
                    BigInt(amountLamports),
                    transactionType,
                    { background_job_id: jobId },
                    notes || 'Bonus credit from background job.'
                );

                if (!creditResult.success) {
                    throw new Error(creditResult.error || 'Failed to apply credit within updateUserBalanceAndLedger.');
                }
                
                const bonusAmountUSDDisplay = await formatBalanceForDisplay(amountLamports, 'USD');
                const bonusAmountSOLDisplay = formatCurrency(amountLamports, 'SOL');

                await safeSendMessage(targetUserId,
                    `🎉 Cha-ching! A bonus of approx. *${escapeMarkdownV2(bonusAmountUSDDisplay)}* (${escapeMarkdownV2(bonusAmountSOLDisplay)}) has been added to your casino balance!`,
                    { parse_mode: 'MarkdownV2' }
                );
            }
            
                // On success, delete the job instead of marking it 'completed'
            await jobClient.query('DELETE FROM background_jobs WHERE job_id = $1', [jobId]);
            await jobClient.query('COMMIT');
            console.log(`${LOG_PREFIX} ✅ Successfully processed and deleted job ${jobId}.`);

        } catch (err) {
            if (jobClient) await jobClient.query('ROLLBACK').catch(rbErr => console.error(`${LOG_PREFIX} Rollback failed for job ${jobId}`, rbErr));
            console.error(`${LOG_PREFIX} ❌ Error processing job ${jobId} on attempt ${job?.attempts || 'N/A'}:`, err);

            // --- DEAD-LETTER QUEUE & RETRY LOGIC ---
            if (job && job.attempts >= MAX_JOB_ATTEMPTS) {
                console.error(`${LOG_PREFIX} Job ${jobId} reached max retries. Moving to failed_jobs.`);
                const moveClient = await pool.connect();
                try {
                    await moveClient.query('BEGIN');
                    await moveClient.query(
                        `INSERT INTO failed_jobs (job_id, job_type, payload, status, attempts, last_attempt_at, final_error_message, created_at)
                         SELECT job_id, job_type, payload, status, attempts, last_attempt_at, $2, created_at FROM background_jobs WHERE job_id = $1`,
                         [jobId, err.message]
                    );
                    await moveClient.query('DELETE FROM background_jobs WHERE job_id = $1', [jobId]);
                    await moveClient.query('COMMIT');
                    if (typeof notifyAdmin === 'function') {
                        notifyAdmin(`☠️ *Job Failed Permanently* ☠️\nJob \`${jobId}\` (${job.job_type}) moved to dead-letter queue after ${job.attempts} attempts.\nFinal Error: \`${escapeMarkdownV2(err.message)}\``);
                    }
                } catch (moveError) {
                    await moveClient.query('ROLLBACK');
                    console.error(`${LOG_PREFIX} CRITICAL: FAILED TO MOVE JOB ${jobId} TO failed_jobs TABLE!`, moveError);
                    if (typeof notifyAdmin === 'function') notifyAdmin(`🚨 CRITICAL: FAILED TO MOVE JOB ${jobId} TO failed_jobs TABLE! It will be retried indefinitely.`);
                } finally {
                    moveClient.release();
                }
            } else if (job) {
                // Not max retries yet, schedule for another attempt with exponential backoff
                const delaySeconds = Math.pow(2, job.attempts) * 5; // e.g., 10s, 20s, 40s
                const processAfter = new Date(Date.now() + delaySeconds * 1000);
                console.log(`${LOG_PREFIX} Scheduling job ${jobId} for retry after ${delaySeconds} seconds.`);
                await queryDatabase(
                    `UPDATE background_jobs SET status = 'pending', error_message = $1, process_after = $2 WHERE job_id = $3`,
                    [err.message, processAfter, jobId]
                );
            }

        } finally {
            if (jobClient) jobClient.release();
        }
    }

    isJobProcessorRunning = false;
}

// In your main bot startup logic, after the database is initialized and `bot` is defined,
// add this line to start the processor. For example, near the bottom before the bot listeners.
// setInterval(processBackgroundJobs, JOB_PROCESSOR_INTERVAL_MS);

console.log(`[System] Starting background job processor. Interval: ${JOB_PROCESSOR_INTERVAL_MS / 1000} seconds.`);
setInterval(processBackgroundJobs, JOB_PROCESSOR_INTERVAL_MS);
// --- End of Part 3 (REVISED for new Group Session Lock Management) ---
// --- Start of Part 4 --- (Ensure this is placed correctly in your file structure)
// index.js - Part 4: Simplified Game Logic (Enhanced)
//---------------------------------------------------------------------------
// Assumes rollDie (from Part 3) is available.
// Assumes escapeHTML (from Part 3) is available if dynamic names needed further escaping,
// but player1Name/player2Name are expected to be pre-escaped HTML.

// --- Coinflip Logic ---
/**
 * Determines the outcome of a coin flip.
 * @returns {object} Object with outcome ('heads'/'tails'), outcomeString ("Heads"/"Tails"), and emoji.
 */
function determineCoinFlipOutcome() {
  const isHeads = Math.random() < 0.5;
  return isHeads
    ? { outcome: 'heads', outcomeString: "Heads", emoji: '🪙' }
    : { outcome: 'tails', outcomeString: "Tails", emoji: '🪙' };
}

// --- Dice Logic (Internal for Bot's Turn or Fallback) ---
/**
 * Determines the outcome for an internal die roll.
 * Uses the `rollDie` function.
 * @param {number} [sides=6] - Number of sides for the die.
 * @returns {object} Object with the roll result and emoji.
 */
function determineDieRollOutcome(sides = 6) {
  if (typeof rollDie !== 'function') {
     console.error("[DetermineDieRollOutcome] CRITICAL Error: rollDie function is not defined. Fallback to 1.");
     return { roll: 1, emoji: '🎲' };
  }
  sides = Number.isInteger(sides) && sides > 1 ? sides : 6;
  const roll = rollDie(sides);

  return { roll: roll, emoji: '🎲' };
}

// --- Rock Paper Scissors (RPS) Logic ---
const RPS_CHOICES = {
  ROCK: 'rock',
  PAPER: 'paper',
  SCISSORS: 'scissors'
};
const RPS_EMOJIS = { // Emojis are generally safe for HTML/MarkdownV2
  [RPS_CHOICES.ROCK]: '🪨',
  [RPS_CHOICES.PAPER]: '📄',
  [RPS_CHOICES.SCISSORS]: '✂️'
};
// Defines what each choice beats and the verb for the action.
const RPS_RULES = {
  [RPS_CHOICES.ROCK]: { beats: RPS_CHOICES.SCISSORS, verb: "crushes" },
  [RPS_CHOICES.PAPER]: { beats: RPS_CHOICES.ROCK, verb: "covers" },
  [RPS_CHOICES.SCISSORS]: { beats: RPS_CHOICES.PAPER, verb: "cuts" }
};

/**
 * Gets a random RPS choice for the bot or an opponent.
 * @returns {object} Object with the choice key and emoji.
 */
function getRandomRPSChoice() {
  const choicesArray = Object.values(RPS_CHOICES);
  const randomChoiceKey = choicesArray[Math.floor(Math.random() * choicesArray.length)];
  return { choice: randomChoiceKey, emoji: RPS_EMOJIS[randomChoiceKey] };
}

/**
 * Determines the outcome of an RPS match given two choices.
 * @param {string} player1ChoiceKey - Player 1's choice (e.g., RPS_CHOICES.ROCK).
 * @param {string} player2ChoiceKey - Player 2's choice.
 * @param {string} [player1NameHtml="Player 1"] - HTML-safe name of player 1.
 * @param {string} [player2NameHtml="Player 2"] - HTML-safe name of player 2.
 * @returns {object} A detailed result object including:
 * - result: 'win_player1', 'win_player2', 'draw', or 'error'.
 * - description: An HTML-formatted string.
 * - player1: { choice, emoji, choiceFormatted }.
 * - player2: { choice, emoji, choiceFormatted }.
 */
function determineRPSOutcome(player1ChoiceKey, player2ChoiceKey, player1NameHtml = "Player 1", player2NameHtml = "Player 2") {
  const LOG_PREFIX_RPS_OUTCOME = "[RPS_Outcome_V3_HTML]";

  const p1c = String(player1ChoiceKey).toLowerCase();
  const p2c = String(player2ChoiceKey).toLowerCase();

  if (!Object.values(RPS_CHOICES).includes(p1c) || !Object.values(RPS_CHOICES).includes(p2c)) {
    console.warn(`${LOG_PREFIX_RPS_OUTCOME} Invalid choices: P1='${player1ChoiceKey}', P2='${player2ChoiceKey}'.`);
    return {
        result: 'error',
        description: "An internal error occurred due to invalid RPS choices. Please try again.",
        player1: { choice: player1ChoiceKey, emoji: '❓', choiceFormatted: 'Invalid' },
        player2: { choice: player2ChoiceKey, emoji: '❓', choiceFormatted: 'Invalid' }
    };
  }

  const p1Emoji = RPS_EMOJIS[p1c];
  const p2Emoji = RPS_EMOJIS[p2c];
  const p1ChoiceFormatted = escapeHTML(p1c.charAt(0).toUpperCase() + p1c.slice(1)); // Escape for safety if used in HTML
  const p2ChoiceFormatted = escapeHTML(p2c.charAt(0).toUpperCase() + p2c.slice(1)); // Escape for safety

  let resultDescription;
  let outcome;

  if (p1c === p2c) {
    outcome = 'draw';
    resultDescription = `${p1Emoji} ${p1ChoiceFormatted} clashes with ${p2Emoji} ${p2ChoiceFormatted}! It's a <b>Draw</b>!`;
  } else if (RPS_RULES[p1c]?.beats === p2c) {
    outcome = 'win_player1';
    // player1NameHtml is expected to be already HTML-safe (e.g., from getPlayerDisplayReference + escapeHTML)
    resultDescription = `${p1Emoji} ${p1ChoiceFormatted} <b>${escapeHTML(RPS_RULES[p1c].verb)}</b> ${p2Emoji} ${p2ChoiceFormatted}! ${player1NameHtml} <b>claims victory</b>!`;
  } else {
    outcome = 'win_player2';
    // player2NameHtml is expected to be already HTML-safe
    resultDescription = `${p2Emoji} ${p2ChoiceFormatted} <b>${escapeHTML(RPS_RULES[p2c]?.verb || 'outplays')}</b> ${p1Emoji} ${p1ChoiceFormatted}! ${player2NameHtml} <b>is the winner</b>!`;
  }

  return {
    result: outcome,
    description: resultDescription, // HTML formatted description
    player1: { choice: p1c, emoji: p1Emoji, choiceFormatted: p1ChoiceFormatted },
    player2: { choice: p2c, emoji: p2Emoji, choiceFormatted: p2ChoiceFormatted }
  };
}

// --- End of Part 4 ---
// --- Start of REVISED Part 5a, Section 3: Upgraded Coinflip & RPS Game Logic (GRANULAR ACTIVE GAME LIMITS - FULL CODE - CORRECTED) ---
// This section contains the complete, new game logic for Coinflip and RPS.

// --- Start of REVISED Coinflip Game Logic & Handlers (Unified Offer, HTML, New Mechanics, Granular Limits) ---

// --- Constants for Coinflip ---
const COINFLIP_CHOICE_HEADS = 'heads';
const COINFLIP_CHOICE_TAILS = 'tails';
const COIN_EMOJI_DISPLAY = '🪙';
const COIN_FLIP_ANIMATION_FRAMES = ['🌕', '🌖', '🌗', '🌘', '🌑', '🌒', '🌓', '🌔'];
const COIN_FLIP_ANIMATION_INTERVAL_MS = 250;
const COIN_FLIP_ANIMATION_DURATION_MS = 2000;
const COIN_FLIP_ANIMATION_STEPS = Math.floor(COIN_FLIP_ANIMATION_DURATION_MS / COIN_FLIP_ANIMATION_INTERVAL_MS);

// --- Coinflip Unified Offer Command ---
// --- START OF REPLACEMENT for handleStartCoinflipUnifiedOfferCommand function ---
async function handleStartCoinflipUnifiedOfferCommand(msg, betAmountLamports, targetUsernameRaw = null) {
    const userId = String(msg.from.id || msg.from.telegram_id);
    const chatId = String(msg.chat.id);
    const chatType = msg.chat.type;
    const logPrefix = `[CF_OfferOrDirect_V6_GranLimit UID:${userId} CH:${chatId}]`;

    // MODIFIED CALL to checkUserActiveGameLimit and NEW ERROR MESSAGE
    const activeUserGameCheck = await checkUserActiveGameLimit(userId, (targetUsernameRaw != null), null); 
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = escapeHTML(getPlayerDisplayReference(msg.from));
        const blockingGameType = activeUserGameCheck.details.type;
        const cleanGameName = getCleanGameName(blockingGameType); // Using the new helper
        const alertMessage = `✨ ${userDisplayName}, you already have a pending offer or active game for <b>${escapeHTML(cleanGameName)}</b>. ✨`;
        await safeSendMessage(chatId, alertMessage, { parse_mode: 'HTML' });
        return;
    }
    // END OF MODIFICATION

    if (chatType === 'private') {
        await safeSendMessage(chatId, `🪙 The Coinflip arena awaits in <b>group chats</b>! Please use <code>/coinflip &lt;bet&gt; [@username]</code> there.`, { parse_mode: 'HTML' });
        return;
    }

    let initiatorUserObj = await getOrCreateUser(userId, msg.from.username, msg.from.first_name, msg.from.last_name);
    if (!initiatorUserObj) {
        await safeSendMessage(chatId, `Sorry ${escapeHTML(msg.from.first_name || 'player')}, I couldn't fetch your profile. Try <code>/start</code> first.`, { parse_mode: 'HTML' });
        return;
    }
    const initiatorPlayerRefHTML = escapeHTML(getPlayerDisplayReference(initiatorUserObj));
    const betDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(betAmountLamports, 'USD'));

    if (BigInt(initiatorUserObj.balance) < betAmountLamports) {
        const needed = betAmountLamports - BigInt(initiatorUserObj.balance);
        await safeSendMessage(chatId, `${initiatorPlayerRefHTML}, your balance is too low for a <b>${betDisplayUSD_HTML}</b> Coinflip game! You need ~<b>${escapeHTML(await formatBalanceForDisplay(needed, 'USD'))}</b> more.`, {
            parse_mode: 'HTML',
            reply_markup: { inline_keyboard: [[{ text: "💸 Add Funds (DM)", callback_data: QUICK_DEPOSIT_CALLBACK_ACTION_CONST }]] }
        });
        return;
    }

    let targetUserObject = null;
    let isDirectChallenge = (targetUsernameRaw != null); 

    if (isDirectChallenge) {
        targetUserObject = await findRecipientUser(targetUsernameRaw);
        if (!targetUserObject || !targetUserObject.telegram_id) {
            await safeSendMessage(chatId, `😕 Player ${escapeHTML(targetUsernameRaw)} not found. To make a general Coinflip offer, use <code>/cf ${escapeHTML(String(betAmountLamports / LAMPORTS_PER_SOL))}</code>.`, { parse_mode: 'HTML' });
            return;
        } else if (String(targetUserObject.telegram_id) === userId) {
            await safeSendMessage(chatId, `😅 You can't challenge yourself to Coinflip, ${initiatorPlayerRefHTML}! To make a general offer, use <code>/cf ${escapeHTML(String(betAmountLamports / LAMPORTS_PER_SOL))}</code>.`, { parse_mode: 'HTML' });
            return;
        }
    }

    const gameSession = await getGroupSession(chatId, msg.chat.title || `Group Chat ${chatId}`);
    let offerActivityKeyForLock;

    if (isDirectChallenge) {
        offerActivityKeyForLock = GAME_IDS.COINFLIP_DIRECT_CHALLENGE_OFFER; 
        const currentDirectChallenges = gameSession.activeGamesByTypeInGroup.get(offerActivityKeyForLock) || [];
        const limitDirect = GAME_ACTIVITY_LIMITS.DIRECT_CHALLENGES[offerActivityKeyForLock] || 1; 
        if (currentDirectChallenges.length >= limitDirect) {
            await safeSendMessage(chatId, `⏳ Hold your coins, ${initiatorPlayerRefHTML}! The limit of ${limitDirect} concurrent direct Coinflip challenge(s) in this group has been reached. Please wait.`, { parse_mode: 'HTML' });
            return;
        }
    } else {
        offerActivityKeyForLock = GAME_IDS.COINFLIP; 
        const currentUnifiedOffers = gameSession.activeGamesByTypeInGroup.get(offerActivityKeyForLock) || [];
        const limitUnified = GAME_ACTIVITY_LIMITS.UNIFIED_OFFERS[offerActivityKeyForLock] || 1;
        if (currentUnifiedOffers.length >= limitUnified) {
            await safeSendMessage(chatId, `⏳ Slow down, ${initiatorPlayerRefHTML}! The limit of ${limitUnified} concurrent Coinflip offer(s) in this group has been reached. Please wait.`, { parse_mode: 'HTML' });
            return;
        }
    }

    let offerId;
    let offerData;
    let clientBetPlacement = null;
    let timeoutDuration;

    try {
        clientBetPlacement = await pool.connect();
        await clientBetPlacement.query('BEGIN');

        if (isDirectChallenge) {
            offerId = generateGameId(`dcf_${userId.slice(-3)}_${String(targetUserObject.telegram_id).slice(-3)}`);
            timeoutDuration = DIRECT_CHALLENGE_ACCEPT_TIMEOUT_MS;

            const betResultDirect = await updateUserBalanceAndLedger(clientBetPlacement, userId, BigInt(-betAmountLamports), 'bet_placed_coinflip_direct_challenge_offer', { custom_offer_id: offerId, opponent_id_custom_field: targetUserObject.telegram_id }, `Direct Coinflip Challenge Offer to ${targetUserObject.username || targetUserObject.telegram_id}`);
            if (!betResultDirect.success) {
                throw new Error(betResultDirect.error || "Failed to place your bet for the direct challenge.");
            }
            initiatorUserObj.balance = betResultDirect.newBalanceLamports;

            const targetPlayerRefHTML = escapeHTML(getPlayerDisplayReference(targetUserObject));
            const groupChallengeTextHTML = `Hey ${targetPlayerRefHTML}❗\n\n${initiatorPlayerRefHTML} has challenged you to a <b>Coinflip</b> duel for <b>${betDisplayUSD_HTML}</b>! You have ${timeoutDuration / 1000} seconds to respond.`;
            const groupChallengeKeyboard = {
                inline_keyboard: [
                    [{ text: "✅ Accept Challenge", callback_data: `cf_direct_accept:${offerId}` }],
                    [{ text: "❌ Decline Challenge", callback_data: `cf_direct_decline:${offerId}` }],
                    [{ text: "🚫 Withdraw My Challenge", callback_data: `cf_direct_cancel:${offerId}` }]
                ]
            };
            const sentGroupMessage = await safeSendMessage(chatId, groupChallengeTextHTML, { parse_mode: 'HTML', reply_markup: groupChallengeKeyboard });
            if (!sentGroupMessage || !sentGroupMessage.message_id) {
                throw new Error("Could not send the direct challenge message to the group.");
            }

            offerData = {
                type: GAME_IDS.DIRECT_PVP_CHALLENGE,
                offerId: offerId,
                gameId: offerId,
                initiatorId: userId,
                initiatorUserObj: initiatorUserObj,
                initiatorMentionHTML: initiatorPlayerRefHTML,
                targetUserId: String(targetUserObject.telegram_id),
                targetUserObj: targetUserObject,
                targetUserMentionHTML: targetPlayerRefHTML,
                betAmount: betAmountLamports,
                originalGroupId: chatId,
                offerMessageIdInGroup: String(sentGroupMessage.message_id),
                chatTitle: msg.chat.title || `Group Chat ${chatId}`,
                status: 'pending_direct_challenge_response',
                gameToStart: GAME_IDS.COINFLIP_PVP,
                _offerKeyUsedForGroupLock: GAME_IDS.COINFLIP_DIRECT_CHALLENGE_OFFER, 
                creationTime: Date.now(),
                timeoutId: null
            };
        } else { // Unified Offer
            offerId = generateGameId(GAME_IDS.COINFLIP_UNIFIED_OFFER);
            timeoutDuration = UNIFIED_OFFER_TIMEOUT_MS;

            const betResultUnified = await updateUserBalanceAndLedger(clientBetPlacement, userId, BigInt(-betAmountLamports), 'bet_placed_coinflip_unified_offer', { custom_offer_id: offerId }, `Coinflip Unified Offer`);
            if (!betResultUnified.success) {
                throw new Error(betResultUnified.error || "Failed to place your bet for the unified offer.");
            }
            initiatorUserObj.balance = betResultUnified.newBalanceLamports;

            const offerMessageTextHTML = `👑 ${COIN_EMOJI_DISPLAY} <b>A Coinflip Challenge Has Been Issued!</b> ${COIN_EMOJI_DISPLAY} 👑\n\n` +
                `High roller ${initiatorPlayerRefHTML} has bravely wagered <b>${betDisplayUSD_HTML}</b> on the toss of a coin!\n\n` +
                `<b>Will you face the Bot Dealer, or will another player accept the PvP challenge?</b>\n\n` +
                `<i>This offer expires in ${timeoutDuration / 1000} seconds! Initiator's bet will be refunded if it times out.</i>`;
            const offerKeyboard = {
                inline_keyboard: [
                    [{ text: "🤖 Challenge Bot Dealer", callback_data: `cf_accept_bot:${offerId}` }],
                    [{ text: "⚔️ Accept PvP Challenge", callback_data: `cf_accept_pvp:${offerId}` }],
                    [{ text: "🚫 Withdraw My Challenge", callback_data: `cf_cancel_offer:${offerId}` }]
                ]
            };
            const sentMessage = await safeSendMessage(chatId, offerMessageTextHTML, { parse_mode: 'HTML', reply_markup: offerKeyboard });
            if (!sentMessage?.message_id) {
                throw new Error("Could not send the unified offer message to the group.");
            }

            offerData = {
                type: GAME_IDS.COINFLIP_UNIFIED_OFFER,
                gameId: offerId,
                chatId: chatId,
                chatType: chatType,
                initiatorId: userId,
                initiatorMentionHTML: initiatorPlayerRefHTML,
                initiatorUserObj: initiatorUserObj,
                betAmount: betAmountLamports,
                status: 'pending_offer',
                creationTime: Date.now(),
                offerMessageId: String(sentMessage.message_id),
                timeoutId: null
            };
        }

        await clientBetPlacement.query('COMMIT');
        activeGames.set(offerId, offerData);
        await updateGroupGameDetails(chatId, offerId, offerActivityKeyForLock, betAmountLamports);
        console.log(`${logPrefix} Offer ${offerId} (Type: ${offerData.type}, Group Lock Key: ${offerActivityKeyForLock}) created and bet placed.`);

        offerData.timeoutId = setTimeout(async () => {
            const timedOutOffer = activeGames.get(offerId);
            if (timedOutOffer && (timedOutOffer.status === 'pending_offer' || timedOutOffer.status === 'pending_direct_challenge_response')) {
                console.log(`${logPrefix} Offer ${offerId} (Type: ${timedOutOffer.type}) timed out.`);
                activeGames.delete(offerId);
                const keyForTimeoutRemoval = timedOutOffer._offerKeyUsedForGroupLock || offerActivityKeyForLock;
                await updateGroupGameDetails(chatId, { removeThisId: offerId }, keyForTimeoutRemoval, null);
                console.log(`${logPrefix} Cleared group lock for timed-out offer ${offerId} using key ${keyForTimeoutRemoval}.`);


                let refundClient = null;
                try {
                    refundClient = await pool.connect();
                    await refundClient.query('BEGIN');
                    const refundReason = timedOutOffer.type === GAME_IDS.DIRECT_PVP_CHALLENGE ? 'direct_challenge_expired_unanswered' : 'unified_offer_expired_unanswered';
                    const refundNotes = `Refund for expired ${timedOutOffer.type === GAME_IDS.DIRECT_PVP_CHALLENGE ? 'direct Coinflip challenge' : 'unified Coinflip offer'} ${offerId}.`;
                    await updateUserBalanceAndLedger(refundClient, timedOutOffer.initiatorId, timedOutOffer.betAmount, `refund_coinflip_${refundReason}`, { custom_offer_id: offerId }, refundNotes);
                    await refundClient.query('COMMIT');
                    console.log(`${logPrefix} Bet refunded to initiator ${timedOutOffer.initiatorId} for timed out offer ${offerId}.`);
                } catch (e) {
                    if (refundClient) await refundClient.query('ROLLBACK').catch(() => {});
                    console.error(`${logPrefix} CRITICAL: Failed to refund initiator ${timedOutOffer.initiatorId} for timed out offer ${offerId}: ${e.message}`);
                    if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL REFUND FAILURE for timed out Coinflip offer ${offerId}, Initiator: ${timedOutOffer.initiatorId}, Bet: ${timedOutOffer.betAmount}. Error: ${e.message}`);
                } finally {
                    if (refundClient) refundClient.release();
                }

                const messageIdToEdit = timedOutOffer.offerMessageIdInGroup || timedOutOffer.offerMessageId;
                const currentBetDisplayHTML_Timeout = escapeHTML(await formatBalanceForDisplay(timedOutOffer.betAmount, 'USD'));
                const timeoutMessageHTML = timedOutOffer.type === GAME_IDS.DIRECT_PVP_CHALLENGE ?
                    `⏳ The Coinflip challenge from ${timedOutOffer.initiatorMentionHTML} to ${timedOutOffer.targetUserMentionHTML} (<b>${currentBetDisplayHTML_Timeout}</b>) has expired unanswered. Initiator's bet refunded.` :
                    `⏳ The Coinflip offer by ${timedOutOffer.initiatorMentionHTML} (<b>${currentBetDisplayHTML_Timeout}</b>) has expired unanswered. Initiator's bet refunded.`;

                if (messageIdToEdit && bot) {
                    await bot.editMessageText(timeoutMessageHTML, {
                        chat_id: chatId, message_id: Number(messageIdToEdit),
                        parse_mode: 'HTML', reply_markup: {}
                    }).catch(e => console.warn(`${logPrefix} Failed to edit expired Coinflip offer message ${messageIdToEdit}: ${e.message}`));
                }
            }
        }, timeoutDuration);
        activeGames.set(offerId, offerData); 

    } catch (error) {
        if (clientBetPlacement) await clientBetPlacement.query('ROLLBACK').catch(() => {});
        console.error(`${logPrefix} Error creating Coinflip offer or placing bet: ${error.message}`);
        await safeSendMessage(chatId, `⚠️ Error creating your Coinflip offer: ${escapeHTML(error.message)}. Please try again.`, { parse_mode: 'HTML' });
        if (offerId && activeGames.has(offerId)) {
            activeGames.delete(offerId);
            const keyForErrorCleanup = offerData?._offerKeyUsedForGroupLock || offerActivityKeyForLock; 
            if(keyForErrorCleanup) await updateGroupGameDetails(chatId, { removeThisId: offerId }, keyForErrorCleanup, null);
        }
    } finally {
        if (clientBetPlacement) clientBetPlacement.release();
    }
}
// --- END OF REPLACEMENT for handleStartCoinflipUnifiedOfferCommand function ---

// --- Coinflip Offer Callback Handlers ---
async function handleCoinflipAcceptBotGameCallback(offerId, userWhoClicked, originalOfferMessageId, originalChatId, originalChatType, callbackQueryId) {
    const userId = String(userWhoClicked.id || userWhoClicked.telegram_id);
    const logPrefix = `[CF_AcceptBotCB_V3_GranLimit OfferID:${offerId} UID:${userId}]`;
    const offerData = activeGames.get(offerId);

    // --- NEW USER ACTIVE GAME LIMIT CHECK ---
    const activeUserGameCheck = await checkUserActiveGameLimit(userId, false, offerId); // Pass offerId as gameIdBeingActioned
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = escapeHTML(getPlayerDisplayReference(userWhoClicked));
        const blockingGameType = activeUserGameCheck.details.type;
        const cleanGameName = getCleanGameName(blockingGameType);
        // For callback queries, alerts should be concise.
        let alertMessage = `✨ ${userDisplayName}, you're already in a game of ${escapeHTML(cleanGameName)}. ✨ Finish it first!`;
        alertMessage = alertMessage.substring(0, 200); // Telegram alert character limit

        await bot.answerCallbackQuery(callbackQueryId, { text: alertMessage, show_alert: true }).catch(() => {});
        return;
    }
    // --- END OF NEW USER ACTIVE GAME LIMIT CHECK ---

    if (!offerData || offerData.type !== GAME_IDS.COINFLIP_UNIFIED_OFFER || offerData.status !== 'pending_offer') {
        await bot.answerCallbackQuery(callbackQueryId, { text: "This Coinflip offer is no longer valid.", show_alert: true }).catch(() => {});
        if (originalOfferMessageId && bot) bot.editMessageReplyMarkup({}, { chat_id: originalChatId, message_id: Number(originalOfferMessageId) }).catch(() => {});
        return;
    }
    if (offerData.initiatorId !== userId) {
        await bot.answerCallbackQuery(callbackQueryId, { text: "Only the one who made the offer can play against the Bot!", show_alert: true }).catch(() => {});
        return;
    }

    const gameSession = await getGroupSession(originalChatId);
    const activeGameKeyToCheck = GAME_IDS.COINFLIP_PVB; 
    const currentActiveGames = gameSession.activeGamesByTypeInGroup.get(activeGameKeyToCheck) || [];
    const limitActive = GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[activeGameKeyToCheck] || 1;

    if (currentActiveGames.length >= limitActive) {
        await bot.answerCallbackQuery(callbackQueryId, { text: `Max ${limitActive} active Coinflip PvB game(s) allowed in this group. Please wait.`, show_alert: true }).catch(() => {});
        return;
    }

    if (offerData.timeoutId) clearTimeout(offerData.timeoutId);
    await bot.answerCallbackQuery(callbackQueryId, { text: `🪙 ${COIN_EMOJI_DISPLAY} Starting your Coinflip duel with the Bot Dealer...` }).catch(() => {});

    offerData.status = 'bot_game_accepted';
    activeGames.set(offerId, offerData);

    await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.COINFLIP, null);
    activeGames.delete(offerId);

    await startCoinflipPvBGame(originalChatId, offerData.initiatorUserObj, offerData.betAmount, offerData.offerMessageId, null);
}

async function handleCoinflipAcceptPvPChallengeCallback(offerId, joinerUserObjFull, originalOfferMessageId, originalChatId, originalChatType, callbackQueryId) {
    const joinerId = String(joinerUserObjFull.id || joinerUserObjFull.telegram_id);
    const logPrefix = `[CF_AcceptPvPCB_V3_GranLimit OfferID:${offerId} JoinerID:${joinerId}]`;
    const offerData = activeGames.get(offerId);

    // --- NEW USER ACTIVE GAME LIMIT CHECK ---
    const activeUserGameCheck = await checkUserActiveGameLimit(joinerId, false, offerId); // Pass offerId as gameIdBeingActioned
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = escapeHTML(getPlayerDisplayReference(joinerUserObjFull));
        const blockingGameType = activeUserGameCheck.details.type;
        const cleanGameName = getCleanGameName(blockingGameType);
        let alertMessage = `✨ ${userDisplayName}, you're already in a game of ${escapeHTML(cleanGameName)}. ✨ Finish it first!`;
        alertMessage = alertMessage.substring(0, 200); // Telegram alert length limit

        await bot.answerCallbackQuery(callbackQueryId, { text: alertMessage, show_alert: true }).catch(() => {});
        return;
    }
    // --- END OF NEW USER ACTIVE GAME LIMIT CHECK ---

    if (!offerData || offerData.type !== GAME_IDS.COINFLIP_UNIFIED_OFFER || offerData.status !== 'pending_offer') {
        await bot.answerCallbackQuery(callbackQueryId, { text: "This Coinflip PvP offer has vanished!", show_alert: true }).catch(() => {});
        if (originalOfferMessageId && bot) bot.editMessageReplyMarkup({}, { chat_id: originalChatId, message_id: Number(originalOfferMessageId) }).catch(() => {});
        return;
    }
    if (offerData.initiatorId === joinerId) {
        await bot.answerCallbackQuery(callbackQueryId, { text: "You can't accept your own Coinflip challenge for PvP!", show_alert: true }).catch(() => {});
        return;
    }

    const gameSession = await getGroupSession(originalChatId);
    const activeGameKeyToCheck = GAME_IDS.COINFLIP_PVP_FROM_UNIFIED; 
    const currentActiveGames = gameSession.activeGamesByTypeInGroup.get(activeGameKeyToCheck) || [];
    const limitActive = GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[activeGameKeyToCheck] || 1;

    if (currentActiveGames.length >= limitActive) {
        await bot.answerCallbackQuery(callbackQueryId, { text: `Max ${limitActive} active Coinflip PvP (from unified offers) game(s) allowed. Please wait.`, show_alert: true }).catch(() => {});
        return;
    }

    const betDisplayHTML = escapeHTML(await formatBalanceForDisplay(offerData.betAmount, 'USD'));
    if (BigInt(joinerUserObjFull.balance) < offerData.betAmount) {
        await bot.answerCallbackQuery(callbackQueryId, { text: `Your funds are too low for this ${betDisplayHTML} duel!`, show_alert: true }).catch(() => {});
        const needed = offerData.betAmount - BigInt(joinerUserObjFull.balance);
        await safeSendMessage(originalChatId, `💰 Oops, ${escapeHTML(getPlayerDisplayReference(joinerUserObjFull))}! Your balance is short by ~<b>${escapeHTML(await formatBalanceForDisplay(needed, 'USD'))}</b> to join this <b>${betDisplayHTML}</b> Coinflip.`, {
            parse_mode: 'HTML', reply_markup: { inline_keyboard: [[{ text: "💸 Add Funds (DM)", callback_data: QUICK_DEPOSIT_CALLBACK_ACTION_CONST }]] }
        });
        return;
    }
    const currentInitiatorUserObj = await getOrCreateUser(offerData.initiatorId); 
    if (!currentInitiatorUserObj || BigInt(currentInitiatorUserObj.balance) < offerData.betAmount) {
        await bot.answerCallbackQuery(callbackQueryId, { text: "Initiator can't cover the bet. Offer cancelled.", show_alert: true }).catch(() => {});
        if (offerData.offerMessageId && bot) {
            await bot.editMessageText(`⚠️ <b>Offer Auto-Cancelled</b><br>The Coinflip offer by ${offerData.initiatorMentionHTML} for <b>${betDisplayHTML}</b> was cancelled as their balance is no longer sufficient.`, {
                chat_id: originalChatId, message_id: Number(offerData.offerMessageId), parse_mode: 'HTML', reply_markup: { inline_keyboard: [] }
            }).catch(() => {});
        }
        if (offerData.timeoutId) clearTimeout(offerData.timeoutId);
        activeGames.delete(offerId);
        await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.COINFLIP, null); 
        return;
    }

    if (offerData.timeoutId) clearTimeout(offerData.timeoutId);
    await bot.answerCallbackQuery(callbackQueryId, { text: "⚔️ PvP Challenge Accepted! The coin is ready to be flipped..." }).catch(() => {});

    offerData.status = 'pvp_accepted'; 
    activeGames.set(offerId, offerData); 

    await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.COINFLIP, null); 
    
    await startCoinflipPvPGame(
        currentInitiatorUserObj,
        joinerUserObjFull,
        offerData.betAmount,
        originalChatId,
        offerData.offerMessageId, 
        'unified_offer', 
        false 
    );
    activeGames.delete(offerId); 
}

async function handleCoinflipCancelOfferCallback(offerId, userWhoClicked, originalOfferMessageId, originalChatId, callbackQueryId) {
    const userId = String(userWhoClicked.id || userWhoClicked.telegram_id);
    const logPrefix = `[CF_CancelOfferCB_V2 OfferID:${offerId} UID:${userId}]`; 
    const offerData = activeGames.get(offerId);

    if (!offerData || offerData.type !== GAME_IDS.COINFLIP_UNIFIED_OFFER || offerData.status !== 'pending_offer') {
        await bot.answerCallbackQuery(callbackQueryId, { text: "Offer already gone or actioned!", show_alert: false }).catch(() => {});
        if (originalOfferMessageId && bot) bot.editMessageReplyMarkup({}, { chat_id: originalChatId, message_id: Number(originalOfferMessageId) }).catch(() => {});
        return;
    }
    if (offerData.initiatorId !== userId) {
        await bot.answerCallbackQuery(callbackQueryId, { text: "Only the offer initiator can cancel.", show_alert: true }).catch(() => {});
        return;
    }

    if (offerData.timeoutId) clearTimeout(offerData.timeoutId);
    await bot.answerCallbackQuery(callbackQueryId, { text: "Coinflip offer withdrawn. Refunding bet..." }).catch(() => {});

    activeGames.delete(offerId);
    await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.COINFLIP, null); 

    let refundClient = null;
    try {
        refundClient = await pool.connect();
        await refundClient.query('BEGIN');
        await updateUserBalanceAndLedger(refundClient, offerData.initiatorId, offerData.betAmount, 'refund_coinflip_offer_cancelled', { custom_offer_id: offerId }, `Refund for cancelled Coinflip unified offer ${offerId}`);
        await refundClient.query('COMMIT');
        console.log(`${logPrefix} Bet refunded to initiator ${offerData.initiatorId} for cancelled offer ${offerId}.`);
    } catch (e) {
        if (refundClient) await refundClient.query('ROLLBACK').catch(() => {});
        console.error(`${logPrefix} CRITICAL: Failed to refund initiator ${offerData.initiatorId} for cancelled offer ${offerId}: ${e.message}`);
        if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL REFUND FAILURE for cancelled Coinflip offer ${offerId}, Initiator: ${offerData.initiatorId}, Bet: ${offerData.betAmount}. Error: ${e.message}`);
    } finally {
        if (refundClient) refundClient.release();
    }

    const betDisplayHTML = escapeHTML(await formatBalanceForDisplay(offerData.betAmount, 'USD'));
    if (originalOfferMessageId && bot) {
        await bot.editMessageText(`🚫 <b>Offer Retracted!</b>\nThe Coinflip challenge by ${offerData.initiatorMentionHTML} (wager: <b>${betDisplayHTML}</b>) has been cancelled. Bet refunded.`, {
            chat_id: originalChatId, message_id: Number(originalOfferMessageId), parse_mode: 'HTML', reply_markup: {}
        }).catch(async (e) => {
            await safeSendMessage(originalChatId, `🚫 Coinflip Offer by ${offerData.initiatorMentionHTML} for <b>${betDisplayHTML}</b> withdrawn. Bet refunded.`, { parse_mode: 'HTML' });
        });
    } else {
        await safeSendMessage(originalChatId, `🚫 Coinflip Offer by ${offerData.initiatorMentionHTML} for <b>${betDisplayHTML}</b> withdrawn. Bet refunded.`, { parse_mode: 'HTML' });
    }
}

// --- Coinflip Player vs. Bot (PvB) Logic ---
async function startCoinflipPvBGame(chatId, initiatorUserObj, betAmountLamports, originalOfferMessageId, offerIdToDeleteIfAny) {
    const userId = String(initiatorUserObj.id || initiatorUserObj.telegram_id);
    const logPrefix = `[CF_PvB_Start_V3_GranLimit UID:${userId} CH:${chatId}]`;
    const playerRefHTML = escapeHTML(getPlayerDisplayReference(initiatorUserObj));
    
    const activeGameActivityKey = GAME_IDS.COINFLIP_PVB; 

    if (originalOfferMessageId && bot) {
        await bot.deleteMessage(chatId, Number(originalOfferMessageId)).catch(() => {});
    }
    if (offerIdToDeleteIfAny) activeGames.delete(offerIdToDeleteIfAny); 

    console.log(`${logPrefix} Starting Coinflip PvB. Bet was already placed by initiator ${userId}.`);

    const pvbGameId = generateGameId(GAME_IDS.COINFLIP_PVB);
    const gameDataPvB = {
        type: GAME_IDS.COINFLIP_PVB, gameId: pvbGameId, chatId, userId,
        playerRefHTML, userObj: initiatorUserObj, betAmount: betAmountLamports,
        playerChoice: null, result: null, status: 'pvb_waiting_choice',
        gameMessageId: null, lastInteractionTime: Date.now(),
        choiceTimeoutId: null
    };
    activeGames.set(pvbGameId, gameDataPvB);
    await updateGroupGameDetails(chatId, pvbGameId, activeGameActivityKey, betAmountLamports);
    console.log(`${logPrefix} Coinflip PvB game ${pvbGameId} started. Group lock for ${activeGameActivityKey} updated.`);

    const titleHTML = `🤖${COIN_EMOJI_DISPLAY} <b>Coinflip: ${playerRefHTML} vs. Bot Dealer!</b> ${COIN_EMOJI_DISPLAY}🤖`;
    const betDisplayUSD_HTML_PvB = escapeHTML(await formatBalanceForDisplay(betAmountLamports, 'USD'));
    const initialMessageTextHTML = `${titleHTML}\n\nWager: <b>${betDisplayUSD_HTML_PvB}</b>\n\n` +
        `The Bot Dealer polishes a shimmering virtual coin! ${playerRefHTML}, make your call: Heads or Tails?\n<i>(You have ${ACTIVE_GAME_TURN_TIMEOUT_MS / 1000} seconds to choose)</i>`;
    const keyboard = {
        inline_keyboard: [
            [
                { text: `${COIN_EMOJI_DISPLAY} Heads`, callback_data: `cf_pvb_choice:${pvbGameId}:${COINFLIP_CHOICE_HEADS}` },
                { text: `${COIN_EMOJI_DISPLAY} Tails`, callback_data: `cf_pvb_choice:${pvbGameId}:${COINFLIP_CHOICE_TAILS}` }
            ],
            [{ text: "📖 Rules", callback_data: `${RULES_CALLBACK_PREFIX_CONST}${GAME_IDS.COINFLIP}` }]
        ]
    };
    const sentMessage = await safeSendMessage(chatId, initialMessageTextHTML, { parse_mode: 'HTML', reply_markup: keyboard });
    if (sentMessage?.message_id) {
        gameDataPvB.gameMessageId = String(sentMessage.message_id);
        gameDataPvB.choiceTimeoutId = setTimeout(() => {
            handleCoinflipPvBChoiceTimeout(pvbGameId);
        }, ACTIVE_GAME_TURN_TIMEOUT_MS); 
        activeGames.set(pvbGameId, gameDataPvB); 
    } else {
        console.error(`${logPrefix} Failed to send Coinflip PvB game message for ${pvbGameId}. Bet was already taken.`);
        activeGames.delete(pvbGameId);
        await updateGroupGameDetails(chatId, { removeThisId: pvbGameId }, activeGameActivityKey, null);
        await safeSendMessage(chatId, `⚙️ Error displaying Coinflip PvB game for ${playerRefHTML}. Your bet was placed. Please contact support if the game doesn't resolve.`, {parse_mode:'HTML'});
    }
}

async function handleCoinflipPvBChoiceTimeout(gameId) {
    const LOG_PREFIX_CF_PVB_CHOICE_TIMEOUT = `[CF_PvB_ChoiceTimeout_V2 GID:${gameId}]`;
    const gameData = activeGames.get(gameId);

    if (!gameData || gameData.type !== GAME_IDS.COINFLIP_PVB || gameData.status !== 'pvb_waiting_choice') {
        if (gameData && gameData.choiceTimeoutId) clearTimeout(gameData.choiceTimeoutId);
        return;
    }
    console.log(`${LOG_PREFIX_CF_PVB_CHOICE_TIMEOUT} Player ${gameData.userId} timed out for Coinflip PvB choice. Game forfeited, bet lost.`);

    if (gameData.choiceTimeoutId) clearTimeout(gameData.choiceTimeoutId);
    gameData.choiceTimeoutId = null;

    activeGames.delete(gameId);
    await updateGroupGameDetails(String(gameData.chatId), { removeThisId: gameId }, GAME_IDS.COINFLIP_PVB, null); 

    let client = null;
    try {
        client = await pool.connect();
        await client.query('BEGIN');
        await updateUserBalanceAndLedger(
            client, gameData.userId, 0n, 'loss_coinflip_pvb_choice_timeout',
            { game_id_custom_field: gameId, original_bet_amount: gameData.betAmount.toString() },
            `Player forfeited Coinflip PvB game ${gameId} due to choice timeout. Bet lost.`
        );
        await client.query('COMMIT');
    } catch (dbError) {
        if (client) await client.query('ROLLBACK').catch(() => {});
        console.error(`${LOG_PREFIX_CF_PVB_CHOICE_TIMEOUT} DB error logging forfeit for ${gameId}: ${dbError.message}`);
        if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL Coinflip PvB TIMEOUT FORFEIT LOGGING FAILURE GID: ${gameId}, User: ${gameData.userId}. Error: ${dbError.message}`);
    } finally {
        if (client) client.release();
    }

    const playerRefHTML = gameData.playerRefHTML || escapeHTML(getPlayerDisplayReference(gameData.userObj || { id: gameData.userId, first_name: "Player" }));
    const betDisplayUSD_HTML_Timeout = escapeHTML(await formatBalanceForDisplay(gameData.betAmount, 'USD'));
    const timeoutMessageText = `⏰ ${playerRefHTML}, your Coinflip game (Bet: <b>${betDisplayUSD_HTML_Timeout}</b>) timed out as no choice was made.\nYour bet has been forfeited.`;

    const messageIdToEdit = Number(gameData.gameMessageId);
    if (bot && messageIdToEdit) {
        await bot.editMessageText(timeoutMessageText, {
            chat_id: String(gameData.chatId), message_id: messageIdToEdit,
            parse_mode: 'HTML', reply_markup: createPostGameKeyboard(GAME_IDS.COINFLIP_PVB, gameData.betAmount) 
        }).catch(async (err) => {
            await safeSendMessage(String(gameData.chatId), timeoutMessageText, { parse_mode: 'HTML', reply_markup: createPostGameKeyboard(GAME_IDS.COINFLIP_PVB, gameData.betAmount) });
        });
    } else {
        await safeSendMessage(String(gameData.chatId), timeoutMessageText, { parse_mode: 'HTML', reply_markup: createPostGameKeyboard(GAME_IDS.COINFLIP_PVB, gameData.betAmount) });
    }
}

async function handleCoinflipPvBChoiceCallback(gameId, playerChoice, userObj, originalMessageId, callbackQueryId) {
    const userId = String(userObj.id || userObj.telegram_id);
    const logPrefix = `[CF_PvBChoiceCB_V2 GID:${gameId} UID:${userId} Choice:${playerChoice}]`;
    const gameData = activeGames.get(gameId);

    if (!gameData || gameData.type !== GAME_IDS.COINFLIP_PVB || gameData.userId !== userId || gameData.status !== 'pvb_waiting_choice') {
        await bot.answerCallbackQuery(callbackQueryId, { text: "This Coinflip game action is outdated or not yours.", show_alert: true }).catch(() => {});
        return;
    }

    if (gameData.choiceTimeoutId) clearTimeout(gameData.choiceTimeoutId);
    gameData.choiceTimeoutId = null;

    const choiceDisplay = playerChoice === COINFLIP_CHOICE_HEADS ? "Heads" : "Tails";
    await bot.answerCallbackQuery(callbackQueryId, { text: `You called ${choiceDisplay}! Bot is flipping...` }).catch(() => {});

    gameData.playerChoice = playerChoice;
    gameData.status = 'pvb_flipping';
    activeGames.set(gameId, gameData);

    const actualFlipOutcome = Math.random() < 0.5 ? COINFLIP_CHOICE_HEADS : COINFLIP_CHOICE_TAILS;
    gameData.result = actualFlipOutcome;

    const titleFlippingHTML = `💫 ${COIN_EMOJI_DISPLAY} <b>Coin in the Air!</b> ${COIN_EMOJI_DISPLAY} 💫`;
    let flippingMessageText = `${titleFlippingHTML}\n\n${gameData.playerRefHTML} called <b>${escapeHTML(choiceDisplay)}</b>!\n` +
        `The Bot Dealer flips the coin... it's spinning wildly!\n\n`;

    if (gameData.gameMessageId && bot) {
        for (let i = 0; i < COIN_FLIP_ANIMATION_STEPS; i++) {
            const frame = COIN_FLIP_ANIMATION_FRAMES[i % COIN_FLIP_ANIMATION_FRAMES.length];
            try {
                await bot.editMessageText(flippingMessageText + `<b>${frame}</b>`, { chat_id: gameData.chatId, message_id: Number(gameData.gameMessageId), parse_mode: 'HTML', reply_markup: {} });
            } catch (e) { if (!e.message?.includes("message is not modified")) console.warn(`${logPrefix} Animation edit fail step ${i}`); break; }
            await sleep(COIN_FLIP_ANIMATION_INTERVAL_MS);
        }
    } else {
        const tempAnimMsg = await safeSendMessage(gameData.chatId, flippingMessageText + "<i>Flip in progress!</i>", { parse_mode: "HTML" });
        await sleep(COIN_FLIP_ANIMATION_DURATION_MS);
        if (tempAnimMsg?.message_id && bot) await bot.deleteMessage(gameData.chatId, tempAnimMsg.message_id).catch(() => {});
    }

    await finalizeCoinflipPvBGame(gameData);
}

// REPLACE your entire finalizeCoinflipPvBGame function with this corrected version

async function finalizeCoinflipPvBGame(gameData) {
    const { gameId, chatId, userId, playerRefHTML, betAmount, playerChoice, result, userObj } = gameData;
    const logPrefix = `[CF_PvB_Finalize_V7_RefFix GID:${gameId}]`;
    let allNotificationsToSend = [];

    let solPrice;
    try {
        solPrice = await getSolUsdPrice();
    } catch (priceError) {
        console.error(`${logPrefix} CRITICAL: Could not get SOL price. Level-up/milestone checks will be skipped. Error: ${priceError.message}`);
        solPrice = 0;
    }

    await updateGroupGameDetails(chatId, { removeThisId: gameId }, GAME_IDS.COINFLIP_PVB, null);

    const playerWins = playerChoice === result;
    let payoutAmountLamports = playerWins ? betAmount * 2n : 0n;
    let ledgerOutcomeCode = playerWins ? `win_coinflip_pvb_${playerChoice}` : `loss_coinflip_pvb_${playerChoice}_vs_${result}`;
    let gameOutcomeTextForLog = playerWins ? `Player wins (${playerChoice})` : `Bot wins (Player chose ${playerChoice}, result ${result})`;
    let finalUserBalance = BigInt(userObj.balance);

    let client = null;
    try {
        client = await pool.connect(); await client.query('BEGIN');

        const actualGameLogId = await logGameResultToGamesTable(
            client, GAME_IDS.COINFLIP_PVB, chatId, userId, [userId], betAmount, gameOutcomeTextForLog, 0n
        );

        const balanceUpdate = await updateUserBalanceAndLedger(
            client, userId, payoutAmountLamports, ledgerOutcomeCode,
            { game_log_id: actualGameLogId, original_bet_amount: betAmount.toString() }, 
            `PvB Coinflip: ${playerChoice} vs Bot ${result}`,
            solPrice
        );

        if (!balanceUpdate.success) {
            throw new Error(balanceUpdate.error || "DB Error during Coinflip PvB payout.");
        }
        
        if (balanceUpdate.notifications && balanceUpdate.notifications.length > 0) {
            allNotificationsToSend.push(...balanceUpdate.notifications);
        }
        
        finalUserBalance = balanceUpdate.newBalanceLamports;

        const isConclusiveOutcome = ledgerOutcomeCode.startsWith('win_') || ledgerOutcomeCode.startsWith('loss_');
        if (isConclusiveOutcome) {
            if (typeof processQualifyingBetAndInitialBonus === 'function') {
                // --- FIX IS HERE: Changed 'clientPayout' to the correct 'client' variable ---
                const initialBonusResult = await processQualifyingBetAndInitialBonus(client, userId, betAmount, gameId);
                if (initialBonusResult.jobQueued) {
                    console.log(`[ReferralCheck] Queued initial bet bonus job for user ${userId} from game ${gameId}.`);
                }
            }
            if (balanceUpdate.newTotalWageredLamports !== undefined && typeof checkAndUpdateUserLevel === 'function') {
                const levelNotifications = await checkAndUpdateUserLevel(client, userId, balanceUpdate.newTotalWageredLamports, solPrice, chatId);
                allNotificationsToSend.push(...levelNotifications);
            }
            if (balanceUpdate.newTotalWageredLamports !== undefined && typeof processWagerMilestoneBonus === 'function') {
                const milestoneResult = await processWagerMilestoneBonus(client, userId, balanceUpdate.newTotalWageredLamports, solPrice);
                if (!milestoneResult.success) console.warn(`${logPrefix} Failed to process milestone bonus for PvB Coinflip: ${milestoneResult.error}`);
            }
        }

        await client.query('COMMIT');
    } catch (e) {
        if (client) await client.query('ROLLBACK').catch(() => {});
        console.error(`${logPrefix} CRITICAL DB error: ${e.message}`);
        if(typeof notifyAdmin === 'function') notifyAdmin(`🚨 CRITICAL Coinflip PvB Payout Failure 🚨\nGame ID: <code>${escapeHTML(gameId)}</code>\nError: ${escapeHTML(e.message)}. Manual check needed.`, { parse_mode: 'HTML'});
    } finally { 
        if (client) client.release(); 
    }

    for (const notification of allNotificationsToSend) {
        if (notification.to === ADMIN_USER_ID && typeof notifyAdmin === 'function') {
            await notifyAdmin(notification.text, notification.options).catch(err => console.error(`Failed to send admin notification: ${err.message}`));
        } else {
            await safeSendMessage(notification.to, notification.text, notification.options).catch(err => console.error(`Failed to send game-related notification to ${notification.to}: ${err.message}`));
        }
    }

    const resultDisplay = result === COINFLIP_CHOICE_HEADS ? "Heads" : "Tails";
    const titleResultHTML = playerWins ? `🎉🏆 <b>YOU WIN, ${playerRefHTML}!</b> 🏆🎉` : `💔😥 <b>Better Luck Next Time, ${playerRefHTML}!</b> 😥💔`;
    const resultMessageHTML = `${titleResultHTML}\n\n` +
        `You called: <b>${escapeHTML(playerChoice === COINFLIP_CHOICE_HEADS ? "Heads" : "Tails")}</b>\n` +
        `The coin landed on... ✨ <b>${COIN_EMOJI_DISPLAY} ${escapeHTML(resultDisplay)}!</b> ✨\n\n` +
        (playerWins ? `Congratulations! You won <b>${escapeHTML(await formatBalanceForDisplay(betAmount, 'USD'))}</b> in profit (total payout: <b>${escapeHTML(await formatBalanceForDisplay(payoutAmountLamports, 'USD'))}</b>)!` : `The Bot Dealer claims the pot of <b>${escapeHTML(await formatBalanceForDisplay(betAmount, 'USD'))}</b>.`);

    const postGameKeyboard = createPostGameKeyboard(GAME_IDS.COINFLIP_PVB, betAmount);
    if (gameData.gameMessageId && bot) {
        await bot.editMessageText(resultMessageHTML, { chat_id: chatId, message_id: Number(gameData.gameMessageId), parse_mode: 'HTML', reply_markup: postGameKeyboard }).catch(async (e) => {
            if (!e.message?.includes("message is not modified")) await safeSendMessage(chatId, resultMessageHTML, { parse_mode: 'HTML', reply_markup: postGameKeyboard });
        });
    } else {
        await safeSendMessage(chatId, resultMessageHTML, { parse_mode: 'HTML', reply_markup: postGameKeyboard });
    }
    activeGames.delete(gameId);
}

// --- Coinflip Player vs. Player (PvP) Logic ---
async function startCoinflipPvPGame(
    initiatorUserObj,
    joinerUserObjFull,
    betAmountInput,
    chatIdInput,
    originalOfferMessageIdToDelete, 
    origin, 
    joinerBetAlreadyDeducted = false 
) {
    const chatId = String(chatIdInput);
    const betAmount = BigInt(betAmountInput);
    const logPrefix = `[CF_PvP_Start_V3_Origin UID1:${initiatorUserObj.id} UID2:${joinerUserObjFull.id} CH:${chatId} Origin:${origin}]`;
    
    let activeGameKeyForStorage;
    if (origin === 'unified_offer') {
        activeGameKeyForStorage = GAME_IDS.COINFLIP_PVP_FROM_UNIFIED;
    } else { 
        activeGameKeyForStorage = GAME_IDS.COINFLIP_PVP; 
    }

    if (originalOfferMessageIdToDelete && bot) {
        await bot.deleteMessage(chatId, Number(originalOfferMessageIdToDelete)).catch(() => {});
    }

    let client = null;
    const pvpGameId = generateGameId(GAME_IDS.COINFLIP_PVP); 

    const initiatorId = String(initiatorUserObj.id || initiatorUserObj.telegram_id);
    const initiatorMentionHTML = escapeHTML(getPlayerDisplayReference(initiatorUserObj));
    const joinerId = String(joinerUserObjFull.id || joinerUserObjFull.telegram_id);
    const joinerMentionHTML = escapeHTML(getPlayerDisplayReference(joinerUserObjFull));

    if (!joinerBetAlreadyDeducted) {
        console.log(`${logPrefix} Joiner's bet not pre-deducted for ${origin} origin. Processing for Coinflip PvP game ${pvpGameId}.`);
        try {
            client = await pool.connect(); await client.query('BEGIN');
            const joinBetRes = await updateUserBalanceAndLedger(client, joinerId, BigInt(-betAmount), 'bet_placed_coinflip_pvp_join', { game_id_custom_field: pvpGameId, opponent_id_custom_field: initiatorId }, `PvP Coinflip bet vs ${initiatorMentionHTML}`);
            if (!joinBetRes.success) throw new Error(`Joiner bet failed: ${joinBetRes.error}`);
            joinerUserObjFull.balance = joinBetRes.newBalanceLamports; 
            await client.query('COMMIT');
        } catch (error) {
            if (client) await client.query('ROLLBACK').catch(() => {});
            console.error(`${logPrefix} DB error placing joiner's PvP Coinflip bet: ${error.message}`);
            await safeSendMessage(chatId, `⚙️ Database error placing joiner's bet for PvP Coinflip. Game cancelled.`, { parse_mode: 'HTML' });
            return; 
        } finally {
            if (client) client.release();
        }
    } else {
        console.log(`${logPrefix} Joiner's bet assumed pre-deducted for Coinflip PvP game ${pvpGameId}.`);
    }

    const p1IsCaller = Math.random() < 0.5;
    const callerId = p1IsCaller ? initiatorId : joinerId;
    const callerMentionHTML = p1IsCaller ? initiatorMentionHTML : joinerMentionHTML;

    const gameDataPvP = {
        type: GAME_IDS.COINFLIP_PVP, gameId: pvpGameId, chatId, betAmount,
        p1: { userId: initiatorId, mentionHTML: initiatorMentionHTML, userObj: initiatorUserObj },
        p2: { userId: joinerId, mentionHTML: joinerMentionHTML, userObj: joinerUserObjFull },
        callerId: callerId,
        callerChoice: null, result: null,
        status: 'pvp_waiting_caller_choice',
        gameMessageId: null, lastInteractionTime: Date.now(),
        callerChoiceTimeoutId: null,
        _origin_key_for_limits: activeGameKeyForStorage 
    };
    activeGames.set(pvpGameId, gameDataPvP);
    await updateGroupGameDetails(chatId, pvpGameId, activeGameKeyForStorage, betAmount);
    console.log(`${logPrefix} Coinflip PvP game ${pvpGameId} started. Group lock using key ${activeGameKeyForStorage} updated.`);

    await promptCoinflipPvPCaller(gameDataPvP, callerMentionHTML);
}

async function promptCoinflipPvPCaller(gameData, callerMentionHTML) {
    const logPrefix = `[CF_PvP_PromptCaller_V2 GID:${gameData.gameId}]`;
    const titleHTML = `✨⚔️ <b>Coinflip PvP: ${gameData.p1.mentionHTML} vs ${gameData.p2.mentionHTML}!</b> ⚔️✨`;
    const betDisplayHTML_PvP = escapeHTML(await formatBalanceForDisplay(gameData.betAmount, 'USD'));
    const messageTextHTML = `${titleHTML}\nWager: <b>${betDisplayHTML_PvP}</b> each.\n\n` +
        `The virtual coin is launched high into the digital sky! 🌪️${COIN_EMOJI_DISPLAY}🌪️\n\n` +
        `Fate has decreed that <b>${callerMentionHTML}</b> shall make the fateful call!\n` +
        `What is your prediction: Heads or Tails? Click your destiny below! (You have ${ACTIVE_GAME_TURN_TIMEOUT_MS / 1000} seconds)`;
    const keyboard = {
        inline_keyboard: [[
            { text: `${COIN_EMOJI_DISPLAY} Heads It Is!`, callback_data: `cf_pvp_call:${gameData.gameId}:${gameData.callerId}:${COINFLIP_CHOICE_HEADS}` },
            { text: `${COIN_EMOJI_DISPLAY} Tails, No Fails!`, callback_data: `cf_pvp_call:${gameData.gameId}:${gameData.callerId}:${COINFLIP_CHOICE_TAILS}` }
        ]]
    };
    const sentMessage = await safeSendMessage(gameData.chatId, messageTextHTML, { parse_mode: 'HTML', reply_markup: keyboard });

    if (sentMessage?.message_id) {
        const currentGameData = activeGames.get(gameData.gameId);
        if (currentGameData && currentGameData.status === 'pvp_waiting_caller_choice') {
            currentGameData.gameMessageId = String(sentMessage.message_id);
            currentGameData.callerChoiceTimeoutId = setTimeout(() => {
                handleCoinflipPvPCallTimeout(gameData.gameId);
            }, ACTIVE_GAME_TURN_TIMEOUT_MS); 
            activeGames.set(gameData.gameId, currentGameData);
            console.log(`${logPrefix} Caller choice timeout started for game ${gameData.gameId}, caller ${gameData.callerId}.`);
        }
    } else {
        console.error(`${logPrefix} Failed to send caller prompt message for ${gameData.gameId}. Attempting to end game with error.`);
        const gameToEndOnError = activeGames.get(gameData.gameId);
        if (gameToEndOnError) {
            gameToEndOnError.status = 'game_over_error_ui_update';
            if (gameToEndOnError.callerChoiceTimeoutId) clearTimeout(gameToEndOnError.callerChoiceTimeoutId);
            activeGames.set(gameData.gameId, gameToEndOnError);
            await finalizeCoinflipPvPGame(gameToEndOnError); 
        }
    }
}

async function handleCoinflipPvPCallTimeout(gameId) {
    const LOG_PREFIX_CF_PVP_TIMEOUT = `[CF_PvP_CallTimeout_V2 GID:${gameId}]`;
    const gameData = activeGames.get(gameId);

    if (!gameData || gameData.type !== GAME_IDS.COINFLIP_PVP || gameData.status !== 'pvp_waiting_caller_choice') {
        if (gameData && gameData.callerChoiceTimeoutId) clearTimeout(gameData.callerChoiceTimeoutId);
        return;
    }
    console.log(`${LOG_PREFIX_CF_PVP_TIMEOUT} Caller ${gameData.callerId} timed out. Game ending by forfeit.`);

    if (gameData.callerChoiceTimeoutId) clearTimeout(gameData.callerChoiceTimeoutId);
    gameData.callerChoiceTimeoutId = null;

    if (gameData.callerId === gameData.p1.userId) {
        gameData.status = 'game_over_p1_timeout_forfeit';
    } else {
        gameData.status = 'game_over_p2_timeout_forfeit';
    }
    activeGames.set(gameId, gameData);
    await finalizeCoinflipPvPGame(gameData); 
}

async function handleCoinflipPvPCallCallback(gameId, callerIdCheck, callChoice, userObj, originalMessageId, callbackQueryId) {
    const userId = String(userObj.id || userObj.telegram_id);
    const logPrefix = `[CF_PvPCallCB_V2 GID:${gameId} UID:${userId} Call:${callChoice}]`;
    const gameData = activeGames.get(gameId);

    if (!gameData || gameData.type !== GAME_IDS.COINFLIP_PVP || gameData.callerId !== userId || String(gameData.callerId) !== String(callerIdCheck) || gameData.status !== 'pvp_waiting_caller_choice') {
        await bot.answerCallbackQuery(callbackQueryId, { text: "This Coinflip call is not for you or has expired.", show_alert: true }).catch(() => {});
        return;
    }

    if (gameData.callerChoiceTimeoutId) clearTimeout(gameData.callerChoiceTimeoutId);
    gameData.callerChoiceTimeoutId = null;

    const callDisplay = callChoice === COINFLIP_CHOICE_HEADS ? "Heads" : "Tails";
    await bot.answerCallbackQuery(callbackQueryId, { text: `You've boldly called ${callDisplay}! The coin descends...` }).catch(() => {});

    gameData.callerChoice = callChoice;
    gameData.status = 'pvp_flipping';
    activeGames.set(gameId, gameData);

    const actualFlipOutcome = Math.random() < 0.5 ? COINFLIP_CHOICE_HEADS : COINFLIP_CHOICE_TAILS;
    gameData.result = actualFlipOutcome;

    const callerPlayerObj = gameData.callerId === gameData.p1.userId ? gameData.p1 : gameData.p2;
    const titleFlippingHTML = `💥 ${COIN_EMOJI_DISPLAY} <b>The Decisive Flip! The Moment of Truth!</b> ${COIN_EMOJI_DISPLAY} 💥`;
    let flippingMessageText = `${titleFlippingHTML}\n\n${callerPlayerObj.mentionHTML} made the call: <b>${escapeHTML(callDisplay)}</b>!\n` +
        `The coin tumbles through the air, secrets held tight... and finally lands!\n\n`;

    if (gameData.gameMessageId && bot) {
        for (let i = 0; i < COIN_FLIP_ANIMATION_STEPS; i++) {
            const frame = COIN_FLIP_ANIMATION_FRAMES[i % COIN_FLIP_ANIMATION_FRAMES.length];
            try {
                await bot.editMessageText(flippingMessageText + `<b>${frame}</b>`, { chat_id: gameData.chatId, message_id: Number(gameData.gameMessageId), parse_mode: 'HTML', reply_markup: {} });
            } catch (e) { if (!e.message?.includes("message is not modified")) console.warn(`${logPrefix} PvP Animation edit fail step ${i}`); break; }
            await sleep(COIN_FLIP_ANIMATION_INTERVAL_MS);
        }
    } else {
        const tempAnimMsg = await safeSendMessage(gameData.chatId, flippingMessageText + "<i>The result is IN!</i>", { parse_mode: "HTML" });
        await sleep(COIN_FLIP_ANIMATION_DURATION_MS);
        if (tempAnimMsg?.message_id && bot) await bot.deleteMessage(gameData.chatId, tempAnimMsg.message_id).catch(() => {});
    }

    await finalizeCoinflipPvPGame(gameData);
}

// CORRECTED finalizeCoinflipPvPGame
// CORRECTED finalizeCoinflipPvPGame (with Deadlock and Referral Fixes)
async function finalizeCoinflipPvPGame(gameData) {
    const { gameId, chatId, betAmount, p1, p2, callerId, callerChoice, result, status: finalStatus, _origin_key_for_limits } = gameData;
    const logPrefix = `[CF_PvP_Finalize_V7_FullFix GID:${gameId}]`;
    const activeGameKeyToClear = _origin_key_for_limits || GAME_IDS.COINFLIP_PVP;
    let allNotificationsToSend = [];

    let solPrice;
    try {
        solPrice = await getSolUsdPrice();
    } catch (priceError) {
        console.error(`${logPrefix} CRITICAL: Could not get SOL price. Level-up/milestone checks will be skipped. Error: ${priceError.message}`);
        solPrice = 0;
    }

    activeGames.delete(gameId);
    await updateGroupGameDetails(chatId, { removeThisId: gameId }, activeGameKeyToClear, null);
    console.log(`${logPrefix} Cleared active game lock for chat ${chatId} using key ${activeGameKeyToClear}.`);

    let winnerObj, loserObj;
    let p1Payout = 0n;
    let p2Payout = 0n;
    let p1LedgerCode = '';
    let p2LedgerCode = '';
    let titleResultHTML = `🎊 ${COIN_EMOJI_DISPLAY} <b>Coinflip PvP - The Outcome is Revealed!</b> ${COIN_EMOJI_DISPLAY} 🎊`;
    let resultDetailsHTML = "";
    let gameOutcomeTextForLog = "";
    let isConclusiveOutcome = false;

    const p1MentionHTML = p1.mentionHTML || escapeHTML(getPlayerDisplayReference(p1.userObj));
    const p2MentionHTML = p2.mentionHTML || escapeHTML(getPlayerDisplayReference(p2.userObj));
    const betDisplayUSD_HTML_Final = escapeHTML(await formatBalanceForDisplay(betAmount, 'USD'));
    const totalPotLamports = betAmount * 2n;

    if (finalStatus === 'game_over_p1_timeout_forfeit') {
        isConclusiveOutcome = true;
        winnerObj = p2; loserObj = p1; 
        p2Payout = totalPotLamports; 
        p1Payout = 0n; 
        p2LedgerCode = 'win_coinflip_pvp_opponent_timeout'; p1LedgerCode = 'loss_coinflip_pvp_self_forfeit';
        titleResultHTML = `⏳🏆 <b>${p2MentionHTML} Wins by Forfeit!</b> 🏆⏳`;
        resultDetailsHTML = `${p1MentionHTML} (the caller) timed out making a choice.\n🥳 <b>${p2MentionHTML}</b> wins the glorious pot of <b>${escapeHTML(await formatBalanceForDisplay(totalPotLamports, 'USD'))}</b>!`;
        gameOutcomeTextForLog = `P2 wins by P1 forfeit (timeout)`;
    } else if (finalStatus === 'game_over_p2_timeout_forfeit') {
        isConclusiveOutcome = true;
        winnerObj = p1; loserObj = p2; 
        p1Payout = totalPotLamports; 
        p2Payout = 0n; 
        p1LedgerCode = 'win_coinflip_pvp_opponent_timeout'; p2LedgerCode = 'loss_coinflip_pvp_self_timeout';
        titleResultHTML = `⏳🏆 <b>${p1MentionHTML} Wins by Forfeit!</b> 🏆⏳`;
        resultDetailsHTML = `${p2MentionHTML} (the caller) timed out making a choice.\n🥳 <b>${p1MentionHTML}</b> wins the glorious pot of <b>${escapeHTML(await formatBalanceForDisplay(totalPotLamports, 'USD'))}</b>!`;
        gameOutcomeTextForLog = `P1 wins by P2 forfeit (timeout)`;
    } else if (finalStatus === 'game_over_error_ui_update' || finalStatus === 'game_over_error_timeout_logic') {
        isConclusiveOutcome = false;
        p1Payout = betAmount; p2Payout = betAmount; 
        p1LedgerCode = 'refund_coinflip_pvp_error'; p2LedgerCode = 'refund_coinflip_pvp_error';
        titleResultHTML = `⚙️ <b>Coinflip PvP - Game Error</b> ⚙️`;
        resultDetailsHTML = `An unexpected error occurred. Bets of <b>${betDisplayUSD_HTML_Final}</b> each are being refunded.`;
        winnerObj = null; loserObj = null; 
        gameOutcomeTextForLog = `Error - bets refunded`;
    } else { 
        const callerWon = callerChoice === result;
        winnerObj = callerWon ? (callerId === p1.userId ? p1 : p2) : (callerId === p1.userId ? p2 : p1);
        loserObj = callerWon ? (callerId === p1.userId ? p2 : p1) : (callerId === p1.userId ? p1 : p2);
        
        if (winnerObj.userId === p1.userId) {
            isConclusiveOutcome = true;
            p1Payout = totalPotLamports; p2Payout = 0n;
            p1LedgerCode = `win_coinflip_pvp_result`; p2LedgerCode = `loss_coinflip_pvp_result`;
            gameOutcomeTextForLog = `P1 wins (Called: ${callerChoice}, Result: ${result})`;
        } else {
            isConclusiveOutcome = true;
            p2Payout = totalPotLamports; p1Payout = 0n;
            p2LedgerCode = `win_coinflip_pvp_result`; p1LedgerCode = `loss_coinflip_pvp_result`;
            gameOutcomeTextForLog = `P2 wins (Called: ${callerChoice}, Result: ${result})`;
        }

        const callerActualMentionHTML = (callerId === p1.userId ? p1MentionHTML : p2MentionHTML);
        const resultDisplay = result === COINFLIP_CHOICE_HEADS ? "Heads" : "Tails";
        const callDisplay = callerChoice === COINFLIP_CHOICE_HEADS ? "Heads" : "Tails";
        const winnerMentionToUse = winnerObj.userId === p1.userId ? p1MentionHTML : p2MentionHTML;
        const loserMentionToUse = loserObj.userId === p1.userId ? p1MentionHTML : p2MentionHTML;

        resultDetailsHTML = `The epic duel between ${p1MentionHTML} and ${p2MentionHTML} (wager: <b>${betDisplayUSD_HTML_Final}</b> each) has concluded!\n\n` +
            `<b>${callerActualMentionHTML}</b> was chosen to make the call and predicted: <b>${escapeHTML(callDisplay)}</b>!\n` +
            `The coin majestically landed on... ✨ <b>${COIN_EMOJI_DISPLAY} ${escapeHTML(resultDisplay)}!</b> ✨\n\n` +
            `And thus, the champion of this fateful flip is... 🥳🏆 <b>${winnerMentionToUse}</b>! You seize the glorious pot of <b>${escapeHTML(await formatBalanceForDisplay(totalPotLamports, 'USD'))}</b>!\n\n` +
            `Commiserations, ${loserMentionToUse}! Better luck on the next toss.`;
    }
    
    let client = null;
    try {
        client = await pool.connect(); await client.query('BEGIN');
        let p1BalanceUpdate, p2BalanceUpdate;

        const actualGameLogId = await logGameResultToGamesTable(
            client, activeGameKeyToClear, chatId, p1.userId, [p1.userId, p2.userId], betAmount, gameOutcomeTextForLog, 0n
        );
        
        // --- DEADLOCK PREVENTION: Sort players by ID before locking/updating ---
        const [playerA, playerB] = [p1, p2].sort((a, b) => String(a.userId).localeCompare(String(b.userId)));
        console.log(`${logPrefix} Locking order established. Player A: ${playerA.userId}, Player B: ${playerB.userId}`);

        const payoutA = (playerA.userId === p1.userId) ? p1Payout : p2Payout;
        const payoutB = (playerB.userId === p1.userId) ? p1Payout : p2Payout;
        const ledgerCodeA = (playerA.userId === p1.userId) ? p1LedgerCode : p2LedgerCode;
        const ledgerCodeB = (playerB.userId === p1.userId) ? p1LedgerCode : p2LedgerCode;

        // Process Player A first
        const updateA = await updateUserBalanceAndLedger(client, playerA.userId, payoutA, ledgerCodeA, 
            { game_log_id: actualGameLogId, opponent_id_custom_field: playerB.userId }, 
            `PvP Coinflip vs ${playerB.displayName || playerB.userId}. Caller: ${callerId === playerA.userId ? 'Self' : 'Opponent'}, Call: ${callerChoice || 'N/A (Timeout)'}, Result: ${result || 'N/A (Timeout)'}`, 
            solPrice
        );
        if (!updateA.success) throw new Error(`Player A (${playerA.userId}) balance update failed: ${updateA.error}`);
        if(updateA.notifications) allNotificationsToSend.push(...updateA.notifications);

        // Process Player B second
        const updateB = await updateUserBalanceAndLedger(client, playerB.userId, payoutB, ledgerCodeB, 
            { game_log_id: actualGameLogId, opponent_id_custom_field: playerA.userId }, 
            `PvP Coinflip vs ${playerA.displayName || playerA.userId}. Caller: ${callerId === playerB.userId ? 'Self' : 'Opponent'}, Call: ${callerChoice || 'N/A (Timeout)'}, Result: ${result || 'N/A (Timeout)'}`, 
            solPrice
        );
        if (!updateB.success && updateB.errorCode !== 'INSUFFICIENT_FUNDS') {
            console.warn(`${logPrefix} Non-critical error updating Player B (${playerB.userId}) ledger: ${updateB.error}`);
        } else if (!updateB.success) {
            throw new Error(`Player B (${playerB.userId}) balance update failed: ${updateB.error}`);
        }
        if(updateB.notifications) allNotificationsToSend.push(...updateB.notifications);
        
        // Map results back to original p1 and p2 for subsequent logic
        p1BalanceUpdate = (p1.userId === playerA.userId) ? updateA : updateB;
        p2BalanceUpdate = (p2.userId === playerA.userId) ? updateA : updateB;

        if (isConclusiveOutcome) {
            // --- ADDED: Check initial bet bonus for both players ---
            if (typeof processQualifyingBetAndInitialBonus === 'function') {
                await processQualifyingBetAndInitialBonus(client, p1.userId, betAmount, gameId);
                await processQualifyingBetAndInitialBonus(client, p2.userId, betAmount, gameId);
            }

            // --- Level up and milestone bonus checks ---
            if (p1BalanceUpdate.success && p1BalanceUpdate.newTotalWageredLamports !== undefined) {
                const p1LevelNotifications = await checkAndUpdateUserLevel(client, p1.userId, p1BalanceUpdate.newTotalWageredLamports, solPrice, chatId);
                allNotificationsToSend.push(...p1LevelNotifications);
                const p1MilestoneResult = await processWagerMilestoneBonus(client, p1.userId, p1BalanceUpdate.newTotalWageredLamports, solPrice);
                if (!p1MilestoneResult.success) console.warn(`${logPrefix} Failed to process milestone bonus for P1: ${p1MilestoneResult.error}`);
            }
            if (p2BalanceUpdate.success && p2BalanceUpdate.newTotalWageredLamports !== undefined) {
                const p2LevelNotifications = await checkAndUpdateUserLevel(client, p2.userId, p2BalanceUpdate.newTotalWageredLamports, solPrice, chatId);
                allNotificationsToSend.push(...p2LevelNotifications);
                const p2MilestoneResult = await processWagerMilestoneBonus(client, p2.userId, p2BalanceUpdate.newTotalWageredLamports, solPrice);
                if (!p2MilestoneResult.success) console.warn(`${logPrefix} Failed to process milestone bonus for P2: ${p2MilestoneResult.error}`);
            }
        }

        await client.query('COMMIT');
    } catch (e) {
        if (client) await client.query('ROLLBACK').catch(() => {});
        console.error(`${logPrefix} CRITICAL DB error during PvP Coinflip payout: ${e.message}`);
        resultDetailsHTML += `\n\n⚠️ Critical error settling wagers. Admin notified.`;
        if (typeof notifyAdmin === 'function') notifyAdmin(`🚨 CRITICAL Coinflip PvP Payout Failure 🚨\nGame ID: <code>${escapeHTML(gameId)}</code>\nError: ${escapeHTML(e.message)}. Manual check required.`, { parse_mode: 'HTML' });
    } finally { if (client) client.release(); }
    
    for (const notification of allNotificationsToSend) {
        if (notification.to === ADMIN_USER_ID && typeof notifyAdmin === 'function') {
            await notifyAdmin(notification.text, notification.options).catch(err => console.error(`Failed to send admin notification: ${err.message}`));
        } else {
            await safeSendMessage(notification.to, notification.text, notification.options).catch(err => console.error(`Failed to send game-related notification to ${notification.to}: ${err.message}`));
        }
    }

    const resultMessageHTML = `${titleResultHTML}\n\n${resultDetailsHTML}`;
    const postGameKeyboard = createPostGameKeyboard(GAME_IDS.COINFLIP_PVP, betAmount);

    if (gameData.gameMessageId && bot) {
        await bot.editMessageText(resultMessageHTML, { chat_id: chatId, message_id: Number(gameData.gameMessageId), parse_mode: 'HTML', reply_markup: postGameKeyboard }).catch(async (e) => {
            if (!e.message?.includes("message is not modified")) await safeSendMessage(chatId, resultMessageHTML, { parse_mode: 'HTML', reply_markup: postGameKeyboard });
        });
    } else {
        await safeSendMessage(chatId, resultMessageHTML, { parse_mode: 'HTML', reply_markup: postGameKeyboard });
    }
}


// --- Start of REVISED Rock Paper Scissors (RPS) Game Logic & Handlers (Unified Offer, HTML, New Mechanics, Granular Limits) ---
// (RPS_CHOICES, RPS_EMOJIS, RPS_RULES are assumed defined from Part 4)

// --- START OF REPLACEMENT for handleStartRPSUnifiedOfferCommand function ---
async function handleStartRPSUnifiedOfferCommand(msg, betAmountLamports, targetUsernameRaw = null) {
    const userId = String(msg.from.id || msg.from.telegram_id);
    const chatId = String(msg.chat.id);
    const chatType = msg.chat.type;
    const logPrefix = `[RPS_OfferOrDirect_V6_GranLimit UID:${userId} CH:${chatId}]`;

    // MODIFIED CALL to checkUserActiveGameLimit and NEW ERROR MESSAGE
    const activeUserGameCheck = await checkUserActiveGameLimit(userId, (targetUsernameRaw != null), null); 
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = escapeHTML(getPlayerDisplayReference(msg.from));
        const blockingGameType = activeUserGameCheck.details.type;
        const cleanGameName = getCleanGameName(blockingGameType); // Using the new helper
        const alertMessage = `✨ ${userDisplayName}, you already have a pending offer or active game for <b>${escapeHTML(cleanGameName)}</b>. ✨`;
        await safeSendMessage(chatId, alertMessage, { parse_mode: 'HTML' });
        return;
    }
    // END OF MODIFICATION

    if (chatType === 'private') {
        await safeSendMessage(chatId, `🪨📄✂️ The Rock Paper Scissors arena is best experienced in <b>group chats</b>! Please use <code>/rps &lt;bet&gt; [@username]</code> there.`, { parse_mode: 'HTML' });
        return;
    }

    let initiatorUserObj = await getOrCreateUser(userId, msg.from.username, msg.from.first_name, msg.from.last_name);
    if (!initiatorUserObj) {
        await safeSendMessage(chatId, `Sorry ${escapeHTML(msg.from.first_name || 'player')}, I couldn't fetch your profile. Try <code>/start</code> first.`, { parse_mode: 'HTML' });
        return;
    }
    const initiatorPlayerRefHTML = escapeHTML(getPlayerDisplayReference(initiatorUserObj));
    const betDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(betAmountLamports, 'USD'));

    if (BigInt(initiatorUserObj.balance) < betAmountLamports) {
        const needed = betAmountLamports - BigInt(initiatorUserObj.balance);
        await safeSendMessage(chatId, `${initiatorPlayerRefHTML}, your balance is too low for a <b>${betDisplayUSD_HTML}</b> RPS game! You need ~<b>${escapeHTML(await formatBalanceForDisplay(needed, 'USD'))}</b> more.`, {
            parse_mode: 'HTML',
            reply_markup: { inline_keyboard: [[{ text: "💸 Add Funds (DM)", callback_data: QUICK_DEPOSIT_CALLBACK_ACTION_CONST }]] }
        });
        return;
    }

    let targetUserObject = null;
    let isDirectChallenge = (targetUsernameRaw != null);

    if (isDirectChallenge) {
        targetUserObject = await findRecipientUser(targetUsernameRaw);
        if (!targetUserObject || !targetUserObject.telegram_id) {
            await safeSendMessage(chatId, `😕 Player ${escapeHTML(targetUsernameRaw)} not found. To make a general RPS offer, use <code>/rps ${escapeHTML(String(betAmountLamports / LAMPORTS_PER_SOL))}</code>.`, { parse_mode: 'HTML' });
            return;
        } else if (String(targetUserObject.telegram_id) === userId) {
            await safeSendMessage(chatId, `😅 You can't challenge yourself to RPS, ${initiatorPlayerRefHTML}! To make a general offer, use <code>/rps ${escapeHTML(String(betAmountLamports / LAMPORTS_PER_SOL))}</code>.`, { parse_mode: 'HTML' });
            return;
        }
    }

    const gameSession = await getGroupSession(chatId, msg.chat.title || `Group Chat ${chatId}`);
    let offerActivityKeyForLock;

    if (isDirectChallenge) {
        offerActivityKeyForLock = GAME_IDS.RPS_DIRECT_CHALLENGE_OFFER; 
        const currentDirectChallenges = gameSession.activeGamesByTypeInGroup.get(offerActivityKeyForLock) || [];
        const limitDirect = GAME_ACTIVITY_LIMITS.DIRECT_CHALLENGES[offerActivityKeyForLock] || 1; 
        if (currentDirectChallenges.length >= limitDirect) {
            await safeSendMessage(chatId, `⏳ Hold your hands, ${initiatorPlayerRefHTML}! The limit of ${limitDirect} concurrent direct RPS challenge(s) in this group has been reached. Please wait.`, { parse_mode: 'HTML' });
            return;
        }
    } else { // Unified Offer
        offerActivityKeyForLock = GAME_IDS.RPS;
        const currentUnifiedOffers = gameSession.activeGamesByTypeInGroup.get(offerActivityKeyForLock) || [];
        const limitUnified = GAME_ACTIVITY_LIMITS.UNIFIED_OFFERS[offerActivityKeyForLock] || 1;
        if (currentUnifiedOffers.length >= limitUnified) {
            await safeSendMessage(chatId, `⏳ Slow down, ${initiatorPlayerRefHTML}! The limit of ${limitUnified} concurrent RPS offer(s) in this group has been reached. Please wait.`, { parse_mode: 'HTML' });
            return;
        }
    }

    let offerId;
    let offerData;
    let clientBetPlacement = null;
    let timeoutDuration;

    try {
        clientBetPlacement = await pool.connect();
        await clientBetPlacement.query('BEGIN');

        if (isDirectChallenge) {
            offerId = generateGameId(`drps_${userId.slice(-3)}_${String(targetUserObject.telegram_id).slice(-3)}`);
            timeoutDuration = DIRECT_CHALLENGE_ACCEPT_TIMEOUT_MS;

            const betResultDirect = await updateUserBalanceAndLedger(clientBetPlacement, userId, BigInt(-betAmountLamports), 'bet_placed_rps_direct_challenge_offer', { custom_offer_id: offerId, opponent_id_custom_field: targetUserObject.telegram_id }, `Direct RPS Challenge Offer to ${targetUserObject.username || targetUserObject.telegram_id}`);
            if (!betResultDirect.success) {
                throw new Error(betResultDirect.error || "Failed to place your bet for the direct challenge.");
            }
            initiatorUserObj.balance = betResultDirect.newBalanceLamports;

            const targetPlayerRefHTML = escapeHTML(getPlayerDisplayReference(targetUserObject));
            const groupChallengeTextHTML = `Hey ${targetPlayerRefHTML}❗\n\n${initiatorPlayerRefHTML} has challenged you to a game of <b>Rock Paper Scissors</b> for <b>${betDisplayUSD_HTML}</b>! You have ${timeoutDuration / 1000} seconds to respond.`;
            const groupChallengeKeyboard = {
                inline_keyboard: [
                    [{ text: "✅ Accept Challenge", callback_data: `rps_direct_accept:${offerId}` }],
                    [{ text: "❌ Decline Challenge", callback_data: `rps_direct_decline:${offerId}` }],
                    [{ text: "🚫 Withdraw My Challenge", callback_data: `rps_direct_cancel:${offerId}` }]
                ]
            };
            const sentGroupMessage = await safeSendMessage(chatId, groupChallengeTextHTML, { parse_mode: 'HTML', reply_markup: groupChallengeKeyboard });
            if (!sentGroupMessage || !sentGroupMessage.message_id) {
                throw new Error("Could not send the direct challenge message to the group.");
            }

            offerData = {
                type: GAME_IDS.DIRECT_PVP_CHALLENGE,
                offerId: offerId,
                gameId: offerId,
                initiatorId: userId,
                initiatorUserObj: initiatorUserObj,
                initiatorMentionHTML: initiatorPlayerRefHTML,
                targetUserId: String(targetUserObject.telegram_id),
                targetUserObj: targetUserObject,
                targetUserMentionHTML: targetPlayerRefHTML, 
                betAmount: betAmountLamports,
                originalGroupId: chatId,
                offerMessageIdInGroup: String(sentGroupMessage.message_id),
                chatTitle: msg.chat.title || `Group Chat ${chatId}`,
                status: 'pending_direct_challenge_response',
                gameToStart: GAME_IDS.RPS_PVP,
                _offerKeyUsedForGroupLock: GAME_IDS.RPS_DIRECT_CHALLENGE_OFFER, 
                creationTime: Date.now(),
                timeoutId: null
            };
        } else { // Unified Offer
            offerId = generateGameId(GAME_IDS.RPS_UNIFIED_OFFER);
            timeoutDuration = UNIFIED_OFFER_TIMEOUT_MS;

            const betResultUnified = await updateUserBalanceAndLedger(clientBetPlacement, userId, BigInt(-betAmountLamports), 'bet_placed_rps_unified_offer', { custom_offer_id: offerId }, `RPS Unified Offer`);
            if (!betResultUnified.success) {
                throw new Error(betResultUnified.error || "Failed to place your bet for the unified offer.");
            }
            initiatorUserObj.balance = betResultUnified.newBalanceLamports;

            const offerMessageTextHTML = `✨🪨📄✂️ <b>A Battle of Wits! RPS Challenge!</b> ✂️📄🪨✨\n\n` +
                `${initiatorPlayerRefHTML} issues an RPS challenge for <b>${betDisplayUSD_HTML}</b>!\n\n` +
                `Face the cunning Bot Dealer or await a worthy PvP opponent!\n\n` +
                `<i>This offer expires in ${timeoutDuration / 1000} seconds! Initiator's bet will be refunded if it times out.</i>`;
            const offerKeyboard = {
                inline_keyboard: [
                    [{ text: "🤖 Challenge Bot", callback_data: `rps_accept_bot:${offerId}` }],
                    [{ text: "👤 Accept PvP Duel", callback_data: `rps_accept_pvp:${offerId}` }],
                    [{ text: "🚫 Withdraw Challenge", callback_data: `rps_cancel_offer:${offerId}` }]
                ]
            };
            const sentMessage = await safeSendMessage(chatId, offerMessageTextHTML, { parse_mode: 'HTML', reply_markup: offerKeyboard });
            if (!sentMessage?.message_id) {
                throw new Error("Could not send the unified offer message to the group.");
            }

            offerData = {
                type: GAME_IDS.RPS_UNIFIED_OFFER,
                gameId: offerId,
                chatId: chatId,
                chatType: chatType,
                initiatorId: userId,
                initiatorMentionHTML: initiatorPlayerRefHTML,
                initiatorUserObj: initiatorUserObj,
                betAmount: betAmountLamports,
                status: 'pending_offer',
                creationTime: Date.now(),
                offerMessageId: String(sentMessage.message_id),
                timeoutId: null
            };
        }

        await clientBetPlacement.query('COMMIT');
        activeGames.set(offerId, offerData);
        await updateGroupGameDetails(chatId, offerId, offerActivityKeyForLock, betAmountLamports);
        console.log(`${logPrefix} Offer ${offerId} (Type: ${offerData.type}, Group Lock Key: ${offerActivityKeyForLock}) created and bet placed.`);

        offerData.timeoutId = setTimeout(async () => {
            const timedOutOffer = activeGames.get(offerId);
            if (timedOutOffer && (timedOutOffer.status === 'pending_offer' || timedOutOffer.status === 'pending_direct_challenge_response')) {
                console.log(`${logPrefix} Offer ${offerId} (Type: ${timedOutOffer.type}) for RPS timed out.`);
                activeGames.delete(offerId);
                const keyForTimeoutRemoval = timedOutOffer._offerKeyUsedForGroupLock || offerActivityKeyForLock;
                await updateGroupGameDetails(chatId, { removeThisId: offerId }, keyForTimeoutRemoval, null);
                console.log(`${logPrefix} Cleared group lock for timed-out RPS offer ${offerId} using key ${keyForTimeoutRemoval}.`);

                let refundClient = null;
                try {
                    refundClient = await pool.connect();
                    await refundClient.query('BEGIN');
                    const refundReason = timedOutOffer.type === GAME_IDS.DIRECT_PVP_CHALLENGE ? 'direct_challenge_expired_unanswered' : 'unified_offer_expired_unanswered';
                    const refundNotes = `Refund for expired ${timedOutOffer.type === GAME_IDS.DIRECT_PVP_CHALLENGE ? 'direct RPS challenge' : 'unified RPS offer'} ${offerId}.`;
                    await updateUserBalanceAndLedger(refundClient, timedOutOffer.initiatorId, timedOutOffer.betAmount, `refund_rps_${refundReason}`, { custom_offer_id: offerId }, refundNotes);
                    await refundClient.query('COMMIT');
                    console.log(`${logPrefix} Bet refunded to initiator ${timedOutOffer.initiatorId} for timed out RPS offer ${offerId}.`);
                } catch (e) {
                    if (refundClient) await refundClient.query('ROLLBACK').catch(() => {});
                    console.error(`${logPrefix} CRITICAL: Failed to refund initiator ${timedOutOffer.initiatorId} for timed out RPS offer ${offerId}: ${e.message}`);
                    if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL REFUND FAILURE for timed out RPS offer ${offerId}, Initiator: ${timedOutOffer.initiatorId}, Bet: ${timedOutOffer.betAmount}. Error: ${e.message}`);
                } finally {
                    if (refundClient) refundClient.release();
                }

                const messageIdToEdit = timedOutOffer.offerMessageIdInGroup || timedOutOffer.offerMessageId;
                const currentBetDisplayHTML_Timeout = escapeHTML(await formatBalanceForDisplay(timedOutOffer.betAmount, 'USD'));
                const timeoutMessageHTML = timedOutOffer.type === GAME_IDS.DIRECT_PVP_CHALLENGE ?
                    `⏳ The RPS challenge from ${timedOutOffer.initiatorMentionHTML} to ${timedOutOffer.targetUserMentionHTML} (<b>${currentBetDisplayHTML_Timeout}</b>) has expired unanswered. Initiator's bet refunded.` :
                    `⏳ The RPS offer by ${timedOutOffer.initiatorMentionHTML} (<b>${currentBetDisplayHTML_Timeout}</b>) has expired unanswered. Initiator's bet refunded.`;

                if (messageIdToEdit && bot) {
                    await bot.editMessageText(timeoutMessageHTML, {
                        chat_id: chatId, message_id: Number(messageIdToEdit),
                        parse_mode: 'HTML', reply_markup: {}
                    }).catch(e => console.warn(`${logPrefix} Failed to edit expired RPS offer message ${messageIdToEdit}: ${e.message}`));
                }
            }
        }, timeoutDuration);
        activeGames.set(offerId, offerData); 

    } catch (error) {
        if (clientBetPlacement) await clientBetPlacement.query('ROLLBACK').catch(() => {});
        console.error(`${logPrefix} Error creating RPS offer or placing bet: ${error.message}`);
        await safeSendMessage(chatId, `⚠️ Error creating your RPS offer: ${escapeHTML(error.message)}. Please try again.`, { parse_mode: 'HTML' });
        if (offerId && activeGames.has(offerId)) {
            activeGames.delete(offerId);
            const keyForErrorCleanup = offerData?._offerKeyUsedForGroupLock || offerActivityKeyForLock;
            if(keyForErrorCleanup) await updateGroupGameDetails(chatId, { removeThisId: offerId }, keyForErrorCleanup, null);
       }
    } finally {
        if (clientBetPlacement) clientBetPlacement.release();
    }
}
// --- END OF REPLACEMENT for handleStartRPSUnifiedOfferCommand function ---

// --- RPS Offer Callback Handlers ---
async function handleRPSAcceptBotGameCallback(offerId, userWhoClicked, originalOfferMessageId, originalChatId, originalChatType, callbackQueryId) {
    const userId = String(userWhoClicked.id || userWhoClicked.telegram_id);
    const logPrefix = `[RPS_AcceptBotCB_V3_GranLimit OfferID:${offerId} UID:${userId}]`;
    const offerData = activeGames.get(offerId);

    // --- NEW USER ACTIVE GAME LIMIT CHECK ---
    const activeUserGameCheck = await checkUserActiveGameLimit(userId, false, offerId); // Pass offerId as gameIdBeingActioned
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = escapeHTML(getPlayerDisplayReference(userWhoClicked));
        const blockingGameType = activeUserGameCheck.details.type;
        const cleanGameName = getCleanGameName(blockingGameType);
        let alertMessage = `✨ ${userDisplayName}, you're already in a game of ${escapeHTML(cleanGameName)}. ✨ Finish it first!`;
        alertMessage = alertMessage.substring(0, 200); // Telegram alert length limit

        await bot.answerCallbackQuery(callbackQueryId, { text: alertMessage, show_alert: true }).catch(() => {});
        return;
    }
    // --- END OF NEW USER ACTIVE GAME LIMIT CHECK ---

    if (!offerData || offerData.type !== GAME_IDS.RPS_UNIFIED_OFFER || offerData.status !== 'pending_offer') {
        await bot.answerCallbackQuery(callbackQueryId, { text: "This RPS offer is no longer valid.", show_alert: true }).catch(() => {});
        if (originalOfferMessageId && bot) bot.editMessageReplyMarkup({}, { chat_id: originalChatId, message_id: Number(originalOfferMessageId) }).catch(() => {});
        return;
    }
    if (offerData.initiatorId !== userId) {
        await bot.answerCallbackQuery(callbackQueryId, { text: "Only the one who laid down the gauntlet can face the Bot!", show_alert: true }).catch(() => {});
        return;
    }

    const gameSession = await getGroupSession(originalChatId);
    const activeGameKeyToCheck = GAME_IDS.RPS_PVB; 
    const currentActiveGames = gameSession.activeGamesByTypeInGroup.get(activeGameKeyToCheck) || [];
    const limitActive = GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[activeGameKeyToCheck] || 1;
    if (currentActiveGames.length >= limitActive) {
        await bot.answerCallbackQuery(callbackQueryId, { text: `Max ${limitActive} active RPS game(s) allowed in this group. Please wait.`, show_alert: true }).catch(() => {});
        return;
    }

    if (offerData.timeoutId) clearTimeout(offerData.timeoutId);
    await bot.answerCallbackQuery(callbackQueryId, { text: "🤖 Preparing your RPS duel with the Bot Dealer..." }).catch(() => {});

    offerData.status = 'bot_game_accepted';
    activeGames.set(offerId, offerData);

    await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.RPS, null); 
    activeGames.delete(offerId); 

    await startRPSPvBGame(originalChatId, offerData.initiatorUserObj, offerData.betAmount, offerData.offerMessageId, null);
}

async function handleRPSAcceptPvPChallengeCallback(offerId, joinerUserObjFull, originalOfferMessageId, originalChatId, originalChatType, callbackQueryId) {
    const joinerId = String(joinerUserObjFull.id || joinerUserObjFull.telegram_id);
    const logPrefix = `[RPS_AcceptPvPCB_V3_GranLimit OfferID:${offerId} JoinerID:${joinerId}]`;
    const offerData = activeGames.get(offerId);

    // --- NEW USER ACTIVE GAME LIMIT CHECK ---
    const activeUserGameCheck = await checkUserActiveGameLimit(joinerId, false, offerId); // Pass offerId as gameIdBeingActioned
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = escapeHTML(getPlayerDisplayReference(joinerUserObjFull));
        const blockingGameType = activeUserGameCheck.details.type;
        const cleanGameName = getCleanGameName(blockingGameType);
        let alertMessage = `✨ ${userDisplayName}, you're already in a game of ${escapeHTML(cleanGameName)}. ✨ Finish it first!`;
        alertMessage = alertMessage.substring(0, 200); // Telegram alert length limit

        await bot.answerCallbackQuery(callbackQueryId, { text: alertMessage, show_alert: true }).catch(() => {});
        return;
    }
    // --- END OF NEW USER ACTIVE GAME LIMIT CHECK ---

    if (!offerData || offerData.type !== GAME_IDS.RPS_UNIFIED_OFFER || offerData.status !== 'pending_offer') {
        await bot.answerCallbackQuery(callbackQueryId, { text: "This RPS PvP challenge has already been met or has expired!", show_alert: true }).catch(() => {});
        if (originalOfferMessageId && bot) bot.editMessageReplyMarkup({}, { chat_id: originalChatId, message_id: Number(originalOfferMessageId) }).catch(() => {});
        return;
    }
    if (offerData.initiatorId === joinerId) {
        await bot.answerCallbackQuery(callbackQueryId, { text: "A duel with oneself? An interesting strategy, but not for this game!", show_alert: true }).catch(() => {});
        return;
    }

    const gameSession = await getGroupSession(originalChatId);
    const activeGameKeyToCheck = GAME_IDS.RPS_PVP_FROM_UNIFIED; 
    const currentActiveGames = gameSession.activeGamesByTypeInGroup.get(activeGameKeyToCheck) || [];
    const limitActive = GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[activeGameKeyToCheck] || 1;

    if (currentActiveGames.length >= limitActive) {
        await bot.answerCallbackQuery(callbackQueryId, { text: `Max ${limitActive} active RPS PvP (from unified offers) game(s) allowed. Please wait.`, show_alert: true }).catch(() => {});
        return;
    }

    const betDisplayHTML = escapeHTML(await formatBalanceForDisplay(offerData.betAmount, 'USD'));
    const currentJoinerUserObj = await getOrCreateUser(joinerId, joinerUserObjFull.username, joinerUserObjFull.first_name, joinerUserObjFull.last_name);
    if (!currentJoinerUserObj || BigInt(currentJoinerUserObj.balance) < offerData.betAmount) {
        await bot.answerCallbackQuery(callbackQueryId, { text: `Your funds are insufficient for this ${betDisplayHTML} RPS battle!`, show_alert: true }).catch(() => {});
        const needed = offerData.betAmount - BigInt(currentJoinerUserObj.balance);
        await safeSendMessage(originalChatId, `💰 ${escapeHTML(getPlayerDisplayReference(currentJoinerUserObj))} your war chest is short by ~<b>${escapeHTML(await formatBalanceForDisplay(needed, 'USD'))}</b> for this intense <b>${betDisplayHTML}</b> RPS duel.`, {
            parse_mode: 'HTML', reply_markup: { inline_keyboard: [[{ text: "💸 Add Funds (DM)", callback_data: QUICK_DEPOSIT_CALLBACK_ACTION_CONST }]] }
        });
        return;
    }
    const currentInitiatorUserObj = await getOrCreateUser(offerData.initiatorId); 
    if (!currentInitiatorUserObj || BigInt(currentInitiatorUserObj.balance) < offerData.betAmount) {
        await bot.answerCallbackQuery(callbackQueryId, { text: "Initiator can't cover the bet. Offer cancelled.", show_alert:true}).catch(()=>{});
        if (offerData.offerMessageId && bot) {
            await bot.editMessageText(`⚠️ <b>Offer Auto-Cancelled</b><br>The RPS challenge by ${offerData.initiatorMentionHTML} for <b>${betDisplayHTML}</b> was cancelled as their balance is no longer sufficient.`, {
                chat_id: originalChatId, message_id: Number(offerData.offerMessageId), parse_mode: 'HTML', reply_markup: {inline_keyboard:[]}
            }).catch(()=>{});
        }
        if (offerData.timeoutId) clearTimeout(offerData.timeoutId);
        activeGames.delete(offerId);
        await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.RPS, null); 
        return;
    }

    if (offerData.timeoutId) clearTimeout(offerData.timeoutId);
    await bot.answerCallbackQuery(callbackQueryId, { text: "⚔️ RPS PvP Duel Accepted! Prepare your minds..." }).catch(() => {});

    offerData.status = 'pvp_accepted';
    activeGames.set(offerId, offerData);

    await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.RPS, null); 
    
    await startRPSPvPGame(
        currentInitiatorUserObj,
        currentJoinerUserObj, 
        offerData.betAmount,
        originalChatId,
        offerData.offerMessageId,
        'unified_offer',
        false 
    );
    activeGames.delete(offerId); 
}

async function handleRPSCancelOfferCallback(offerId, userWhoClicked, originalOfferMessageId, originalChatId, callbackQueryId) {
    const userId = String(userWhoClicked.id || userWhoClicked.telegram_id);
    const logPrefix = `[RPS_CancelOfferCB_V2 OfferID:${offerId} UID:${userId}]`; 
    const offerData = activeGames.get(offerId);

    if (!offerData || offerData.type !== GAME_IDS.RPS_UNIFIED_OFFER || offerData.status !== 'pending_offer') {
        await bot.answerCallbackQuery(callbackQueryId, { text: "Offer already gone or actioned!", show_alert: false }).catch(() => {});
        if (originalOfferMessageId && bot) bot.editMessageReplyMarkup({}, { chat_id: originalChatId, message_id: Number(originalOfferMessageId) }).catch(() => {});
        return;
    }
    if (offerData.initiatorId !== userId) {
        await bot.answerCallbackQuery(callbackQueryId, { text: "Only the initiator can cancel this RPS challenge.", show_alert: true }).catch(() => {});
        return;
    }

    if (offerData.timeoutId) clearTimeout(offerData.timeoutId);
    await bot.answerCallbackQuery(callbackQueryId, { text: "RPS challenge withdrawn. Refunding bet..." }).catch(() => {});

    activeGames.delete(offerId);
    await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.RPS, null); 

    let refundClient = null;
    try {
        refundClient = await pool.connect();
        await refundClient.query('BEGIN');
        await updateUserBalanceAndLedger(refundClient, offerData.initiatorId, offerData.betAmount, 'refund_rps_offer_cancelled', { custom_offer_id: offerId }, `Refund for cancelled RPS unified offer ${offerId}`);
        await refundClient.query('COMMIT');
        console.log(`${logPrefix} Bet refunded to initiator ${offerData.initiatorId} for cancelled RPS offer ${offerId}.`);
    } catch (e) {
        if (refundClient) await refundClient.query('ROLLBACK').catch(() => {});
        console.error(`${logPrefix} CRITICAL: Failed to refund initiator ${offerData.initiatorId} for cancelled RPS offer ${offerId}: ${e.message}`);
        if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL REFUND FAILURE for cancelled RPS offer ${offerId}, Initiator: ${offerData.initiatorId}, Bet: ${offerData.betAmount}. Error: ${e.message}`);
    } finally {
        if (refundClient) refundClient.release();
    }

    const betDisplayHTML = escapeHTML(await formatBalanceForDisplay(offerData.betAmount, 'USD'));
    if (originalOfferMessageId && bot) {
        await bot.editMessageText(`🚫 <b>Challenge Retracted!</b>\nThe RPS duel by ${offerData.initiatorMentionHTML} (wager: <b>${betDisplayHTML}</b>) has been cancelled. Bet refunded.`, {
            chat_id: originalChatId, message_id: Number(originalOfferMessageId), parse_mode: 'HTML', reply_markup: {}
        }).catch(async (e) => {
            await safeSendMessage(originalChatId, `🚫 RPS challenge by ${offerData.initiatorMentionHTML} for <b>${betDisplayHTML}</b> withdrawn. Bet refunded.`, { parse_mode: 'HTML' });
        });
    } else {
        await safeSendMessage(originalChatId, `🚫 RPS challenge by ${offerData.initiatorMentionHTML} for <b>${betDisplayHTML}</b> withdrawn. Bet refunded.`, { parse_mode: 'HTML' });
    }
}

// --- RPS Player vs. Bot (PvB) Logic ---
async function startRPSPvBGame(chatId, initiatorUserObj, betAmountLamports, originalOfferMessageId, offerIdToDeleteIfAny) {
    const userId = String(initiatorUserObj.id || initiatorUserObj.telegram_id);
    const logPrefix = `[RPS_PvB_Start_V3_GranLimit UID:${userId} CH:${chatId}]`;
    const playerRefHTML = escapeHTML(getPlayerDisplayReference(initiatorUserObj));
    
    const activeGameActivityKey = GAME_IDS.RPS_PVB; 

    if (originalOfferMessageId && bot) await bot.deleteMessage(chatId, Number(originalOfferMessageId)).catch(() => {});
    if (offerIdToDeleteIfAny) activeGames.delete(offerIdToDeleteIfAny);

    console.log(`${logPrefix} Starting RPS PvB. Bet was already placed by initiator ${userId}.`);

    const pvbGameId = generateGameId(GAME_IDS.RPS_PVB);
    const gameDataPvB = {
        type: GAME_IDS.RPS_PVB, gameId: pvbGameId, chatId, userId,
        playerRefHTML, userObj: initiatorUserObj, betAmount: betAmountLamports,
        playerChoice: null, botChoice: null, result: null, status: 'pvb_waiting_player_choice',
        gameMessageId: null, lastInteractionTime: Date.now(),
        choiceTimeoutId: null
    };
    activeGames.set(pvbGameId, gameDataPvB);
    await updateGroupGameDetails(chatId, pvbGameId, activeGameActivityKey, betAmountLamports);
    console.log(`${logPrefix} RPS PvB game ${pvbGameId} started. Group lock for ${activeGameActivityKey} updated.`);

    const betDisplayUSD_HTML_PvB = escapeHTML(await formatBalanceForDisplay(betAmountLamports, 'USD'));
    const titleHTML = `🤖🪨📄✂️ <b>RPS: ${playerRefHTML} vs. The Bot Brain!</b> ✂️📄🪨🤖`;
    const initialMessageTextHTML = `${titleHTML}\n\nWager: <b>${betDisplayUSD_HTML_PvB}</b>\n\n` +
        `The Bot Dealer cracks its digital knuckles! ${playerRefHTML}, make your move! Choose your weapon: Rock, Paper, or Scissors?\n<i>(You have ${ACTIVE_GAME_TURN_TIMEOUT_MS / 1000} seconds to choose)</i>`;
    const keyboard = {
        inline_keyboard: [
            [
                { text: `${RPS_EMOJIS.rock} Rock`, callback_data: `rps_pvb_choice:${pvbGameId}:${RPS_CHOICES.ROCK}` },
                { text: `${RPS_EMOJIS.paper} Paper`, callback_data: `rps_pvb_choice:${pvbGameId}:${RPS_CHOICES.PAPER}` },
                { text: `${RPS_EMOJIS.scissors} Scissors`, callback_data: `rps_pvb_choice:${pvbGameId}:${RPS_CHOICES.SCISSORS}` }
            ],
            [{ text: "📖 Rules", callback_data: `${RULES_CALLBACK_PREFIX_CONST}${GAME_IDS.RPS}` }]
        ]
    };
    const sentMessage = await safeSendMessage(chatId, initialMessageTextHTML, { parse_mode: 'HTML', reply_markup: keyboard });
    if (sentMessage?.message_id) {
        gameDataPvB.gameMessageId = String(sentMessage.message_id);
        gameDataPvB.choiceTimeoutId = setTimeout(() => {
            handleRPSPvBChoiceTimeout(pvbGameId);
        }, ACTIVE_GAME_TURN_TIMEOUT_MS); 
        activeGames.set(pvbGameId, gameDataPvB);
    } else {
        console.error(`${logPrefix} Failed to send RPS PvB game message for ${pvbGameId}. Bet was already taken.`);
        activeGames.delete(pvbGameId);
        await updateGroupGameDetails(chatId, { removeThisId: pvbGameId }, activeGameActivityKey, null);
        await safeSendMessage(chatId, `⚙️ Error displaying RPS PvB game for ${playerRefHTML}. Your bet was placed. Please contact support if the game doesn't resolve.`, {parse_mode:'HTML'});
    }
}

async function handleRPSPvBChoiceTimeout(gameId) {
    const LOG_PREFIX_RPS_PVB_CHOICE_TIMEOUT = `[RPS_PvB_ChoiceTimeout_V2 GID:${gameId}]`;
    const gameData = activeGames.get(gameId);

    if (!gameData || gameData.type !== GAME_IDS.RPS_PVB || gameData.status !== 'pvb_waiting_player_choice') {
        if (gameData && gameData.choiceTimeoutId) clearTimeout(gameData.choiceTimeoutId);
        return;
    }
    console.log(`${LOG_PREFIX_RPS_PVB_CHOICE_TIMEOUT} Player ${gameData.userId} timed out for RPS PvB choice. Game forfeited, bet lost.`);

    if (gameData.choiceTimeoutId) clearTimeout(gameData.choiceTimeoutId);
    gameData.choiceTimeoutId = null;

    activeGames.delete(gameId);
    await updateGroupGameDetails(String(gameData.chatId), { removeThisId: gameId }, GAME_IDS.RPS_PVB, null); 

    let client = null;
    try {
        client = await pool.connect();
        await client.query('BEGIN');
        await updateUserBalanceAndLedger(
            client, gameData.userId, 0n, 'loss_rps_pvb_choice_timeout',
            { game_id_custom_field: gameId, original_bet_amount: gameData.betAmount.toString() },
            `Player forfeited RPS PvB game ${gameId} due to choice timeout. Bet lost.`
        );
        await client.query('COMMIT');
    } catch (dbError) {
        if (client) await client.query('ROLLBACK').catch(() => {});
        console.error(`${LOG_PREFIX_RPS_PVB_CHOICE_TIMEOUT} DB error logging forfeit for ${gameId}: ${dbError.message}`);
        if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL RPS PvB TIMEOUT FORFEIT LOGGING FAILURE GID: ${gameId}, User: ${gameData.userId}. Error: ${dbError.message}`);
    } finally {
        if (client) client.release();
    }

    const playerRefHTML = gameData.playerRefHTML || escapeHTML(getPlayerDisplayReference(gameData.userObj || { id: gameData.userId, first_name: "Player" }));
    const betDisplayUSD_HTML_Timeout = escapeHTML(await formatBalanceForDisplay(gameData.betAmount, 'USD'));
    const timeoutMessageText = `⏰ ${playerRefHTML}, your Rock Paper Scissors game (Bet: <b>${betDisplayUSD_HTML_Timeout}</b>) timed out as no choice was made.\nYour bet has been forfeited.`;

    const messageIdToEdit = Number(gameData.gameMessageId);
    if (bot && messageIdToEdit) {
        await bot.editMessageText(timeoutMessageText, {
            chat_id: String(gameData.chatId), message_id: messageIdToEdit,
            parse_mode: 'HTML', reply_markup: createPostGameKeyboard(GAME_IDS.RPS_PVB, gameData.betAmount) 
        }).catch(async (err) => {
            await safeSendMessage(String(gameData.chatId), timeoutMessageText, { parse_mode: 'HTML', reply_markup: createPostGameKeyboard(GAME_IDS.RPS_PVB, gameData.betAmount) });
        });
    } else {
        await safeSendMessage(String(gameData.chatId), timeoutMessageText, { parse_mode: 'HTML', reply_markup: createPostGameKeyboard(GAME_IDS.RPS_PVB, gameData.betAmount) });
    }
}

async function handleRPSPvBChoiceCallback(gameId, playerChoiceKey, userObj, originalMessageId, callbackQueryId) {
    const userId = String(userObj.id || userObj.telegram_id);
    const logPrefix = `[RPS_PvBChoiceCB_V2 GID:${gameId} UID:${userId} Choice:${playerChoiceKey}]`;
    const gameData = activeGames.get(gameId);

    if (!gameData || gameData.type !== GAME_IDS.RPS_PVB || gameData.userId !== userId || gameData.status !== 'pvb_waiting_player_choice') {
        await bot.answerCallbackQuery(callbackQueryId, { text: "This RPS game action is outdated or not yours.", show_alert: true }).catch(() => {});
        return;
    }

    if (gameData.choiceTimeoutId) clearTimeout(gameData.choiceTimeoutId);
    gameData.choiceTimeoutId = null;

    const playerChoiceDisplay = playerChoiceKey.charAt(0).toUpperCase() + playerChoiceKey.slice(1);
    await bot.answerCallbackQuery(callbackQueryId, { text: `You chose ${RPS_EMOJIS[playerChoiceKey]} ${playerChoiceDisplay}! Bot is making its move...` }).catch(() => {});

    gameData.playerChoice = playerChoiceKey;
    const botRPSChoice = getRandomRPSChoice();
    gameData.botChoice = botRPSChoice.choice;
    gameData.status = 'pvb_resolving';
    activeGames.set(gameId, gameData);

    const playerChoiceEmoji = RPS_EMOJIS[gameData.playerChoice];
    const titleResolvingHTML = `💥 <b>RPS Showdown Unfolds!</b> 💥`;
    let resolvingText = `${titleResolvingHTML}\n\n${gameData.playerRefHTML} throws: ${playerChoiceEmoji}\n` +
        `Bot Dealer counters with: Thinking... 🤔\n\n<i>The tension mounts!</i>`;

    if (gameData.gameMessageId && bot) {
        try {
            await bot.editMessageText(resolvingText, { chat_id: gameData.chatId, message_id: Number(gameData.gameMessageId), parse_mode: 'HTML', reply_markup: {} });
        } catch (e) {
            if (!e.message || !e.message.toLowerCase().includes("message is not modified")) {
                const newMsg = await safeSendMessage(gameData.chatId, resolvingText, { parse_mode: 'HTML' });
                if (newMsg?.message_id && activeGames.has(gameId)) {
                    const currentGd = activeGames.get(gameId);
                    if (currentGd) currentGd.gameMessageId = String(newMsg.message_id);
                }
            }
        }
    } else {
        const newMsg = await safeSendMessage(gameData.chatId, resolvingText, { parse_mode: 'HTML' });
        if (newMsg?.message_id && activeGames.has(gameId)) {
            const currentGd = activeGames.get(gameId);
            if (currentGd) currentGd.gameMessageId = String(newMsg.message_id);
        }
    }

    await sleep(2500); 
    await finalizeRPSPvBGame(gameData);
}

// CORRECTED finalizeRPSPvBGame
// CORRECTED finalizeRPSPvBGame (with Referral Fixes)
async function finalizeRPSPvBGame(gameData) {
    const { gameId, chatId, userId, playerRefHTML, betAmount, playerChoice, botChoice, userObj } = gameData;
    const logPrefix = `[RPS_PvB_Finalize_V6_FullFix GID:${gameId}]`;
    let allNotificationsToSend = [];

    let solPrice;
    try {
        solPrice = await getSolUsdPrice();
    } catch (priceError) {
        console.error(`${logPrefix} CRITICAL: Could not get SOL price. Level-up/milestone checks will be skipped. Error: ${priceError.message}`);
        solPrice = 0;
    }

    await updateGroupGameDetails(chatId, { removeThisId: gameId }, GAME_IDS.RPS_PVB, null);
    const rpsOutcome = determineRPSOutcome(playerChoice, botChoice, playerRefHTML, "Bot Dealer");
    let payoutAmountLamports = 0n;
    let ledgerOutcomeCode = `loss_rps_pvb_${playerChoice}_vs_${botChoice}`;
    let financialOutcomeText = "";
    let gameOutcomeTextForLog = `Player: ${playerChoice}, Bot: ${botChoice} - ${rpsOutcome.result}`;
    let isConclusiveOutcome = false;

    if (rpsOutcome.result === 'win_player1') {
        isConclusiveOutcome = true;
        payoutAmountLamports = betAmount * 2n;
        const profitAmount = betAmount;
        financialOutcomeText = `Congratulations! You won <b>${escapeHTML(await formatBalanceForDisplay(profitAmount, 'USD'))}</b> in profit (total payout: ${escapeHTML(await formatBalanceForDisplay(payoutAmountLamports, 'USD'))})!`;
        ledgerOutcomeCode = `win_rps_pvb_${playerChoice}_vs_${botChoice}`;
    } else if (rpsOutcome.result === 'draw') {
        isConclusiveOutcome = false; // A push does not trigger wager-based bonuses
        payoutAmountLamports = betAmount;
        financialOutcomeText = `Your wager of <b>${escapeHTML(await formatBalanceForDisplay(betAmount, 'USD'))}</b> has been returned.`;
        ledgerOutcomeCode = `draw_rps_pvb_${playerChoice}_vs_${botChoice}`;
    } else if (rpsOutcome.result === 'error') { 
        isConclusiveOutcome = false;
        payoutAmountLamports = betAmount; // Refund in case of game logic error
        ledgerOutcomeCode = `refund_rps_pvb_logic_error`;
        financialOutcomeText = `There was an issue determining the RPS outcome. Your bet of <b>${escapeHTML(await formatBalanceForDisplay(betAmount, 'USD'))}</b> is refunded.`;
        gameOutcomeTextForLog = `Game Logic Error - Player: ${playerChoice}, Bot: ${botChoice}`;
    } else { // Bot wins
        isConclusiveOutcome = true;
        financialOutcomeText = `The Bot Dealer claims your wager of <b>${escapeHTML(await formatBalanceForDisplay(betAmount, 'USD'))}</b>.`;
    }

    let client = null;
    try {
        client = await pool.connect(); await client.query('BEGIN');
        const actualGameLogId = await logGameResultToGamesTable(
            client, GAME_IDS.RPS_PVB, chatId, userId, [userId], betAmount, gameOutcomeTextForLog, 0n
        );

        const balanceUpdate = await updateUserBalanceAndLedger(
            client, userId, payoutAmountLamports, ledgerOutcomeCode,
            { game_log_id: actualGameLogId }, `RPS PvB: ${playerChoice} vs Bot ${botChoice}`,
            solPrice
        );
        if (!balanceUpdate.success) {
            throw new Error(balanceUpdate.error || "DB Error during RPS PvB payout.");
        }
        if (balanceUpdate.notifications && balanceUpdate.notifications.length > 0) {
            allNotificationsToSend.push(...balanceUpdate.notifications);
        }
        
        if (isConclusiveOutcome) {
            // --- START OF MODIFICATION ---

            // 1. ADDED: Check for the initial bet bonus.
            if (typeof processQualifyingBetAndInitialBonus === 'function') {
                const initialBonusResult = await processQualifyingBetAndInitialBonus(client, userId, betAmount, gameId);
                if (initialBonusResult.jobQueued) {
                    console.log(`[ReferralCheck] Queued initial bet bonus job for user ${userId} from game ${gameId}.`);
                }
            }
            
            // 2. MODIFIED: Correctly call level and milestone checks.
            if (balanceUpdate.newTotalWageredLamports !== undefined) {
                if (typeof checkAndUpdateUserLevel === 'function') {
                    const levelNotifications = await checkAndUpdateUserLevel(client, userId, balanceUpdate.newTotalWageredLamports, solPrice, chatId);
                    allNotificationsToSend.push(...levelNotifications);
                }
                if (typeof processWagerMilestoneBonus === 'function') {
                    const milestoneResult = await processWagerMilestoneBonus(client, userId, balanceUpdate.newTotalWageredLamports, solPrice);
                    if (!milestoneResult.success) {
                        console.warn(`${logPrefix} Failed to process milestone bonus: ${milestoneResult.error}`);
                    }
                }
            }

            // --- END OF MODIFICATION ---
        }

        await client.query('COMMIT');
    } catch (e) {
        if (client) await client.query('ROLLBACK').catch(() => {});
        console.error(`${logPrefix} CRITICAL DB error: ${e.message}`);
        const dbErrorMsg = `<br><br>⚠️ Critical error settling wager. Admin notified.`;
        rpsOutcome.description = (rpsOutcome.description && rpsOutcome.result === 'error' ? rpsOutcome.description : (rpsOutcome.description || "Game error.")) + dbErrorMsg;
        if (typeof notifyAdmin === 'function') notifyAdmin(`🚨 CRITICAL RPS PvB Payout Failure 🚨\nGame ID: <code>${escapeHTML(gameId)}</code>\nError: ${escapeHTML(e.message)}. Manual check needed.`, { parse_mode: 'HTML'});
    } finally { 
        if (client) client.release(); 
    }

    // Send all collected notifications AFTER the transaction is closed
    for (const notification of allNotificationsToSend) {
        if (notification.to === ADMIN_USER_ID && typeof notifyAdmin === 'function') {
            await notifyAdmin(notification.text, notification.options).catch(err => console.error(`Failed to send admin notification: ${err.message}`));
        } else {
            await safeSendMessage(notification.to, notification.text, notification.options).catch(err => console.error(`Failed to send game-related notification to ${notification.to}: ${err.message}`));
        }
    }

    const titleResultHTML = `⚡️ <b>RPS PvB - The Dust Settles!</b> ⚡️`;
    const resultMessageHTML = `${titleResultHTML}\n\n${playerRefHTML} wagered <b>${escapeHTML(await formatBalanceForDisplay(betAmount, 'USD'))}</b>.\n\n` +
        `Your masterful choice: ${RPS_EMOJIS[playerChoice]} <b>${escapeHTML(rpsOutcome.player1.choiceFormatted)}</b>\n` +
        `The Bot Dealer's cunning play: ${RPS_EMOJIS[botChoice]} <b>${escapeHTML(rpsOutcome.player2.choiceFormatted)}</b>\n\n` +
        `<i>${rpsOutcome.description}</i>\n\n` + 
        `${financialOutcomeText}`;

    const postGameKeyboard = createPostGameKeyboard(GAME_IDS.RPS_PVB, betAmount);
    if (gameData.gameMessageId && bot) {
        await bot.editMessageText(resultMessageHTML, { chat_id: chatId, message_id: Number(gameData.gameMessageId), parse_mode: 'HTML', reply_markup: postGameKeyboard }).catch(async (e) => {
            if (!e.message?.includes("message is not modified")) await safeSendMessage(chatId, resultMessageHTML, { parse_mode: 'HTML', reply_markup: postGameKeyboard });
        });
    } else {
        await safeSendMessage(chatId, resultMessageHTML, { parse_mode: 'HTML', reply_markup: postGameKeyboard });
    }
    activeGames.delete(gameId);
}

// --- RPS Player vs. Player (PvP) Logic (Secret Choices) ---
async function startRPSPvPGame(
    initiatorUserObj,
    joinerUserObjFull,
    betAmountInput,
    chatIdInput,
    originalOfferMessageIdToDelete,
    origin, // 'unified_offer' or 'direct_challenge'
    joinerBetAlreadyDeducted = false
) {
    const chatId = String(chatIdInput);
    const betAmount = BigInt(betAmountInput);
    const logPrefix = `[RPS_PvP_Start_V3_Origin UID1:${initiatorUserObj.id} UID2:${joinerUserObjFull.id} CH:${chatId} Origin:${origin}]`;
    
    let activeGameKeyForStorage;
    if (origin === 'unified_offer') {
        activeGameKeyForStorage = GAME_IDS.RPS_PVP_FROM_UNIFIED;
    } else { // 'direct_challenge'
        activeGameKeyForStorage = GAME_IDS.RPS_PVP;
    }

    if (originalOfferMessageIdToDelete && bot) {
        await bot.deleteMessage(chatId, Number(originalOfferMessageIdToDelete)).catch(() => {});
    }

    let client = null;
    const pvpGameId = generateGameId(GAME_IDS.RPS_PVP);
    const initiatorId = String(initiatorUserObj.id || initiatorUserObj.telegram_id);
    const initiatorMentionHTML = escapeHTML(getPlayerDisplayReference(initiatorUserObj));
    const joinerId = String(joinerUserObjFull.id || joinerUserObjFull.telegram_id);
    const joinerMentionHTML = escapeHTML(getPlayerDisplayReference(joinerUserObjFull));

    if (!joinerBetAlreadyDeducted) {
        console.log(`${logPrefix} Joiner's bet not pre-deducted for ${origin} origin. Processing for RPS PvP game ${pvpGameId}.`);
        try {
            client = await pool.connect(); await client.query('BEGIN');
            const joinBetRes = await updateUserBalanceAndLedger(client, joinerId, BigInt(-betAmount), 'bet_placed_rps_pvp_join', { game_id_custom_field: pvpGameId, opponent_id_custom_field: initiatorId }, `PvP RPS bet vs ${initiatorMentionHTML}`);
            if (!joinBetRes.success) throw new Error(`Joiner bet failed: ${joinBetRes.error}`);
            joinerUserObjFull.balance = joinBetRes.newBalanceLamports; 
            await client.query('COMMIT');
        } catch (error) {
            if (client) await client.query('ROLLBACK').catch(() => {});
            console.error(`${logPrefix} DB error placing joiner's PvP RPS bet: ${error.message}`);
            await safeSendMessage(chatId, `⚙️ Database error placing joiner's bet for PvP RPS. Game cancelled.`, { parse_mode: 'HTML' });
            return; 
        } finally {
            if (client) client.release();
        }
    } else {
        console.log(`${logPrefix} Joiner's bet assumed pre-deducted for RPS PvP game ${pvpGameId}.`);
    }

    const gameDataPvP = {
        type: GAME_IDS.RPS_PVP, gameId: pvpGameId, chatId, betAmount,
        p1: { userId: initiatorId, mentionHTML: initiatorMentionHTML, userObj: initiatorUserObj, choice: null, hasChosen: false },
        p2: { userId: joinerId, mentionHTML: joinerMentionHTML, userObj: joinerUserObjFull, choice: null, hasChosen: false },
        status: 'pvp_p1_choosing',
        gameMessageId: null, 
        currentMessageId: null, 
        lastInteractionTime: Date.now(),
        currentChoiceTimeoutId: null,
        _origin_key_for_limits: activeGameKeyForStorage
    };
    activeGames.set(pvpGameId, gameDataPvP);
    await updateGroupGameDetails(chatId, pvpGameId, activeGameKeyForStorage, betAmount);
    console.log(`${logPrefix} RPS PvP game ${pvpGameId} started. Group lock using key ${activeGameKeyForStorage} updated.`);

    await updateRPSPvPGameMessage(gameDataPvP);
}

async function updateRPSPvPGameMessage(gameData) {
    const logPrefix = `[RPS_PvP_UpdateMsg_V2 GID:${gameData.gameId}]`;
    if (gameData.currentMessageId && bot) {
        await bot.deleteMessage(gameData.chatId, Number(gameData.currentMessageId)).catch(() => {});
        gameData.currentMessageId = null;
    }

    if (gameData.currentChoiceTimeoutId) {
        clearTimeout(gameData.currentChoiceTimeoutId);
        gameData.currentChoiceTimeoutId = null;
    }

    const p1 = gameData.p1; const p2 = gameData.p2;
    const betDisplayHTML_Update = escapeHTML(await formatBalanceForDisplay(gameData.betAmount, 'USD'));
    let titleHTML = `🌌✨ <b>High Stakes RPS Duel: ${p1.mentionHTML} vs ${p2.mentionHTML}!</b> ✨🌌`;
    let textHTML = `${titleHTML}\nWager of Doom: <b>${betDisplayHTML_Update}</b> each!\n\n`;
    let keyboard = { inline_keyboard: [] }; 
    let activePlayerIdForTimeout = null;

    textHTML += `<b>${p1.mentionHTML} (P1):</b> ${p1.hasChosen ? "✅ Choice Locked!" : "🤔 Strategizing..."}\n`;
    textHTML += `<b>${p2.mentionHTML} (P2):</b> ${p2.hasChosen ? "✅ Choice Locked!" : (p1.hasChosen ? "🤔 Strategizing..." : "⏳ Waiting for P1...")}\n\n`;

    if (gameData.status === 'pvp_p1_choosing') {
        textHTML += `🔥 ${p1.mentionHTML}, the arena awaits your command! Click your SECRET choice below. (You have ${ACTIVE_GAME_TURN_TIMEOUT_MS / 1000} seconds)`;
        keyboard.inline_keyboard.push([
            { text: `${RPS_EMOJIS.rock} Rock`, callback_data: `rps_pvp_choice:${gameData.gameId}:${p1.userId}:${RPS_CHOICES.ROCK}` },
            { text: `${RPS_EMOJIS.paper} Paper`, callback_data: `rps_pvp_choice:${gameData.gameId}:${p1.userId}:${RPS_CHOICES.PAPER}` },
            { text: `${RPS_EMOJIS.scissors} Scissors`, callback_data: `rps_pvp_choice:${gameData.gameId}:${p1.userId}:${RPS_CHOICES.SCISSORS}` }
        ]);
        activePlayerIdForTimeout = p1.userId;
    } else if (gameData.status === 'pvp_p2_choosing') {
        textHTML += `⚡️ ${p1.mentionHTML} has committed! Now, ${p2.mentionHTML}, it's your turn to make your SECRET choice! (You have ${ACTIVE_GAME_TURN_TIMEOUT_MS / 1000} seconds)`;
        keyboard.inline_keyboard.push([
            { text: `${RPS_EMOJIS.rock} Rock`, callback_data: `rps_pvp_choice:${gameData.gameId}:${p2.userId}:${RPS_CHOICES.ROCK}` },
            { text: `${RPS_EMOJIS.paper} Paper`, callback_data: `rps_pvp_choice:${gameData.gameId}:${p2.userId}:${RPS_CHOICES.PAPER}` },
            { text: `${RPS_EMOJIS.scissors} Scissors`, callback_data: `rps_pvp_choice:${gameData.gameId}:${p2.userId}:${RPS_CHOICES.SCISSORS}` }
        ]);
        activePlayerIdForTimeout = p2.userId;
    } else if (gameData.status === 'pvp_reveal') {
        textHTML += `Decision time is over! Both warriors have made their move. The moment of truth arrives... Unveiling the clash! 💥`;
    }

    if (keyboard.inline_keyboard.length > 0 && (gameData.status === 'pvp_p1_choosing' || gameData.status === 'pvp_p2_choosing')) {
        keyboard.inline_keyboard.push([{ text: "📖 Rules", callback_data: `${RULES_CALLBACK_PREFIX_CONST}${GAME_IDS.RPS}` }]);
    }

    const sentMessage = await safeSendMessage(gameData.chatId, textHTML, { parse_mode: 'HTML', reply_markup: keyboard.inline_keyboard.length > 0 ? keyboard : {} });
    if (sentMessage?.message_id) {
        const currentGameData = activeGames.get(gameData.gameId);
        if (currentGameData) {
            currentGameData.currentMessageId = String(sentMessage.message_id);
            if (activePlayerIdForTimeout && (currentGameData.status === 'pvp_p1_choosing' || currentGameData.status === 'pvp_p2_choosing')) {
                currentGameData.currentChoiceTimeoutId = setTimeout(() => {
                    handleRPSPvPTurnTimeout(currentGameData.gameId, activePlayerIdForTimeout);
                }, ACTIVE_GAME_TURN_TIMEOUT_MS); 
                console.log(`${logPrefix} Turn timeout started for player ${activePlayerIdForTimeout} in RPS PvP game ${currentGameData.gameId}.`);
            }
            activeGames.set(currentGameData.gameId, currentGameData);
        }
    } else {
        console.error(`${logPrefix} Failed to send/update RPS PvP game message for ${gameData.gameId}. Attempting error finalization.`);
        const gameToEndOnError = activeGames.get(gameData.gameId);
        if (gameToEndOnError) {
            gameToEndOnError.status = 'game_over_error_ui_update';
            if (gameToEndOnError.currentChoiceTimeoutId) clearTimeout(gameToEndOnError.currentChoiceTimeoutId);
            activeGames.set(gameData.gameId, gameToEndOnError);
            await finalizeRPSPvPGame(gameToEndOnError); 
        }
    }
}

async function handleRPSPvPChoiceCallback(gameId, chooserId, choiceKey, userObj, originalMessageId, callbackQueryId) {
    const userIdMakingChoice = String(userObj.id || userObj.telegram_id);
    const logPrefix = `[RPS_PvPChoiceCB_V2 GID:${gameId} UID:${userIdMakingChoice} ChosenID:${chooserId} Choice:${choiceKey}]`;
    const gameData = activeGames.get(gameId);

    if (!gameData || gameData.type !== GAME_IDS.RPS_PVP) {
        await bot.answerCallbackQuery(callbackQueryId, { text: "This RPS PvP game is no longer active.", show_alert: true }).catch(() => {});
        return;
    }
    if (userIdMakingChoice !== chooserId) {
        await bot.answerCallbackQuery(callbackQueryId, { text: "This is not your turn or button.", show_alert: true }).catch(() => {});
        return;
    }

    let playerObj;
    let isP1Choosing = (gameData.status === 'pvp_p1_choosing' && gameData.p1.userId === chooserId && !gameData.p1.hasChosen);
    let isP2Choosing = (gameData.status === 'pvp_p2_choosing' && gameData.p2.userId === chooserId && !gameData.p2.hasChosen);

    if (isP1Choosing) playerObj = gameData.p1;
    else if (isP2Choosing) playerObj = gameData.p2;
    else {
        await bot.answerCallbackQuery(callbackQueryId, { text: "Not your turn or already chosen.", show_alert: false }).catch(() => {});
        return;
    }

    if (gameData.currentChoiceTimeoutId) {
        clearTimeout(gameData.currentChoiceTimeoutId);
        gameData.currentChoiceTimeoutId = null;
        console.log(`${logPrefix} Cleared turn timeout for game ${gameId}.`);
    }

    playerObj.choice = choiceKey;
    playerObj.hasChosen = true;
    const choiceDisplay = choiceKey.charAt(0).toUpperCase() + choiceKey.slice(1);
    await bot.answerCallbackQuery(callbackQueryId, { text: `Your choice ${RPS_EMOJIS[choiceKey]} ${choiceDisplay} is locked in secretly!` }).catch(() => {});
    gameData.lastInteractionTime = Date.now();

    if (isP1Choosing && gameData.p1.hasChosen && !gameData.p2.hasChosen) {
        gameData.status = 'pvp_p2_choosing';
        activeGames.set(gameData.gameId, gameData);
        await updateRPSPvPGameMessage(gameData);
    } else if (isP2Choosing && gameData.p1.hasChosen && gameData.p2.hasChosen) {
        gameData.status = 'pvp_reveal';
        activeGames.set(gameData.gameId, gameData);
        await updateRPSPvPGameMessage(gameData);
        await sleep(3000); 
        await finalizeRPSPvPGame(gameData);
    } else {
        console.warn(`${logPrefix} Unexpected state. P1 chosen: ${gameData.p1.hasChosen}, P2 chosen: ${gameData.p2.hasChosen}, Status: ${gameData.status}.`);
        activeGames.set(gameData.gameId, gameData);
        await updateRPSPvPGameMessage(gameData); // Refresh UI, new timeout will be set if applicable
    }
}

async function handleRPSPvPTurnTimeout(gameId, timedOutPlayerId) {
    const LOG_PREFIX_RPS_PVP_TIMEOUT = `[RPS_PvP_TurnTimeout_V2 GID:${gameId} TimedOutUID:${timedOutPlayerId}]`;
    const gameData = activeGames.get(gameId);

    if (!gameData || gameData.type !== GAME_IDS.RPS_PVP || gameData.status.startsWith('game_over_')) {
        if (gameData && gameData.currentChoiceTimeoutId) clearTimeout(gameData.currentChoiceTimeoutId);
        return;
    }

    const isP1TurnTimeout = (gameData.status === 'pvp_p1_choosing' && gameData.p1.userId === timedOutPlayerId);
    const isP2TurnTimeout = (gameData.status === 'pvp_p2_choosing' && gameData.p2.userId === timedOutPlayerId);

    if (!isP1TurnTimeout && !isP2TurnTimeout) {
        return; 
    }
    console.log(`${LOG_PREFIX_RPS_PVP_TIMEOUT} Player ${timedOutPlayerId} timed out choosing. Game ending by forfeit.`);

    if (gameData.currentChoiceTimeoutId) clearTimeout(gameData.currentChoiceTimeoutId);
    gameData.currentChoiceTimeoutId = null;

    if (gameData.p1.userId === timedOutPlayerId) {
        gameData.status = 'game_over_p1_timeout_forfeit';
    } else {
        gameData.status = 'game_over_p2_timeout_forfeit';
    }
    activeGames.set(gameId, gameData);
    await finalizeRPSPvPGame(gameData);
}

// CORRECTED finalizeRPSPvPGame (with Deadlock and Referral Fixes)
async function finalizeRPSPvPGame(gameData) {
    const { gameId, chatId, betAmount, p1, p2, status: finalStatus, _origin_key_for_limits } = gameData;
    const logPrefix = `[RPS_PvP_Finalize_V7_FullFix GID:${gameId}]`;
    const activeGameKeyToClear = _origin_key_for_limits || GAME_IDS.RPS_PVP;
    let allNotificationsToSend = [];

    let solPrice;
    try {
        solPrice = await getSolUsdPrice();
    } catch (priceError) {
        console.error(`${logPrefix} CRITICAL: Could not get SOL price. Level-up/milestone checks will be skipped. Error: ${priceError.message}`);
        solPrice = 0;
    }

    activeGames.delete(gameId);
    await updateGroupGameDetails(chatId, { removeThisId: gameId }, activeGameKeyToClear, null);
    console.log(`${logPrefix} Cleared active game lock for chat ${chatId} using key ${activeGameKeyToClear}.`);

    if (!p1 || typeof p1.mentionHTML === 'undefined' || typeof p1.userId === 'undefined' || !p2 || typeof p2.mentionHTML === 'undefined' || typeof p2.userId === 'undefined') {
        console.error(`${logPrefix} CRITICAL: p1 or p2 object or their essential properties missing.`);
        await safeSendMessage(chatId, "⚙️ Critical error resolving RPS PvP. Admin notified.", {parse_mode: "HTML"});
        return;
    }

    const p1MentionHTML = p1.mentionHTML;
    const p2MentionHTML = p2.mentionHTML;
    let p1Payout = 0n; let p2Payout = 0n;
    let p1LedgerCode = `loss_rps_pvp`; let p2LedgerCode = `loss_rps_pvp`;
    let financialOutcomeTextPvP = "";
    let rpsOutcome = null;
    let resultDescriptionForMessage = "";
    let gameOutcomeTextForLog = "";
    const totalPotDisplay = escapeHTML(await formatBalanceForDisplay(betAmount * 2n, 'USD'));
    const singleBetDisplay = escapeHTML(await formatBalanceForDisplay(betAmount, 'USD'));
    let titleResultHTML = `💥✨ <b>RPS PvP - The Reckoning!</b> ✨💥`;
    let isConclusiveOutcome = false;

    if (finalStatus === 'game_over_p1_timeout_forfeit') {
        isConclusiveOutcome = true;
        titleResultHTML = `⏳🏆 <b>${p2MentionHTML} Wins by Forfeit!</b> 🏆⏳`;
        resultDescriptionForMessage = `${p1MentionHTML} timed out making a choice.`;
        financialOutcomeTextPvP = `${p2MentionHTML} wins the pot of <b>${totalPotDisplay}</b>!`;
        p2Payout = betAmount * 2n; p2LedgerCode = 'win_rps_pvp_opponent_forfeit'; p1LedgerCode = 'loss_rps_pvp_self_forfeit';
        gameOutcomeTextForLog = `P2 wins by P1 forfeit (timeout)`;
    } else if (finalStatus === 'game_over_p2_timeout_forfeit') {
        isConclusiveOutcome = true;
        titleResultHTML = `⏳🏆 <b>${p1MentionHTML} Wins by Forfeit!</b> 🏆⏳`;
        resultDescriptionForMessage = `${p2MentionHTML} timed out making a choice.`;
        financialOutcomeTextPvP = `${p1MentionHTML} wins the pot of <b>${totalPotDisplay}</b>!`;
        p1Payout = betAmount * 2n; p1LedgerCode = 'win_rps_pvp_opponent_forfeit'; p2LedgerCode = 'loss_rps_pvp_self_forfeit';
        gameOutcomeTextForLog = `P1 wins by P2 forfeit (timeout)`;
    } else if (finalStatus === 'game_over_error_timeout_logic' || finalStatus === 'game_over_error_ui_update' || !p1.choice || !p2.choice) {
        isConclusiveOutcome = false;
        titleResultHTML = `⚙️ <b>RPS PvP - Game Concluded Inconclusively</b> ⚙️`;
        resultDescriptionForMessage = `The game concluded due to an unexpected error or missing choices.`;
        financialOutcomeTextPvP = `Bets of <b>${singleBetDisplay}</b> each are refunded for fairness.`;
        p1Payout = betAmount; p2Payout = betAmount;
        p1LedgerCode = 'refund_rps_pvp_error'; p2LedgerCode = 'refund_rps_pvp_error';
        gameOutcomeTextForLog = `Error - bets refunded (P1: ${p1.choice || 'N/A'}, P2: ${p2.choice || 'N/A'})`;
    } else {
        rpsOutcome = determineRPSOutcome(p1.choice, p2.choice, p1MentionHTML, p2MentionHTML);
        resultDescriptionForMessage = `<i>${rpsOutcome.description}</i>`;
        if (rpsOutcome.result === 'win_player1') {
            isConclusiveOutcome = true;
            p1Payout = betAmount * 2n; financialOutcomeTextPvP = `${p1MentionHTML} wins the pot of <b>${totalPotDisplay}</b>!`;
            p1LedgerCode = `win_rps_pvp_${p1.choice}_vs_${p2.choice}`; p2LedgerCode = `loss_rps_pvp_${p2.choice}_vs_${p1.choice}`;
            gameOutcomeTextForLog = `P1 wins (${p1.choice} vs ${p2.choice})`;
        } else if (rpsOutcome.result === 'win_player2') {
            isConclusiveOutcome = true;
            p2Payout = betAmount * 2n; financialOutcomeTextPvP = `${p2MentionHTML} wins the pot of <b>${totalPotDisplay}</b>!`;
            p2LedgerCode = `win_rps_pvp_${p2.choice}_vs_${p1.choice}`; p1LedgerCode = `loss_rps_pvp_${p1.choice}_vs_${p2.choice}`;
            gameOutcomeTextForLog = `P2 wins (${p2.choice} vs ${p1.choice})`;
        } else if (rpsOutcome.result === 'draw') {
            isConclusiveOutcome = false; // A push does not trigger wager bonuses
            p1Payout = betAmount; p2Payout = betAmount; financialOutcomeTextPvP = `It's a draw! Bets of <b>${singleBetDisplay}</b> each are returned.`;
            p1LedgerCode = `draw_rps_pvp_${p1.choice}_vs_${p2.choice}`; p2LedgerCode = `draw_rps_pvp_${p2.choice}_vs_${p1.choice}`;
            gameOutcomeTextForLog = `Draw (${p1.choice} vs ${p2.choice})`;
        } else { // Error from determineRPSOutcome
            isConclusiveOutcome = false;
            p1Payout = betAmount; p2Payout = betAmount; financialOutcomeTextPvP = `Bets refunded due to unclear outcome.`;
            p1LedgerCode = 'refund_rps_pvp_internal_error'; p2LedgerCode = 'refund_rps_pvp_internal_error';
            gameOutcomeTextForLog = `Internal game error - bets refunded (P1: ${p1.choice}, P2: ${p2.choice})`;
        }
    }
    
    let client = null; let dbErrorOccurred = false;
    try {
        client = await pool.connect(); await client.query('BEGIN');
        const actualGameLogId = await logGameResultToGamesTable(
            client, activeGameKeyToClear, chatId, p1.userId, [p1.userId, p2.userId], betAmount, gameOutcomeTextForLog, 0n
        );

        // --- DEADLOCK PREVENTION: Sort players by ID before locking/updating ---
        const [playerA, playerB] = [p1, p2].sort((a, b) => String(a.userId).localeCompare(String(b.userId)));
        console.log(`${logPrefix} Locking order established. Player A: ${playerA.userId}, Player B: ${playerB.userId}`);

        const payoutA = (playerA.userId === p1.userId) ? p1Payout : p2Payout;
        const payoutB = (playerB.userId === p1.userId) ? p1Payout : p2Payout;
        const ledgerCodeA = (playerA.userId === p1.userId) ? p1LedgerCode : p2LedgerCode;
        const ledgerCodeB = (playerB.userId === p1.userId) ? p1LedgerCode : p2LedgerCode;
        
        // Process Player A first
        const pA_Update = await updateUserBalanceAndLedger(client, playerA.userId, payoutA, ledgerCodeA, { game_log_id: actualGameLogId, opponent_id_custom_field: playerB.userId }, `PvP RPS vs ${playerB.displayName || playerB.userId}. Choice: ${playerA.choice || 'N/A (Timeout)'}`, solPrice);
        if (!pA_Update.success) { dbErrorOccurred = true; console.error(`${logPrefix} Player A (${playerA.userId}) update failed: ${pA_Update.error}`); }
        if (pA_Update.notifications) allNotificationsToSend.push(...pA_Update.notifications);
        
        // Process Player B second
        const pB_Update = await updateUserBalanceAndLedger(client, playerB.userId, payoutB, ledgerCodeB, { game_log_id: actualGameLogId, opponent_id_custom_field: playerA.userId }, `PvP RPS vs ${playerA.displayName || playerA.userId}. Choice: ${playerB.choice || 'N/A (Timeout)'}`, solPrice);
        if (!pB_Update.success) { dbErrorOccurred = true; console.error(`${logPrefix} Player B (${playerB.userId}) update failed: ${pB_Update.error}`); }
        if (pB_Update.notifications) allNotificationsToSend.push(...pB_Update.notifications);
        
        // Map results back to original p1 and p2 for subsequent logic
        const p1Update = (p1.userId === playerA.userId) ? pA_Update : pB_Update;
        const p2Update = (p2.userId === playerA.userId) ? pA_Update : pB_Update;
        
        if (dbErrorOccurred) throw new Error("One or more balance updates failed during RPS PvP finalization.");

        if (isConclusiveOutcome) {
            // --- START OF MODIFICATION ---

            // 1. ADDED: Check initial bet bonus for both players.
            if (typeof processQualifyingBetAndInitialBonus === 'function') {
                await processQualifyingBetAndInitialBonus(client, p1.userId, betAmount, gameId);
                await processQualifyingBetAndInitialBonus(client, p2.userId, betAmount, gameId);
            }

            // 2. MODIFIED: Correctly call level and milestone checks for both players.
            if (p1Update.success && p1Update.newTotalWageredLamports !== undefined) {
                const p1LevelNotifications = await checkAndUpdateUserLevel(client, p1.userId, p1Update.newTotalWageredLamports, solPrice, chatId);
                allNotificationsToSend.push(...p1LevelNotifications);
                const p1MilestoneResult = await processWagerMilestoneBonus(client, p1.userId, p1Update.newTotalWageredLamports, solPrice);
                if (!p1MilestoneResult.success) console.warn(`${logPrefix} Failed to process milestone bonus for P1: ${p1MilestoneResult.error}`);
            }
            if (p2Update.success && p2Update.newTotalWageredLamports !== undefined) {
                const p2LevelNotifications = await checkAndUpdateUserLevel(client, p2.userId, p2Update.newTotalWageredLamports, solPrice, chatId);
                allNotificationsToSend.push(...p2LevelNotifications);
                const p2MilestoneResult = await processWagerMilestoneBonus(client, p2.userId, p2Update.newTotalWageredLamports, solPrice);
                if (!p2MilestoneResult.success) console.warn(`${logPrefix} Failed to process milestone bonus for P2: ${p2MilestoneResult.error}`);
            }

            // --- END OF MODIFICATION ---
        }
        
        await client.query('COMMIT');
    } catch (e) {
        if (client) await client.query('ROLLBACK').catch(() => {});
        console.error(`${logPrefix} CRITICAL DB error: ${e.message}`);
        resultDescriptionForMessage = (rpsOutcome && rpsOutcome.result === 'error' && rpsOutcome.description) ? rpsOutcome.description : resultDescriptionForMessage;
        resultDescriptionForMessage += `<br><br>⚠️ Critical error settling wagers. Admin notified.`;
        financialOutcomeTextPvP = `⚠️ Admin has been notified. Please await manual review.`;
        if (typeof notifyAdmin === 'function') notifyAdmin(`🚨 CRITICAL RPS PvP Payout Failure 🚨\nGame ID: <code>${escapeHTML(gameId)}</code>\nError: ${escapeHTML(e.message)}. Manual check required.`, { parse_mode: 'HTML' });
    } finally { 
        if (client) client.release(); 
    }

    // Send all collected notifications AFTER the transaction is closed
    for (const notification of allNotificationsToSend) {
        if (notification.to === ADMIN_USER_ID && typeof notifyAdmin === 'function') {
            await notifyAdmin(notification.text, notification.options).catch(err => console.error(`Failed to send admin notification: ${err.message}`));
        } else {
            await safeSendMessage(notification.to, notification.text, notification.options).catch(err => console.error(`Failed to send game-related notification to ${notification.to}: ${err.message}`));
        }
    }

    const resultMessageHTML = `${titleResultHTML}\n\n` +
        `The dust settles between ${p1MentionHTML} and ${p2MentionHTML} (Wager: <b>${singleBetDisplay}</b> each)!\n\n` +
        `<b>${p1MentionHTML} (P1) secretly chose:</b> ${p1.choice ? RPS_EMOJIS[p1.choice] : '❓'} <b>${p1.choice ? escapeHTML(rpsOutcome?.player1?.choiceFormatted || p1.choice) : 'N/A'}</b>\n` +
        `<b>${p2MentionHTML} (P2) secretly chose:</b> ${p2.choice ? RPS_EMOJIS[p2.choice] : '❓'} <b>${p2.choice ? escapeHTML(rpsOutcome?.player2?.choiceFormatted || p2.choice) : 'N/A'}</b>\n\n` +
        `${resultDescriptionForMessage}\n\n${financialOutcomeTextPvP}`;

    const postGameKeyboard = createPostGameKeyboard(GAME_IDS.RPS_PVP, betAmount);
    if (gameData.currentMessageId && bot) {
        await bot.editMessageText(resultMessageHTML, { chat_id: chatId, message_id: Number(gameData.currentMessageId), parse_mode: 'HTML', reply_markup: postGameKeyboard }).catch(async (e) => {
            if (!e.message?.includes("message is not modified")) await safeSendMessage(chatId, resultMessageHTML, { parse_mode: 'HTML', reply_markup: postGameKeyboard });
        });
    } else {
        await safeSendMessage(chatId, resultMessageHTML, { parse_mode: 'HTML', reply_markup: postGameKeyboard });
    }
}

// --- End of REVISED Part 5a, Section 3 ---
// --- Start of Part 5b, Section 1 (COMPLETE DICE ESCALATOR LOGIC - HTML Revamp V4 - PvP State Alignment - GRANULAR ACTIVE GAME LIMITS - FULL CODE - CORRECTED) ---
// index.js - Part 5b, Section 1: Dice Escalator Game Logic & Handlers
//----------------------------------------------------------------------------------------------

// Assumed dependencies from previous Parts are available

// --- Constants specific to New Dice Escalator ---
const DE_PVB_BOT_ROLL_COUNT = 3;
const BUST_MESSAGE_DELAY_MS = 1500;

// --- Helper Function for DE Game Message Formatting (RETURNS // --- START OF FULL REPLACEMENT for formatDiceEscalatorGameMessage_New function ---
async function formatDiceEscalatorGameMessage_New(gameData) {
    let messageTextHTML = "";
    let jackpotDisplayHTML = "";
    const LOG_PREFIX_FORMAT_DE_HTML_V4 = `[FormatDE_Msg_HTML_V4 GID:${gameData.gameId}]`;

    if (gameData.type === GAME_IDS.DICE_ESCALATOR_PVB) {
        try {
            const jackpotResult = await queryDatabase('SELECT current_amount FROM jackpots WHERE jackpot_id = $1', [MAIN_JACKPOT_ID]);
            if (jackpotResult.rows.length > 0 && jackpotResult.rows[0].current_amount) {
                const jackpotAmountLamports = BigInt(jackpotResult.rows[0].current_amount);
                if (jackpotAmountLamports > 0n) {
                    const jackpotUSD_HTML = escapeHTML(await formatBalanceForDisplay(jackpotAmountLamports, 'USD'));
                    const jackpotSOL_HTML = escapeHTML(formatCurrency(jackpotAmountLamports, 'SOL'));
                    // MODIFIED: Removed _CONST from TARGET_JACKPOT_SCORE
                    jackpotDisplayHTML = `\n\n<pre>🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇\n` +
                                         `   💎   SUPER JACKPOT ALERT!   💎\n` +
                                         `🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇🎇</pre>\n` +
                                         `Current Prize: 🔥<b>${jackpotUSD_HTML}</b>🔥\n` +
                                         `(<i>Approx. ${jackpotSOL_HTML}</i>)\n` +
                                         `Score <b>${escapeHTML(String(TARGET_JACKPOT_SCORE))}+</b> & beat the Bot to WIN IT ALL!\n`;
                } else {
                     jackpotDisplayHTML = `\n\n💎 The Super Jackpot is currently <b>${escapeHTML(await formatBalanceForDisplay(0n, 'USD'))}</b>. Be the first to build it up!\n`;
                }
            }
        } catch (error) {
            console.error(`${LOG_PREFIX_FORMAT_DE_HTML_V4} Error fetching jackpot for display: ${error.message}`);
            jackpotDisplayHTML = "\n\n⚠️ <i>Jackpot status temporarily unavailable.</i>\n";
        }
    }

    const betDisplaySOL_HTML = escapeHTML(formatCurrency(gameData.betAmount, 'SOL'));
    const betUsdDisplay_HTML = escapeHTML(await formatBalanceForDisplay(gameData.betAmount, 'USD'));
    let playerRefHTML = "Player";
    if (gameData.type === GAME_IDS.DICE_ESCALATOR_PVB && gameData.player && gameData.player.displayName) {
        playerRefHTML = escapeHTML(gameData.player.displayName);
    } else if (gameData.initiator && gameData.initiator.displayName) {
        playerRefHTML = escapeHTML(gameData.initiator.displayName);
    }

    if (gameData.type === GAME_IDS.DICE_ESCALATOR_PVB) {
        const player = gameData.player;
        messageTextHTML = `🎲 💎 <b>Dice Escalator vs. Bot Dealer</b> 💎 🎲\n\n` +
                          `<b>Player</b>: ${playerRefHTML}\n` +
                          `<b>Wager</b>: <b>${betUsdDisplay_HTML}</b> (<i>${betDisplaySOL_HTML}</i>)\n` +
                          `${jackpotDisplayHTML}\n`+
                          `Your Score: <b>${escapeHTML(String(player.score))}</b>\n`;
        if (player.rolls && player.rolls.length > 0) {
            messageTextHTML += `Your Rolls: ${formatDiceRolls(player.rolls)}\n`;
        }

        if (gameData.status === 'player_score_18_plus_awaiting_choice') {
            // MODIFIED: Removed _CONST from TARGET_JACKPOT_SCORE
            messageTextHTML += `\n\n⚠️ <b>DECISION TIME!</b> Score: <b>${escapeHTML(String(player.score))}</b> ⚠️\n` +
                               `You can:\n` +
                               `1. ✋ <b>Stand Firm:</b> Lock in your score.\n` +
                               `2. 🔥 <b>Go for Jackpot!:</b> Roll for <b>${escapeHTML(String(TARGET_JACKPOT_SCORE))}+</b>! (<i>No standing after this choice!</i>)\n\n` +
                               `What's your strategy, <b>${playerRefHTML}</b>? (Turn timeout: ${ACTIVE_GAME_TURN_TIMEOUT_MS / 1000}s)`;
        } else if (gameData.status === 'player_turn_awaiting_emoji') {
            if (player.isGoingForJackpot) {
                // MODIFIED: Removed _CONST from TARGET_JACKPOT_SCORE
                messageTextHTML += `\n\n🔥🔥 <b>JACKPOT RUN!</b> 🔥🔥\nScore: <b>${escapeHTML(String(player.score))}</b> (Target: ${escapeHTML(String(TARGET_JACKPOT_SCORE))}+)\n` +
                                   `<i>No turning back! Send 🎲 to roll again! (Turn timeout: ${ACTIVE_GAME_TURN_TIMEOUT_MS / 1000}s)</i>`;
            } else {
                messageTextHTML += `\n👉 <b>${playerRefHTML}</b>, it's your turn! Send a 🎲 emoji to roll.\n` +
                                   `<i>Or press "Stand Firm" below. (Turn timeout: ${ACTIVE_GAME_TURN_TIMEOUT_MS / 1000}s)</i>`;
            }
        } else if (gameData.status === 'player_stood') {
            messageTextHTML += `\n✅ You stood with <b>${escapeHTML(String(player.score))}</b> points!\n`+
                               `<i>🤖 The Bot Dealer is now making its move...</i>`;
        } else if (gameData.status === 'bot_turn_complete') {
            messageTextHTML += `\n🤖 Bot Dealer's Rolls: ${formatDiceRolls(gameData.botRolls || [])}\n` +
                               `Bot's Final Score: <b>${escapeHTML(String(gameData.botScore || 0))}</b>\n\n` +
                               `<i>⏳ Calculating results...</i>`;
        } else if (gameData.status === 'player_busted') {
            messageTextHTML += `\n💥 <b>Oh no, a BUST!</b> You rolled a <code>${escapeHTML(String(gameData.lastPlayerRoll))}</code> (bust on <code>${escapeHTML(String(DICE_ESCALATOR_BUST_ON))}</code>).\n<i>Bot Dealer wins this round.</i>`;
        }
    } else if (gameData.type === GAME_IDS.DICE_ESCALATOR_PVP) {
        // ... (PvP message formatting, no changes needed here for TARGET_JACKPOT_SCORE) ...
        const p1 = gameData.initiator;
        const p2 = gameData.opponent;
        const p1MentionHTML = escapeHTML(p1.displayName);
        const p2MentionHTML = escapeHTML(p2.displayName);
        const totalPotUsdDisplay_HTML = escapeHTML(await formatBalanceForDisplay(gameData.betAmount * 2n, 'USD'));

        messageTextHTML = `⚔️ <b>Dice Escalator PvP Challenge!</b> ⚔️\n` +
                          `<i>${p1MentionHTML} vs ${p2MentionHTML}</i>\n\n` +
                          `<b>Wager</b>: ${betUsdDisplay_HTML} each\n`+
                          `<b>Total Pot</b>: <b>${totalPotUsdDisplay_HTML}</b>\n\n` +
                          `--- <b>Current Scores</b> ---\n`;
        messageTextHTML += `👤 <b>${p1MentionHTML}</b> (P1): ${formatDiceRolls(p1.rolls)} Score: <b>${escapeHTML(String(p1.score))}</b> ${p1.busted ? "💥 BUSTED!" : (p1.stood ? "✅ Stood" : (p1.status === 'awaiting_roll_emoji' ? "🎲 Rolling..." : ""))}\n`;
        messageTextHTML += `👤 <b>${p2MentionHTML}</b> (P2): ${formatDiceRolls(p2.rolls)} Score: <b>${escapeHTML(String(p2.score))}</b> ${p2.busted ? "💥 BUSTED!" : (p2.stood ? "✅ Stood" : (p2.status === 'awaiting_roll_emoji' ? "🎲 Rolling..." : (p2.status === 'waiting_turn' ? "<i>Waiting...</i>" : "")) )}\n\n`;

        let actionPromptHTML = "<i>Waiting for player action...</i>";

        if (p1.isTurn && p1.status === 'awaiting_roll_emoji') {
            actionPromptHTML = `👉 <b>${p1MentionHTML}</b> (P1), it's your turn! Send 🎲 to roll, or use "Stand" below. (Turn timeout: ${ACTIVE_GAME_TURN_TIMEOUT_MS / 1000}s)`;
        } else if (p2.isTurn && p2.status === 'awaiting_roll_emoji') {
            actionPromptHTML = `👉 <b>${p2MentionHTML}</b> (P2), ${p1MentionHTML} (P1) ${p1.stood ? `stands at <b>${p1.score}</b>` : `busted`}. Your turn! Send 🎲 or "Stand". (Turn timeout: ${ACTIVE_GAME_TURN_TIMEOUT_MS / 1000}s)`;
        } else if (gameData.status === 'p1_stood' && p2.status === 'waiting_turn') {
            actionPromptHTML = `✅ <b>${p1MentionHTML}</b> (P1) stands with <b>${escapeHTML(String(p1.score))}</b>!\n<b>${p2MentionHTML}</b> (P2), your turn to conquer! Send 🎲 to roll or "Stand"! (Turn timeout: ${ACTIVE_GAME_TURN_TIMEOUT_MS / 1000}s)`;
        } else if (gameData.status.startsWith('game_over')) {
            actionPromptHTML = "<i>🏁 Game Over! Calculating final results...</i> ⏳";
        }
        messageTextHTML += actionPromptHTML;
    }
    return messageTextHTML.trim();
}
// --- END OF FULL REPLACEMENT for formatDiceEscalatorGameMessage_New function ---

// (getThreeDiceRollsViaHelper_DE_New remains unchanged by this specific refactoring task)
async function getThreeDiceRollsViaHelper_DE_New(gameIdForLog, chatIdForLogContext) {
    const LOG_PREFIX_HELPER = `[DE_HelperBotRolls Game:${gameIdForLog}]`;
    const rolls = [];
    let overallHelperError = null;
    for (let i = 0; i < DE_PVB_BOT_ROLL_COUNT; i++) {
        if (isShuttingDown) { overallHelperError = "Shutdown during DE PvB bot roll requests."; break; }
        let client = null;
        let requestId = null;
        let currentSingleRollError = null;
        try {
            client = await pool.connect();
            const insertResult = await client.query(
                'INSERT INTO dice_roll_requests (game_id, chat_id, user_id, status, emoji_type, notes) VALUES ($1, $2, $3, $4, $5, $6) RETURNING request_id',
                [gameIdForLog, String(chatIdForLogContext), null, 'pending', '🎲', `DE PvB Bot Roll ${i+1}`]
            );
            if (!insertResult.rows[0] || !insertResult.rows[0].request_id) {
                throw new Error("Failed to insert roll request or retrieve request_id for bot.");
            }
            requestId = insertResult.rows[0].request_id;
            client.release(); client = null;
            let attempts = 0;
            let rollValue = null;
            let rollStatus = 'pending';
            let rollNotes = null;
            while (attempts < DICE_ROLL_POLLING_MAX_ATTEMPTS && rollStatus === 'pending') {
                await sleep(DICE_ROLL_POLLING_INTERVAL_MS);
                if (isShuttingDown) { currentSingleRollError = "Shutdown during DE PvB bot roll poll."; break; }
                client = await pool.connect();
                const res = await client.query('SELECT roll_value, status, notes FROM dice_roll_requests WHERE request_id = $1', [requestId]);
                client.release(); client = null;
                if (res.rows.length > 0) {
                    rollValue = res.rows[0].roll_value;
                    rollStatus = res.rows[0].status;
                    rollNotes = res.rows[0].notes;
                    if (rollStatus === 'completed' && rollValue !== null && rollValue >= 1 && rollValue <= 6) {
                        rolls.push(rollValue);
                        break;
                    } else if (rollStatus === 'error') {
                        currentSingleRollError = rollNotes || `Helper Bot reported error for DE PvB Bot roll ${i+1} (Req ID: ${requestId}).`;
                        break;
                    }
                }
                attempts++;
            }
            if (currentSingleRollError) { throw new Error(currentSingleRollError); }
            if (rollStatus !== 'completed' || rollValue === null) {
                currentSingleRollError = `Timeout polling for DE PvB Bot roll ${i+1} (Req ID: ${requestId}). Max attempts reached.`;
                client = await pool.connect();
                await client.query("UPDATE dice_roll_requests SET status='timeout', notes=$1 WHERE request_id=$2 AND status='pending'", [String(currentSingleRollError).substring(0,250), requestId]).catch(()=>{});
                client.release(); client = null;
                throw new Error(currentSingleRollError);
            }
        } catch (dbOrPollError) {
            if (client) client.release();
            console.error(`${LOG_PREFIX_HELPER} Error during bot roll ${i+1} (Req ID: ${requestId || 'N/A'}): ${dbOrPollError.message}. Using fallback.`);
            rolls.push(Math.floor(Math.random() * 6) + 1); 
            if (!overallHelperError) overallHelperError = dbOrPollError.message;
        }
    }
    if (overallHelperError) { console.warn(`${LOG_PREFIX_HELPER} One or more bot rolls encountered errors. Final rolls (may include fallbacks): ${rolls.join(', ')}. First error: ${overallHelperError}`); }
    return rolls;
}

// --- START OF FULL REPLACEMENT for handleStartDiceEscalatorUnifiedOfferCommand_New function ---
async function handleStartDiceEscalatorUnifiedOfferCommand_New(msg, betAmountLamports, targetUsernameRaw = null) {
    const userId = String(msg.from.id || msg.from.telegram_id);
    const chatId = String(msg.chat.id);
    const chatType = msg.chat.type;
    const logPrefix = `[DE_OfferOrDirect_V7_GranLimit UID:${userId} CH:${chatId}]`;

    // MODIFIED CALL to checkUserActiveGameLimit and NEW ERROR MESSAGE
    const isDirectChallengeOfferAttempt = (targetUsernameRaw != null);
    // Ensure the third parameter 'null' (for gameIdBeingActioned) is passed
    const activeUserGameCheck = await checkUserActiveGameLimit(userId, isDirectChallengeOfferAttempt, null);
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = escapeHTML(getPlayerDisplayReference(msg.from));
        const blockingGameType = activeUserGameCheck.details.type;
        // Use getCleanGameName for consistent and user-friendly game type display
        const cleanGameName = getCleanGameName(blockingGameType);
        const alertMessage = `✨ ${userDisplayName}, you already have a pending offer or active game for <b>${escapeHTML(cleanGameName)}</b>. ✨`;
        await safeSendMessage(chatId, alertMessage, { parse_mode: 'HTML' });
        return;
    }
    // END OF MODIFICATION

    if (chatType === 'private') {
        await safeSendMessage(chatId, `🎲 The Dice Escalator arena is in <b>group chats</b>! Use <code>/de &lt;bet&gt; [@username]</code> there.`, { parse_mode: 'HTML' });
        return;
    }

    let initiatorUserObj = await getOrCreateUser(userId, msg.from.username, msg.from.first_name, msg.from.last_name);
    if (!initiatorUserObj) {
        await safeSendMessage(chatId, "⚠️ Error fetching your player profile. Please try <code>/start</code> with me first.", { parse_mode: 'HTML' });
        return;
    }
    const initiatorPlayerRefHTML = escapeHTML(getPlayerDisplayReference(initiatorUserObj));
    const betDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(betAmountLamports, 'USD'));

    if (BigInt(initiatorUserObj.balance) < betAmountLamports) {
        const needed = betAmountLamports - BigInt(initiatorUserObj.balance);
        await safeSendMessage(chatId, `💰 ${initiatorPlayerRefHTML}, your balance is too low for a <b>${betDisplayUSD_HTML}</b> Dice Escalator game! You need approx. <b>${escapeHTML(await formatBalanceForDisplay(needed, 'USD'))}</b> more.`, {
            parse_mode: 'HTML',
            reply_markup: { inline_keyboard: [[{ text: "💸 Add Funds (DM)", callback_data: QUICK_DEPOSIT_CALLBACK_ACTION_CONST }]] }
        });
        return;
    }

    let targetUserObjectForChallenge = null;
    let isDirectChallenge = (targetUsernameRaw != null); // This was already correct

    if (isDirectChallenge) {
        targetUserObjectForChallenge = await findRecipientUser(targetUsernameRaw);
        if (!targetUserObjectForChallenge || !targetUserObjectForChallenge.telegram_id) {
            await safeSendMessage(chatId, `😕 Player ${escapeHTML(targetUsernameRaw)} not found. To make a general Dice Escalator offer, use <code>/de ${escapeHTML(String(betAmountLamports/LAMPORTS_PER_SOL))}</code>.`, { parse_mode: 'HTML' });
            return;
        } else if (String(targetUserObjectForChallenge.telegram_id) === userId) {
            await safeSendMessage(chatId, `😅 You can't directly challenge yourself, ${initiatorPlayerRefHTML}! To make a general offer, use <code>/de ${escapeHTML(String(betAmountLamports/LAMPORTS_PER_SOL))}</code>.`, { parse_mode: 'HTML' });
            return;
        }
    }

    const gameSession = await getGroupSession(chatId, msg.chat.title || `Group Chat ${chatId}`);
    let offerActivityKeyForLock;
    let limit;

    if (isDirectChallenge) {
        offerActivityKeyForLock = GAME_IDS.DICE_ESCALATOR_DIRECT_CHALLENGE_OFFER;
        const currentDirectChallenges = gameSession.activeGamesByTypeInGroup.get(offerActivityKeyForLock) || [];
        limit = GAME_ACTIVITY_LIMITS.DIRECT_CHALLENGES[offerActivityKeyForLock] || 1;
        if (currentDirectChallenges.length >= limit) {
            await safeSendMessage(chatId, `⏳ Hold your dice, ${initiatorPlayerRefHTML}! The limit of ${limit} concurrent direct Dice Escalator challenge(s) in this group has been reached. Please wait.`, { parse_mode: 'HTML' });
            return;
        }
    } else { // Unified Offer Path
        offerActivityKeyForLock = GAME_IDS.DICE_ESCALATOR_UNIFIED_OFFER;
        const currentUnifiedOffers = gameSession.activeGamesByTypeInGroup.get(offerActivityKeyForLock) || [];
        limit = GAME_ACTIVITY_LIMITS.UNIFIED_OFFERS[GAME_IDS.DICE_ESCALATOR_UNIFIED_OFFER] || GAME_ACTIVITY_LIMITS.UNIFIED_OFFERS[GAME_IDS.DICE_ESCALATOR] || 1;
        if (currentUnifiedOffers.length >= limit) {
            await safeSendMessage(chatId, `⏳ Slow down, ${initiatorPlayerRefHTML}! The limit of ${limit} concurrent Dice Escalator offer(s) in this group has been reached. Please wait.`, { parse_mode: 'HTML' });
            return;
        }
    }

    let offerId;
    let offerData;
    let clientBetPlacement = null;
    let timeoutDuration;

    try {
        clientBetPlacement = await pool.connect();
        await clientBetPlacement.query('BEGIN');

        if (isDirectChallenge) {
            offerId = generateGameId(`dde_${userId.slice(-3)}_${String(targetUserObjectForChallenge.telegram_id).slice(-3)}`);
            timeoutDuration = DIRECT_CHALLENGE_ACCEPT_TIMEOUT_MS;

            const betResultDirect = await updateUserBalanceAndLedger(clientBetPlacement, userId, BigInt(-betAmountLamports), 'bet_placed_de_direct_challenge_offer', { custom_offer_id: offerId, opponent_id_custom_field: targetUserObjectForChallenge.telegram_id }, `Direct Dice Escalator Challenge Offer to ${targetUserObjectForChallenge.username || targetUserObjectForChallenge.telegram_id}`);
            if (!betResultDirect.success) throw new Error(betResultDirect.error || "Failed to place your bet for the direct challenge.");
            initiatorUserObj.balance = betResultDirect.newBalanceLamports;

            const targetPlayerRefHTML = escapeHTML(getPlayerDisplayReference(targetUserObjectForChallenge));
            const groupChallengeTextHTML = `Hey ${targetPlayerRefHTML}❗\n\n${initiatorPlayerRefHTML} has challenged you to a <b>Dice Escalator</b> duel for <b>${betDisplayUSD_HTML}</b>! You have ${timeoutDuration / 1000} seconds to respond.`;
            const groupChallengeKeyboard = {
                inline_keyboard: [
                    [{ text: "✅ Accept Challenge", callback_data: `de_direct_accept:${offerId}` }],
                    [{ text: "❌ Decline Challenge", callback_data: `de_direct_decline:${offerId}` }],
                    [{ text: "🚫 Withdraw My Challenge", callback_data: `de_direct_cancel:${offerId}` }]
                ]
            };
            const sentGroupMessage = await safeSendMessage(chatId, groupChallengeTextHTML, { parse_mode: 'HTML', reply_markup: groupChallengeKeyboard });
            if (!sentGroupMessage || !sentGroupMessage.message_id) throw new Error("Could not send the direct challenge message.");

            offerData = {
                type: GAME_IDS.DIRECT_PVP_CHALLENGE, offerId: offerId, gameId: offerId, initiatorId: userId,
                initiatorUserObj: initiatorUserObj, initiatorMentionHTML: initiatorPlayerRefHTML,
                targetUserId: String(targetUserObjectForChallenge.telegram_id), targetUserObj: targetUserObjectForChallenge, targetUserMentionHTML: targetPlayerRefHTML,
                betAmount: betAmountLamports, originalGroupId: chatId, offerMessageIdInGroup: String(sentGroupMessage.message_id),
                chatTitle: msg.chat.title || `Group Chat ${chatId}`, status: 'pending_direct_challenge_response',
                gameToStart: GAME_IDS.DICE_ESCALATOR_PVP,
                _offerKeyUsedForGroupLock: GAME_IDS.DICE_ESCALATOR_DIRECT_CHALLENGE_OFFER,
                creationTime: Date.now(), timeoutId: null
            };
        } else { // Unified Offer
            offerId = generateGameId("de_uo");
            timeoutDuration = UNIFIED_OFFER_TIMEOUT_MS;

            const betResultUnified = await updateUserBalanceAndLedger(clientBetPlacement, userId, BigInt(-betAmountLamports), 'bet_placed_de_unified_offer', { custom_offer_id: offerId }, `Dice Escalator Unified Offer`);
            if (!betResultUnified.success) throw new Error(betResultUnified.error || "Failed to place your bet for the unified offer.");
            initiatorUserObj.balance = betResultUnified.newBalanceLamports;

            const offerMessageTextHTML = `🎲 <b>Dice Escalator Challenge by ${initiatorPlayerRefHTML}!</b> 🎲\n\n` +
                `Wager: <b>${betDisplayUSD_HTML}</b>\n\n` +
                `Do you want to challenge the Bot Dealer or another player? This offer expires in ${timeoutDuration / 1000} seconds. Bet refunded on timeout.`;
            const offerKeyboard = {
                inline_keyboard: [
                    [{ text: `⚔️ Accept PvP Challenge!`, callback_data: `de_accept_pvp_challenge:${offerId}` }],
                    [{ text: `🤖 Challenge Bot Dealer`, callback_data: `de_accept_bot_game:${offerId}` }],
                    [{ text: "🚫 Cancel My Offer", callback_data: `de_cancel_unified_offer:${offerId}` }]
                ]
            };
            const sentOfferMessage = await safeSendMessage(chatId, offerMessageTextHTML, { parse_mode: 'HTML', reply_markup: offerKeyboard });
            if (!sentOfferMessage?.message_id) throw new Error("Could not send the unified offer message.");

            offerData = {
                type: GAME_IDS.DICE_ESCALATOR_UNIFIED_OFFER, gameId: offerId, chatId: String(chatId),
                chatType: chatType, initiatorId: userId, initiatorMentionHTML: initiatorPlayerRefHTML,
                initiatorUserObj: initiatorUserObj, betAmount: betAmountLamports, status: 'pending_unified_offer',
                creationTime: Date.now(), gameSetupMessageId: String(sentOfferMessage.message_id), timeoutId: null
            };
        }

        await clientBetPlacement.query('COMMIT');
        activeGames.set(offerId, offerData);
        await updateGroupGameDetails(chatId, offerId, offerActivityKeyForLock, betAmountLamports);
        console.log(`${logPrefix} Offer ${offerId} (Type: ${offerData.type}, Group Lock Key: ${offerActivityKeyForLock}) created. Bet placed. Lock updated.`);

        offerData.timeoutId = setTimeout(async () => {
            const timedOutOffer = activeGames.get(offerId);
            if (timedOutOffer && (timedOutOffer.status === 'pending_unified_offer' || timedOutOffer.status === 'pending_direct_challenge_response')) {
                console.log(`${logPrefix} Offer ${offerId} (Type: ${timedOutOffer.type}) for Dice Escalator has timed out.`);
                activeGames.delete(offerId);
                const keyForTimeoutRemoval = timedOutOffer._offerKeyUsedForGroupLock || offerActivityKeyForLock;
                await updateGroupGameDetails(chatId, { removeThisId: offerId }, keyForTimeoutRemoval, null);
                console.log(`${logPrefix} Cleared group lock for timed-out offer ${offerId} using key ${keyForTimeoutRemoval}.`);

                let refundClientTimeout = null;
                try {
                    refundClientTimeout = await pool.connect();
                    await refundClientTimeout.query('BEGIN');
                    const refundReason = timedOutOffer.type === GAME_IDS.DIRECT_PVP_CHALLENGE ? 'direct_challenge_expired_unanswered' : 'unified_offer_expired_unanswered';
                    const refundNotes = `Refund for expired ${timedOutOffer.type === GAME_IDS.DIRECT_PVP_CHALLENGE ? 'direct Dice Escalator challenge' : 'unified Dice Escalator offer'} ${offerId}.`;
                    await updateUserBalanceAndLedger(refundClientTimeout, timedOutOffer.initiatorId, timedOutOffer.betAmount, `refund_de_${refundReason}`, { custom_offer_id: offerId }, refundNotes);
                    await refundClientTimeout.query('COMMIT');
                } catch (e) {
                    if (refundClientTimeout) await refundClientTimeout.query('ROLLBACK').catch(() => {});
                    console.error(`${logPrefix} CRITICAL: Failed to refund initiator ${timedOutOffer.initiatorId} for timed out DE offer ${offerId}: ${e.message}`);
                    if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL REFUND FAILURE for timed out DE offer ${offerId}, Initiator: ${timedOutOffer.initiatorId}. Error: ${e.message}`);
                } finally {
                    if (refundClientTimeout) refundClientTimeout.release();
                }

                const messageIdToEdit = timedOutOffer.offerMessageIdInGroup || timedOutOffer.gameSetupMessageId;
                const currentBetDisplayHTML_Timeout = escapeHTML(await formatBalanceForDisplay(timedOutOffer.betAmount, 'USD'));
                const timeoutMsgHTML = timedOutOffer.type === GAME_IDS.DIRECT_PVP_CHALLENGE ?
                    `⏳ The Dice Escalator challenge from ${timedOutOffer.initiatorMentionHTML} to ${timedOutOffer.targetUserMentionHTML} for <b>${currentBetDisplayHTML_Timeout}</b> has expired unanswered. Initiator's bet refunded.` :
                    `⏳ The Dice Escalator offer by ${timedOutOffer.initiatorMentionHTML} for <b>${currentBetDisplayHTML_Timeout}</b> has expired unanswered. Initiator's bet refunded.`;

                if (messageIdToEdit && bot) {
                    await bot.editMessageText(timeoutMsgHTML, {
                        chat_id: String(chatId), message_id: Number(messageIdToEdit),
                        parse_mode: 'HTML', reply_markup: {}
                    }).catch(e => console.warn(`${logPrefix} Failed to edit expired DE offer message ${messageIdToEdit}: ${e.message}`));
                }
            }
        }, timeoutDuration);
        activeGames.set(offerId, offerData); // Save timeoutId

    } catch (error) {
        if (clientBetPlacement) await clientBetPlacement.query('ROLLBACK').catch(() => {});
        console.error(`${logPrefix} Error creating DE offer or placing bet: ${error.message}`);
        await safeSendMessage(chatId, `⚠️ Error creating your Dice Escalator offer: ${escapeHTML(error.message)}. Please try again.`, { parse_mode: 'HTML' });
        if (offerId && activeGames.has(offerId)) {
            activeGames.delete(offerId);
            const keyForErrorCleanup = offerData?._offerKeyUsedForGroupLock || offerActivityKeyForLock;
            if(keyForErrorCleanup) await updateGroupGameDetails(chatId, { removeThisId: offerId }, keyForErrorCleanup, null);
        }
    } finally {
        if (clientBetPlacement) clientBetPlacement.release();
    }
}
// --- END OF FULL REPLACEMENT for handleStartDiceEscalatorUnifiedOfferCommand_New ---
// --- START OF FULL REPLACEMENT for handleDiceEscalatorAcceptBotGame_New function ---
async function handleDiceEscalatorAcceptBotGame_New(offerId, userWhoClicked, originalOfferMessageId, originalChatId, originalChatType, callbackQueryId) {
    const userId = String(userWhoClicked.telegram_id || userWhoClicked.id); 
    const logPrefix = `[DE_AcceptBot_V3_GranLimit UID:${userId} OfferID:"${offerId}" CH:${originalChatId}]`;
    const offerData = activeGames.get(offerId);

    // --- MODIFIED USER ACTIVE GAME LIMIT CHECK AND MESSAGE ---
    // Pass offerId as gameIdBeingActioned, as the user is actioning this specific offer.
    const activeUserGameCheck = await checkUserActiveGameLimit(userId, false, offerId); 
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = escapeHTML(getPlayerDisplayReference(userWhoClicked));
        const blockingGameType = activeUserGameCheck.details.type;
        const cleanGameName = getCleanGameName(blockingGameType);
        let alertMessage = `✨ ${userDisplayName}, you're already in a game of ${escapeHTML(cleanGameName)}. ✨ Finish it first!`;
        alertMessage = alertMessage.substring(0, 200); // Telegram alert length limit

        if (callbackQueryId) {
            await bot.answerCallbackQuery(callbackQueryId, { text: alertMessage, show_alert: true }).catch(() => {});
        } else {
            // Fallback if no callbackQueryId (e.g., if called from a non-callback context, though less likely here)
            const fullAlertMessageForChat = `✨ ${userDisplayName}, you already have a pending offer or active game for <b>${escapeHTML(cleanGameName)}</b>. Please finish it before starting a new one. ✨`;
            await safeSendMessage(originalChatId, fullAlertMessageForChat, { parse_mode: 'HTML' });
        }
        return;
    }
    // --- END OF MODIFICATION ---

    if (!offerData || offerData.type !== GAME_IDS.DICE_ESCALATOR_UNIFIED_OFFER || offerData.status !== 'pending_unified_offer') {
        if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "This Dice Escalator offer has expired or is invalid.", show_alert: true });
        const msgIdToClearButtons = offerData?.gameSetupMessageId || originalOfferMessageId;
        if (msgIdToClearButtons && bot) {
            bot.editMessageReplyMarkup({}, { chat_id: originalChatId, message_id: Number(msgIdToClearButtons) }).catch(() => {});
        }
        return;
    }
    if (userId !== offerData.initiatorId) {
        if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "Only the offer initiator can play against the Bot.", show_alert: true });
        return;
    }

    const gameSession = await getGroupSession(originalChatId);
    const activeGameKeyToCheck = GAME_IDS.DICE_ESCALATOR_PVB; 
    const currentActiveDEGamesInGroup = gameSession.activeGamesByTypeInGroup.get(activeGameKeyToCheck) || [];
    const limitActiveForGroup = GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[activeGameKeyToCheck] || 1;

    if (currentActiveDEGamesInGroup.length >= limitActiveForGroup) {
        if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: `Max ${limitActiveForGroup} active Dice Escalator PvB game(s) allowed in this group. Please wait.`, show_alert: true }).catch(() => {});
        return;
    }

    if (offerData.timeoutId) clearTimeout(offerData.timeoutId);
    if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "Starting Dice Escalator vs Bot..." }).catch(() => {});
    
    offerData.status = 'bot_game_accepted'; 

    await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.DICE_ESCALATOR_UNIFIED_OFFER, null);
    
    activeGames.delete(offerId); 

    await startDiceEscalatorPvBGame_New(
        { id: originalChatId, type: originalChatType }, 
        offerData.initiatorUserObj,
        offerData.betAmount,
        offerData.gameSetupMessageId || originalOfferMessageId, 
        false, 
        null, 
        originalChatType 
    );
}
// --- END OF FULL REPLACEMENT for handleDiceEscalatorAcceptBotGame_New function ---

// --- START OF FULL REPLACEMENT for handleDiceEscalatorAcceptPvPChallenge_New function ---
async function handleDiceEscalatorAcceptPvPChallenge_New(offerId, joinerUserObjFromCallback, originalOfferMessageId, originalChatId, originalChatType, callbackQueryId) {
    const joinerId = String(joinerUserObjFromCallback.telegram_id || joinerUserObjFromCallback.id); 
    const logPrefix = `[DE_AcceptPvP_V3_GranLimit UID:${joinerId} OfferID:"${offerId}" CH:${originalChatId}]`;
    const offerData = activeGames.get(offerId);

    // --- MODIFIED USER ACTIVE GAME LIMIT CHECK AND MESSAGE ---
    // Pass offerId as gameIdBeingActioned, as the user is actioning this specific offer.
    const activeUserGameCheck = await checkUserActiveGameLimit(joinerId, false, offerId); 
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = escapeHTML(getPlayerDisplayReference(joinerUserObjFromCallback));
        const blockingGameType = activeUserGameCheck.details.type;
        const cleanGameName = getCleanGameName(blockingGameType);
        let alertMessage = `✨ ${userDisplayName}, you're already in a game of ${escapeHTML(cleanGameName)}. ✨ Finish it first!`;
        alertMessage = alertMessage.substring(0, 200); // Telegram alert length limit

        if (callbackQueryId) {
            await bot.answerCallbackQuery(callbackQueryId, { text: alertMessage, show_alert: true }).catch(() => {});
        } else {
            // Fallback if no callbackQueryId (less likely for this handler type)
            const fullAlertMessageForChat = `✨ ${userDisplayName}, you already have a pending offer or active game for <b>${escapeHTML(cleanGameName)}</b>. Please finish it before starting a new one. ✨`;
            await safeSendMessage(originalChatId, fullAlertMessageForChat, { parse_mode: 'HTML' });
        }
        return;
    }
    // --- END OF MODIFICATION ---

    if (!offerData || offerData.type !== GAME_IDS.DICE_ESCALATOR_UNIFIED_OFFER || offerData.status !== 'pending_unified_offer') {
        if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "This Dice Escalator PvP offer is no longer valid.", show_alert: true });
        const msgIdToClearButtons = offerData?.gameSetupMessageId || originalOfferMessageId;
        if (msgIdToClearButtons && bot) {
            bot.editMessageReplyMarkup({}, { chat_id: originalChatId, message_id: Number(msgIdToClearButtons) }).catch(() => {});
        }
        return;
    }
    if (joinerId === offerData.initiatorId) {
        if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "You cannot accept your own challenge for PvP.", show_alert: true });
        return;
    }

    const gameSession = await getGroupSession(originalChatId);
    const activeGameKeyToCheck = GAME_IDS.DICE_ESCALATOR_PVP_FROM_UNIFIED;
    const currentActiveDEGames = gameSession.activeGamesByTypeInGroup.get(activeGameKeyToCheck) || [];
    const limitActive = GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[activeGameKeyToCheck] || 1;

    if (currentActiveDEGames.length >= limitActive) {
        if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: `Max ${limitActive} active Dice Escalator PvP (from unified) game(s) allowed. Please wait.`, show_alert: true });
        return;
    }

    const betDisplayHTML = escapeHTML(await formatBalanceForDisplay(offerData.betAmount, 'USD'));
    const currentJoinerUserObj = await getOrCreateUser(joinerId, joinerUserObjFromCallback.username, joinerUserObjFromCallback.first_name, joinerUserObjFromCallback.last_name);
    if (!currentJoinerUserObj || BigInt(currentJoinerUserObj.balance) < offerData.betAmount) {
        if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: `Your balance is too low for this ${betDisplayHTML} duel.`, show_alert: true });
        return;
    }
    const currentInitiatorUserObj = await getOrCreateUser(offerData.initiatorId);
    if (!currentInitiatorUserObj || BigInt(currentInitiatorUserObj.balance) < offerData.betAmount) {
        if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "Initiator can't cover the bet. Offer cancelled.", show_alert: true });
        if (offerData.timeoutId) clearTimeout(offerData.timeoutId);
        activeGames.delete(offerId);
        await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.DICE_ESCALATOR_UNIFIED_OFFER, null);
        const msgIdToEdit = offerData.gameSetupMessageId || originalOfferMessageId;
        if(msgIdToEdit && bot) await bot.editMessageText(`⚠️ Dice Escalator offer by ${offerData.initiatorMentionHTML} cancelled (initiator funds insufficient).`, {chat_id: originalChatId, message_id: Number(msgIdToEdit), parse_mode:'HTML', reply_markup:{}}).catch(()=>{});
        return;
    }

    if (offerData.timeoutId) clearTimeout(offerData.timeoutId);
    if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: `Joining DE PvP vs ${offerData.initiatorMentionHTML}...` });
    
    offerData.status = 'pvp_accepted';
    
    await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.DICE_ESCALATOR_UNIFIED_OFFER, null);

    let clientBet = null;
    try {
        clientBet = await pool.connect();
        await clientBet.query('BEGIN');
        const joinBetRes = await updateUserBalanceAndLedger(clientBet, joinerId, BigInt(-offerData.betAmount), 'bet_placed_de_pvp_join', { game_id_custom_field: offerId, opponent_id_custom_field: offerData.initiatorId }, `Dice Escalator PvP Join vs ${offerData.initiatorMentionHTML}`);
        if (!joinBetRes.success) throw new Error(joinBetRes.error || "Failed to deduct joiner's bet.");
        currentJoinerUserObj.balance = joinBetRes.newBalanceLamports;
        await clientBet.query('COMMIT');
    } catch (e) {
        if (clientBet) await clientBet.query('ROLLBACK').catch(() => {});
        console.error(`${logPrefix} Failed to deduct joiner's bet for DE PvP: ${e.message}`);
        await safeSendMessage(originalChatId, `Error processing joiner's bet for DE PvP. Game cancelled.`, { parse_mode: 'HTML' });
        let refundClient = null;
        try {
            refundClient = await pool.connect(); await refundClient.query('BEGIN');
            await updateUserBalanceAndLedger(refundClient, offerData.initiatorId, offerData.betAmount, 'refund_de_pvp_opponent_bet_fail', {custom_offer_id: offerId}, `DE offer ${offerId} refund due to joiner bet fail.`);
            await refundClient.query('COMMIT');
        } catch (refErr) { if(refundClient) await refundClient.query('ROLLBACK'); console.error(`${logPrefix} CRITICAL: Failed to refund initiator after joiner bet fail: ${refErr.message}`); }
        finally { if(refundClient) refundClient.release(); }
        activeGames.delete(offerId); 
        return;
    } finally {
        if (clientBet) clientBet.release();
    }

    // Bet successfully taken, now delete the offer object from activeGames
    activeGames.delete(offerId); 

    await startDiceEscalatorPvPGame_New(
        currentInitiatorUserObj,
        currentJoinerUserObj,
        offerData.betAmount,
        originalChatId,
        originalChatType,
        offerData.gameSetupMessageId || originalOfferMessageId,
        'unified_offer' 
    );
}
// --- END OF FULL REPLACEMENT for handleDiceEscalatorAcceptPvPChallenge_New function ---

// --- START OF FULL REPLACEMENT for handleDiceEscalatorCancelUnifiedOffer_New function ---
async function handleDiceEscalatorCancelUnifiedOffer_New(offerId, userWhoClicked, originalOfferMessageId, originalChatId, callbackQueryId) {
    const userId = String(userWhoClicked.telegram_id || userWhoClicked.id); // Use telegram_id if available, fallback to id
    const logPrefix = `[DE_CancelUnified_V2 UID:${userId} OfferID:"${offerId}"]`;
    const offerData = activeGames.get(offerId);

    if (!offerData || offerData.type !== GAME_IDS.DICE_ESCALATOR_UNIFIED_OFFER || offerData.status !== 'pending_unified_offer') {
        await bot.answerCallbackQuery(callbackQueryId, { text: "Offer already actioned or invalid.", show_alert: false });
        return;
    }
    if (userId !== offerData.initiatorId) {
        await bot.answerCallbackQuery(callbackQueryId, { text: "Only the initiator can cancel.", show_alert: true });
        return;
    }

    if (offerData.timeoutId) clearTimeout(offerData.timeoutId);
    await bot.answerCallbackQuery(callbackQueryId, { text: "Dice Escalator offer cancelled. Refunding bet..." });
    activeGames.delete(offerId);
    // Ensure we use the specific key for Dice Escalator UNIFIED offers for removal
    await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.DICE_ESCALATOR_UNIFIED_OFFER, null);

    let refundClient = null;
    try {
        refundClient = await pool.connect();
        await refundClient.query('BEGIN');
        await updateUserBalanceAndLedger(refundClient, offerData.initiatorId, offerData.betAmount, 'refund_de_offer_cancelled', { custom_offer_id: offerId }, `Refund for cancelled DE unified offer ${offerId}`);
        await refundClient.query('COMMIT');
        console.log(`${logPrefix} Bet refunded to initiator ${offerData.initiatorId} for cancelled DE offer ${offerId}.`);
    } catch (e) {
        if (refundClient) await refundClient.query('ROLLBACK').catch(() => {});
        console.error(`${logPrefix} CRITICAL: Failed to refund initiator for cancelled DE offer ${offerId}: ${e.message}`);
        if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL REFUND FAILURE for cancelled DE offer ${offerId}, Initiator: ${offerData.initiatorId}, Bet: ${offerData.betAmount}. Error: ${e.message}`);
    } finally {
        if (refundClient) refundClient.release();
    }

    const betDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(offerData.betAmount, 'USD'));
    // offerData.initiatorMentionHTML should already be HTML-escaped from when the offer was created
    const initiatorDisplayHTML = offerData.initiatorMentionHTML || escapeHTML(getPlayerDisplayReference(offerData.initiatorUserObj || {id: offerData.initiatorId, first_name: "Player"}));

    // Construct the message without problematic <span> tags
    const cancelledMessageHTML = `🚫 ${initiatorDisplayHTML} has cancelled their Dice Escalator offer for <b>${betDisplayUSD_HTML}</b>. Bet refunded.`;

    const messageIdToEdit = Number(originalOfferMessageId || offerData.gameSetupMessageId);
    if (bot && messageIdToEdit) {
        await bot.editMessageText(cancelledMessageHTML, {
            chat_id: originalChatId, message_id: messageIdToEdit,
            parse_mode: 'HTML', reply_markup: {}
        }).catch(async (e) => {
            // If editing fails (e.g., message too old, or some other intermittent issue), send a new message.
             if (!e.message?.toLowerCase().includes("message is not modified")) {
                console.warn(`${logPrefix} Failed to edit cancellation message ${messageIdToEdit}, sending new. Error: ${e.message}`);
                await safeSendMessage(originalChatId, cancelledMessageHTML, { parse_mode: 'HTML' });
            }
        });
    } else {
        await safeSendMessage(originalChatId, cancelledMessageHTML, { parse_mode: 'HTML' });
    }
}
// --- END OF FULL REPLACEMENT for handleDiceEscalatorCancelUnifiedOffer_New function ---
// --- Dice Escalator Player vs. Bot (PvB) Game Logic ---
async function startDiceEscalatorPvBGame_New(chat, initiatorUserObj, betAmountLamports, originalOfferMessageIdToDelete = null, isPlayAgain = false, unifiedOfferIdIfAny = null) {
    const chatId = String(chat.id);
    const userId = String(initiatorUserObj.telegram_id);
    const logPrefix = `[DE_PvB_Start_V4_GranLimit UID:${userId} CH:${chatId}]`;
    const playerRefHTML = escapeHTML(getPlayerDisplayReference(initiatorUserObj));
    
    // Specific key for active PvB Dice Escalator games
    const activeGameActivityKey = GAME_IDS.DICE_ESCALATOR_PVB; 

    if (originalOfferMessageIdToDelete && bot) {
        await bot.deleteMessage(chatId, Number(originalOfferMessageIdToDelete)).catch(e => {});
    }
    if (unifiedOfferIdIfAny && activeGames.has(unifiedOfferIdIfAny)) {
        activeGames.delete(unifiedOfferIdIfAny);
    }

    let client = null;
    const gameId = generateGameId(GAME_IDS.DICE_ESCALATOR_PVB);
    let jackpotContribution = 0n;

    try {
        if (isPlayAgain) { 
            client = await pool.connect();
            await client.query('BEGIN');
            const betResult = await updateUserBalanceAndLedger(client, userId, BigInt(-betAmountLamports), 'bet_placed_de_pvb', { game_id_custom_field: gameId }, `DE PvB bet (Play Again)`);
            if (!betResult.success) throw new Error(betResult.error || "Play Again bet placement failed.");
            initiatorUserObj.balance = betResult.newBalanceLamports; 
            jackpotContribution = BigInt(Math.floor(Number(betAmountLamports) * JACKPOT_CONTRIBUTION_PERCENT));
            if (jackpotContribution > 0n) {
                await client.query('UPDATE jackpots SET current_amount = current_amount + $1, updated_at = NOW() WHERE jackpot_id = $2', [jackpotContribution.toString(), MAIN_JACKPOT_ID]);
            }
            await client.query('COMMIT');
        } else { 
            jackpotContribution = BigInt(Math.floor(Number(betAmountLamports) * JACKPOT_CONTRIBUTION_PERCENT));
            // If coming from unified offer, initial bet already placed, and jackpot should be handled based on house rules
            // For simplicity, if jackpot is always contributed from player bet, ensure it was part of the initial deduction.
            // If the offer didn't explicitly deduct jackpot fee, and it MUST be deducted, this is the place for non-play-again.
            // However, current logic for unified offers deducts only betAmount. So, jackpot contribution might be taken from house share.
            // The `jackpotContribution` variable stores the amount IF it were to be moved.
            // The DB update for jackpot happens here only for "Play Again" to ensure it's added if player pays again.
        }
    } catch (error) {
        if (client) await client.query('ROLLBACK').catch(()=>{});
        console.error(`${logPrefix} Database error starting PvB (Play Again bet/jackpot): ${error.message}`);
        await safeSendMessage(chatId, "⚙️ <b>Database Hiccup!</b> Error starting game. Wager not processed if play again. Try again.", { parse_mode: 'HTML' });
        return; 
    } finally {
        if (client) client.release();
    }

    const gameData = {
        gameId: gameId, type: GAME_IDS.DICE_ESCALATOR_PVB,
        player: {
            userId: userId, username: initiatorUserObj.username, firstName: initiatorUserObj.first_name,
            displayName: playerRefHTML, score: 0, rolls: [], isGoingForJackpot: false, busted: false, stood: false
        },
        betAmount: betAmountLamports, chatId: chatId, chatType: chat.type,
        status: 'player_turn_awaiting_emoji',
        createdAt: Date.now(), gameMessageId: null,
        jackpotContribution: jackpotContribution, 
        lastPlayerRoll: null, botRolls: [], botScore: 0,
        turnTimeoutId: null 
    };
    activeGames.set(gameId, gameData);
    if (chat.type !== 'private') {
        await updateGroupGameDetails(chatId, gameId, activeGameActivityKey, betAmountLamports); // Use specific PvB key
    }
    console.log(`${logPrefix} DE PvB game ${gameId} instance created. Group lock for ${activeGameActivityKey} updated.`);
    await updateDiceEscalatorPvBMessage_New(gameData); 
}

async function handleDiceEscalatorPvBTurnTimeout(gameId) {
    const logPrefix = `[DE_PvB_TurnTimeout GID:${gameId}]`;
    const gameData = activeGames.get(gameId);

    if (!gameData || gameData.type !== GAME_IDS.DICE_ESCALATOR_PVB ||
        !(gameData.status === 'player_turn_awaiting_emoji' || gameData.status === 'player_score_18_plus_awaiting_choice')) {
        if (gameData && gameData.turnTimeoutId) clearTimeout(gameData.turnTimeoutId);
        return;
    }
    console.log(`${logPrefix} Player ${gameData.player.userId} timed out. Game forfeited.`);

    if (gameData.turnTimeoutId) clearTimeout(gameData.turnTimeoutId);
    gameData.turnTimeoutId = null;

    gameData.status = 'game_over_player_forfeit'; 
    gameData.player.busted = true; 
    activeGames.set(gameId, gameData); 

    let client = null;
    try {
        client = await pool.connect(); await client.query('BEGIN');
        await updateUserBalanceAndLedger(client, gameData.player.userId, 0n, 'loss_de_pvb_timeout_forfeit',
            { game_id_custom_field: gameId, score_before_forfeit: gameData.player.score },
            `DE PvB game ${gameId} forfeited by player due to turn timeout.`);
        await client.query('COMMIT');
    } catch (e) {
        if(client) await client.query('ROLLBACK');
        console.error(`${logPrefix} DB error logging DE PvB timeout forfeit: ${e.message}`);
    } finally {
        if(client) client.release();
    }

    await finalizeDiceEscalatorPvBGame_New(gameData, 0); 
}

async function handleDEGoForJackpot(gameId, userWhoClicked, originalMessageId, callbackQueryId, chatData) {
    const userId = String(userWhoClicked.telegram_id || userWhoClicked.id);
    const chatId = String(chatData.id); // Use chatData.id passed from callback router
    const logPrefix = `[DE_GoForJackpot_V2_HelperHandOff GID:${gameId} UID:${userId}]`;

    const gameData = activeGames.get(gameId);

    if (!gameData || gameData.type !== GAME_IDS.DICE_ESCALATOR_PVB || 
        gameData.status !== 'player_score_18_plus_awaiting_choice' || 
        gameData.player.userId !== userId) {
        if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "Action not available or not your turn.", show_alert: true }).catch(()=>{});
        console.warn(`${logPrefix} Invalid action. GameData Status: ${gameData?.status}, Type: ${gameData?.type}, Player in game: ${gameData?.player?.userId}`);
        return;
    }

    // Clear MainBot's turn timeout for this game's player choice phase
    if (gameData.turnTimeoutId) {
        clearTimeout(gameData.turnTimeoutId);
        gameData.turnTimeoutId = null;
    }
    if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, {text: "Engaging Jackpot Mode! Handing over to Jackpot Roller..."}).catch(()=>{});

    let client = null;
    try {
        client = await pool.connect();
        await client.query('BEGIN');

        const jackpotResultDb = await client.query('SELECT current_amount FROM jackpots WHERE jackpot_id = $1 FOR UPDATE', [MAIN_JACKPOT_ID]);
        let jackpotPoolAtSessionStart = 0n;
        if (jackpotResultDb.rows.length > 0 && jackpotResultDb.rows[0].current_amount) {
            jackpotPoolAtSessionStart = BigInt(jackpotResultDb.rows[0].current_amount);
        }
        console.log(`${logPrefix} Jackpot pool amount at start of run: ${jackpotPoolAtSessionStart}`);

        const mainBotGameIdForSession = gameData.gameId; // Use the existing gameId
        const initialScore = gameData.player.score;
        const initialRollsJson = JSON.stringify(gameData.player.rolls);
        const betAmountLamports = gameData.betAmount;
        const targetJackpotScoreConst = parseInt(process.env.TARGET_JACKPOT_SCORE, 10) || TARGET_JACKPOT_SCORE;
        const bustOnValueConst = parseInt(process.env.DICE_ESCALATOR_BUST_ON, 10) || DICE_ESCALATOR_BUST_ON;

        const insertSessionQuery = `
            INSERT INTO de_jackpot_sessions 
                (main_bot_game_id, user_id, chat_id, initial_score, initial_rolls_json, 
                 bet_amount_lamports, target_jackpot_score, bust_on_value, jackpot_pool_at_session_start, status)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, 'pending_pickup')
            RETURNING session_id;
        `;
        const sessionParams = [
            mainBotGameIdForSession, userId, chatId, initialScore, initialRollsJson,
            betAmountLamports.toString(), targetJackpotScoreConst, bustOnValueConst, jackpotPoolAtSessionStart.toString()
        ];
        const sessionRes = await client.query(insertSessionQuery, sessionParams);
        
        if (!sessionRes.rows[0] || !sessionRes.rows[0].session_id) {
            throw new Error("Failed to create jackpot session record in DB.");
        }
        const jackpotSessionDbId = sessionRes.rows[0].session_id;
        console.log(`${logPrefix} Created de_jackpot_sessions record ID: ${jackpotSessionDbId} for MainBot GID: ${mainBotGameIdForSession}`);

        // Update MainBot's game status to indicate handoff and store jackpot session DB ID
        gameData.player.isGoingForJackpot = true; 
        gameData.status = 'jackpot_run_delegated'; 
        gameData.jackpotSessionDbId = jackpotSessionDbId; // Store the DB ID of the session
        gameData.lastInteractionTime = Date.now();
        // No more turnTimeouts for the MainBot for this game's player turns phase
        if (gameData.turnTimeoutId) { clearTimeout(gameData.turnTimeoutId); gameData.turnTimeoutId = null; }
        
        activeGames.set(gameData.gameId, gameData); 

        await client.query('COMMIT');

        // Inform the user and delete/edit the MainBot's last message
        if (gameData.gameMessageId && bot) {
            await bot.deleteMessage(String(chatId), Number(gameData.gameMessageId)).catch(e => {});
            gameData.gameMessageId = null; 
            activeGames.set(gameData.gameId, gameData); 
        }

        const playerRefHTML = escapeHTML(gameData.player.displayName || getPlayerDisplayReference(userWhoClicked));
        const handoverMessage = `🔥 <b>Jackpot Run Activated for ${playerRefHTML}!</b> 🔥\n\n` +
                                `You're going for the grand prize! Our specialist Jackpot Roller Bot will now guide your rolls.\n\n` +
                                `Please send your 🎲 dice emoji to the chat when prompted by the Jackpot Roller. Good luck!`;
        await safeSendMessage(String(chatId), handoverMessage, { parse_mode: 'HTML' });

    } catch (error) {
        if (client) await client.query('ROLLBACK').catch(rbErr => console.error(`${logPrefix} Rollback error: ${rbErr.message}`));
        console.error(`${logPrefix} Error during jackpot handoff: ${error.message}`, error.stack?.substring(0, 500));
        await safeSendMessage(String(chatId), "⚙️ An error occurred while activating Jackpot Mode. Please try again or contact support.", { parse_mode: 'HTML' });
        
        const gameDataOnError = activeGames.get(gameId);
        if (gameDataOnError && gameDataOnError.status === 'jackpot_run_delegated') { 
            gameDataOnError.status = 'player_score_18_plus_awaiting_choice'; 
            gameDataOnError.player.isGoingForJackpot = false;
            delete gameDataOnError.jackpotSessionDbId; // Clear session id if handoff failed
            activeGames.set(gameId, gameDataOnError);
            console.warn(`${logPrefix} Reverted game status for ${gameId} due to handoff error.`);
            // Optionally resend choice prompt if desired
            // if (typeof updateDiceEscalatorPvBMessage_New === 'function') await updateDiceEscalatorPvBMessage_New(gameDataOnError);
        }
    } finally {
        if (client) client.release();
    }
}

// --- START OF FULL REPLACEMENT for processDiceEscalatorPvBRollByEmoji_New function ---
async function processDiceEscalatorPvBRollByEmoji_New(gameData, diceValue) {
    const logPrefix = `[DE_PvB_Roll_V3_ChoiceFix UID:${gameData.player.userId} Game:${gameData.gameId}]`;

    // --- MODIFIED STATUS CHECK ---
    if (gameData.status === 'player_score_18_plus_awaiting_choice') {
        console.warn(`${logPrefix} Roll received via emoji while status is 'player_score_18_plus_awaiting_choice'. Ignoring. Player should use buttons.`);
        // User's dice emoji is typically deleted by the main message handler.
        // You could optionally send a brief message here if desired, but ignoring is often sufficient.
        return; 
    }

    if (gameData.status !== 'player_turn_awaiting_emoji') { 
        console.warn(`${logPrefix} Roll received but game status is '${gameData.status}' (not 'player_turn_awaiting_emoji'). Ignoring.`);
        return;
    }
    // --- END OF MODIFIED STATUS CHECK ---
    
    if (gameData.turnTimeoutId) {
        clearTimeout(gameData.turnTimeoutId);
        gameData.turnTimeoutId = null; 
    }

    const player = gameData.player;
    const playerRefHTML = escapeHTML(player.displayName);

    // Decide on your temporary roll announcement strategy.
    // If you want to keep it "as is" (meaning the temporary message is still sent and deleted by this MainBot function):
    const rollAnnounceTextHTML = `🎲 ${playerRefHTML} rolled a <b>${escapeHTML(String(diceValue))}</b>!`;
    const tempRollMsg = await safeSendMessage(gameData.chatId, rollAnnounceTextHTML, { parse_mode: 'HTML' });
    if (tempRollMsg?.message_id && bot) { 
         await sleep(BUST_MESSAGE_DELAY_MS > 1000 ? 1200 : BUST_MESSAGE_DELAY_MS / 1.5);
         await bot.deleteMessage(gameData.chatId, tempRollMsg.message_id).catch(()=>{});
    }
    // If you decided to REMOVE the temporary message based on earlier discussions to reduce API calls,
    // you would remove the block above.

    player.rolls.push(diceValue);
    gameData.lastPlayerRoll = diceValue;
    gameData.lastInteractionTime = Date.now();

    const currentBustOnValue = parseInt(process.env.DICE_ESCALATOR_BUST_ON, 10) || DICE_ESCALATOR_BUST_ON;
    if (diceValue === currentBustOnValue) {
        player.busted = true;
        gameData.status = 'player_busted';
        activeGames.set(gameData.gameId, gameData);
        await updateDiceEscalatorPvBMessage_New(gameData); 
        await sleep(BUST_MESSAGE_DELAY_MS); 
        await finalizeDiceEscalatorPvBGame_New(gameData, 0); 
        return;
    }

    player.score += diceValue;
    const currentTargetJackpotScore = parseInt(process.env.TARGET_JACKPOT_SCORE, 10) || TARGET_JACKPOT_SCORE;

    if (player.score >= currentTargetJackpotScore) { 
        player.stood = true; 
        gameData.status = 'player_stood'; 
        activeGames.set(gameData.gameId, gameData);
        await updateDiceEscalatorPvBMessage_New(gameData); 
        await sleep(1000);
        await processDiceEscalatorBotTurnPvB_New(gameData); 
        return;
    }

    if (player.score >= 18 && !player.isGoingForJackpot) {
        gameData.status = 'player_score_18_plus_awaiting_choice';
    } else {
        gameData.status = 'player_turn_awaiting_emoji';
    }
    activeGames.set(gameData.gameId, gameData);
    await updateDiceEscalatorPvBMessage_New(gameData); 
}
// --- END OF FULL REPLACEMENT for processDiceEscalatorPvBRollByEmoji_New function ---

async function updateDiceEscalatorPvBMessage_New(gameData, isStanding = false) {
    if (!gameData || !bot) return;
    if (gameData.gameMessageId && bot) {
        await bot.deleteMessage(gameData.chatId, Number(gameData.gameMessageId)).catch(e => {});
        gameData.gameMessageId = null;
    }

    if (isStanding) gameData.status = 'player_stood';
    if (gameData.turnTimeoutId) {
        clearTimeout(gameData.turnTimeoutId);
        gameData.turnTimeoutId = null;
    }
    activeGames.set(gameData.gameId, gameData); 

    const messageTextHTML = await formatDiceEscalatorGameMessage_New(gameData);
    let keyboard = { inline_keyboard: [] };

    if (gameData.status === 'player_score_18_plus_awaiting_choice') {
        keyboard.inline_keyboard.push(
            [{ text: "✋ Stand Firm!", callback_data: `de_stand_pvb:${gameData.gameId}` }],
            [{ text: "🔥 Go for Jackpot!", callback_data: `de_pvb_go_for_jackpot:${gameData.gameId}` }]
        );
    } else if (gameData.status === 'player_turn_awaiting_emoji' && !isStanding && !gameData.player.busted && !gameData.player.isGoingForJackpot) {
        keyboard.inline_keyboard.push([{ text: "✋ Stand Firm!", callback_data: `de_stand_pvb:${gameData.gameId}` }]);
    }

    if (keyboard.inline_keyboard.length > 0 || gameData.status === 'player_stood' || gameData.status === 'bot_turn_complete' || gameData.status.startsWith('game_over_')) {
        if (keyboard.inline_keyboard.length > 0 && (!keyboard.inline_keyboard[keyboard.inline_keyboard.length-1] || !keyboard.inline_keyboard[keyboard.inline_keyboard.length-1].find(b => b.text === "📖 Game Rules"))) {
            keyboard.inline_keyboard.push([{ text: "📖 Game Rules", callback_data: `${RULES_CALLBACK_PREFIX_CONST}${GAME_IDS.DICE_ESCALATOR_UNIFIED_OFFER}` }]);
        } else if (keyboard.inline_keyboard.length === 0 && !gameData.status.startsWith('game_over_')) { 
            keyboard.inline_keyboard.push([{ text: "📖 Game Rules", callback_data: `${RULES_CALLBACK_PREFIX_CONST}${GAME_IDS.DICE_ESCALATOR_UNIFIED_OFFER}` }]);
        }
    }

    const sentMessage = await safeSendMessage(gameData.chatId, messageTextHTML, {
        parse_mode: 'HTML',
        reply_markup: (keyboard.inline_keyboard && keyboard.inline_keyboard.length > 0) ? keyboard : {}
    });

    if (sentMessage?.message_id) {
        gameData.gameMessageId = String(sentMessage.message_id);
        if (gameData.status === 'player_turn_awaiting_emoji' || gameData.status === 'player_score_18_plus_awaiting_choice') {
            gameData.turnTimeoutId = setTimeout(() => {
                handleDiceEscalatorPvBTurnTimeout(gameData.gameId);
            }, ACTIVE_GAME_TURN_TIMEOUT_MS);
            console.log(`[UpdateDE_PvB_V2_Timeout] Set turn timeout ${gameData.turnTimeoutId} for ${gameData.gameId}`);
        }
    } else {
        console.error(`[UpdateDE_PvB_V2_Timeout] CRITICAL: Failed to send/update PvB game message for ${gameData.gameId}.`);
    }
    if(activeGames.has(gameData.gameId)) activeGames.set(gameData.gameId, gameData);
}

async function handleDiceEscalatorPvBStand_New(gameId, userWhoClicked, originalMessageId, callbackQueryId, chatData) {
    const gameData = activeGames.get(gameId);
    if (!gameData || gameData.type !== GAME_IDS.DICE_ESCALATOR_PVB || gameData.player.userId !== userWhoClicked.telegram_id || gameData.player.isGoingForJackpot || (gameData.status !== 'player_turn_awaiting_emoji' && gameData.status !== 'player_score_18_plus_awaiting_choice') ) {
        if(callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "Cannot stand now.", show_alert: true }).catch(()=>{});
        return;
    }

    if (gameData.turnTimeoutId) clearTimeout(gameData.turnTimeoutId); 
    gameData.turnTimeoutId = null;

    if(callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, {text: `You stand with ${gameData.player.score} points! Bot's turn...`}).catch(()=>{});

    gameData.player.stood = true;
    gameData.lastInteractionTime = Date.now();
    await updateDiceEscalatorPvBMessage_New(gameData, true); 
    await sleep(1000);
    await processDiceEscalatorBotTurnPvB_New(gameData);
}

async function processDiceEscalatorBotTurnPvB_New(gameData) {
    if (!gameData || gameData.status !== 'player_stood') { return; }

    gameData.botRolls = await getThreeDiceRollsViaHelper_DE_New(gameData.gameId, gameData.chatId);
    gameData.botScore = gameData.botRolls.reduce((sum, roll) => sum + roll, 0);
    gameData.status = 'bot_turn_complete';
    activeGames.set(gameData.gameId, gameData);

    await updateDiceEscalatorPvBMessage_New(gameData);
    await sleep(1500);
    await finalizeDiceEscalatorPvBGame_New(gameData, gameData.botScore);
}

// CORRECTED finalizeDiceEscalatorPvBGame_New (with Referral Fixes)
async function finalizeDiceEscalatorPvBGame_New(gameData, botScoreArgument) {
    const { gameId, chatId, player, betAmount, userObj, status: finalStatusInput, chatType } = gameData;
    const logPrefix = `[FinalizeDE_PvB_V7_FullFix GID:${gameId}]`;
    let allNotificationsToSend = [];

    let solPrice;
    try {
        solPrice = await getSolUsdPrice();
    } catch (priceError) {
        console.error(`${logPrefix} CRITICAL: Could not get SOL price. Level-up/milestone checks will be skipped. Error: ${priceError.message}`);
        solPrice = 0;
    }

    activeGames.delete(gameId);
    const activeGameKeyToClear = GAME_IDS.DICE_ESCALATOR_PVB;
    if (chatType && chatType !== 'private') {
        await updateGroupGameDetails(chatId, { removeThisId: gameId }, activeGameKeyToClear, null);
    }

    let resultTextOutcomeHTML = "";
    let titleEmoji = "🏁";
    let payoutLamports = 0n;
    let ledgerOutcomeCode = 'loss_de_pvb';
    let jackpotWon = false;
    let jackpotAmountClaimed = 0n;
    const playerRefHTML = escapeHTML(player.displayName);
    const wagerDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(betAmount, 'USD'));
    let finalTitle = `Dice Escalator - Result!`;
    let gameOutcomeTextForLog = "";
    let isConclusiveOutcome = false;
    
    const botFinalScore = gameData.botScore || botScoreArgument || 0;
    const finalStatus = finalStatusInput || gameData.status;
    const currentTargetJackpotScore = parseInt(process.env.TARGET_JACKPOT_SCORE, 10) || TARGET_JACKPOT_SCORE;
    const currentBustOnValue = parseInt(process.env.DICE_ESCALATOR_BUST_ON, 10) || DICE_ESCALATOR_BUST_ON;

    if (finalStatus === 'game_over_player_forfeit') {
        isConclusiveOutcome = true;
        titleEmoji = "⏳"; finalTitle = `Game Forfeited, ${playerRefHTML}!`;
        resultTextOutcomeHTML = `Your turn timed out, or you forfeited. The Bot Dealer wins <b>${wagerDisplayUSD_HTML}</b>.`;
        ledgerOutcomeCode = 'loss_de_pvb_timeout_forfeit';
        gameOutcomeTextForLog = `Player forfeit (score: ${player.score})`;
    } else if (player.busted) {
        isConclusiveOutcome = true;
        titleEmoji = "💥"; finalTitle = `BUSTED, ${playerRefHTML}!`;
        const lastRollDisplay = escapeHTML(String(gameData.lastPlayerRoll !== undefined && gameData.lastPlayerRoll !== null ? gameData.lastPlayerRoll : '?'));
        const bustOnDisplay = escapeHTML(String(currentBustOnValue));
        resultTextOutcomeHTML = `Your roll of <b>${lastRollDisplay}</b> (bust on <b>${bustOnDisplay}</b>) ended your climb.\nThe Bot Dealer wins <b>${wagerDisplayUSD_HTML}</b>.`;
        ledgerOutcomeCode = 'loss_de_pvb_bust';
        gameOutcomeTextForLog = `Player busted (roll: ${lastRollDisplay}, score: ${player.score})`;
    } else if (finalStatus === 'game_over_error_helper') {
        isConclusiveOutcome = true;
        titleEmoji = "⚙️"; finalTitle = `Problem during Jackpot Run, ${playerRefHTML}!`;
        resultTextOutcomeHTML = `There was an issue reported by the Jackpot Helper Bot. Your bet of <b>${wagerDisplayUSD_HTML}</b> will be treated as a loss for this game round against the bot. Notes: ${escapeHTML(gameData.outcome_notes || "Helper error")}`;
        ledgerOutcomeCode = 'loss_de_pvb_helper_error';
        gameOutcomeTextForLog = `Helper error during jackpot run (score: ${player.score})`;
    } else if (player.score > botFinalScore) {
        isConclusiveOutcome = true;
        titleEmoji = "🎉"; finalTitle = `VICTORY, ${playerRefHTML}!`;
        payoutLamports = betAmount * 2n; 
        ledgerOutcomeCode = 'win_de_pvb';
        const potWonHTML = escapeHTML(await formatBalanceForDisplay(betAmount, 'USD'));
        resultTextOutcomeHTML = `Your score of <b>${player.score}</b> conquers the Bot Dealer's <i>${botFinalScore}</i>!\nYou win <b>${potWonHTML}</b> in profit!`;
        gameOutcomeTextForLog = `Player wins (${player.score} vs ${botFinalScore})`;

        if (player.score >= currentTargetJackpotScore) {
            let clientJackpot = null;
            try {
                clientJackpot = await pool.connect(); 
                await clientJackpot.query('BEGIN');
                const jackpotRes = await clientJackpot.query('SELECT current_amount FROM jackpots WHERE jackpot_id = $1 FOR UPDATE', [MAIN_JACKPOT_ID]);
                if (jackpotRes.rows.length > 0 && BigInt(jackpotRes.rows[0].current_amount || '0') > 0n) {
                    jackpotAmountClaimed = BigInt(jackpotRes.rows[0].current_amount);
                    await clientJackpot.query('UPDATE jackpots SET current_amount = 0, last_won_by_telegram_id = $1, last_won_timestamp = NOW(), updated_at = NOW() WHERE jackpot_id = $2', [player.userId, MAIN_JACKPOT_ID]);
                    payoutLamports += jackpotAmountClaimed; 
                    jackpotWon = true; titleEmoji = "🎆";
                    finalTitle = `SUPER JACKPOT WIN, ${playerRefHTML}!!`;
                    resultTextOutcomeHTML = `<pre>🎇✨✨✨✨✨✨✨✨✨✨✨✨🎇\n`+
                                           `   💎💎  MEGA JACKPOT HIT!  💎💎\n`+
                                           `🎇✨✨✨✨✨✨✨✨✨✨✨✨🎇</pre>\n` +
                                           `<b>INCREDIBLE, ${playerRefHTML}!</b>\nYour score of <b>${player.score}</b> beat the Bot's <i>${botFinalScore}</i>, AND you've smashed the Super Jackpot, claiming an additional astounding:\n\n`+
                                           `💰💰💰🔥 <b>${escapeHTML(await formatBalanceForDisplay(jackpotAmountClaimed, 'USD'))}</b> 🔥💰💰💰\n\n` +
                                           `Total Payout: An unbelievable <b>${escapeHTML(await formatBalanceForDisplay(payoutLamports, 'USD'))}</b>!\n` +
                                           `Truly a legendary performance! 🥳🎉`;
                    ledgerOutcomeCode = 'win_de_pvb_jackpot';
                    gameOutcomeTextForLog = `Player JACKPOT WIN! (${player.score} vs ${botFinalScore})`;
                } else { resultTextOutcomeHTML += `\n\n<i>(The Super Jackpot was already claimed or empty.)</i>`; }
                await clientJackpot.query('COMMIT');
            } catch (e) {
                if (clientJackpot) await clientJackpot.query('ROLLBACK').catch(()=>{});
                jackpotWon = false; jackpotAmountClaimed = 0n; 
                if (ledgerOutcomeCode === 'win_de_pvb_jackpot') ledgerOutcomeCode = 'win_de_pvb';
                resultTextOutcomeHTML += `\n\n⚠️ <i>Jackpot claim issue. Base winnings secure.</i>`;
            } finally { if (clientJackpot) clientJackpot.release(); }
        }
    } else if (player.score === botFinalScore) {
        isConclusiveOutcome = false; // A push does not trigger wager bonuses
        titleEmoji = "⚖️"; finalTitle = `A Close Call - It's a Push!`;
        payoutLamports = betAmount; 
        ledgerOutcomeCode = 'push_de_pvb';
        resultTextOutcomeHTML = `You and the Bot Dealer both scored <b>${player.score}</b>.\nYour wager of <b>${wagerDisplayUSD_HTML}</b> is returned.`;
        gameOutcomeTextForLog = `Push (Draw at ${player.score})`;
    } else { // Bot wins by score
        isConclusiveOutcome = true;
        titleEmoji = "🤖"; finalTitle = `The Bot Dealer Wins This Round!`;
        ledgerOutcomeCode = 'loss_de_pvb_score';
        resultTextOutcomeHTML = `The Bot Dealer's score of <b>${botFinalScore}</b> narrowly beat your <i>${player.score}</i>. Better luck next time!`;
        gameOutcomeTextForLog = `Bot wins (${botFinalScore} vs ${player.score})`;
    }
    
    let dbErrorDuringPayoutText = "";
    let clientPayout = null;
    try {
        clientPayout = await pool.connect(); await clientPayout.query('BEGIN');

        const actualGameLogId = await logGameResultToGamesTable(
            clientPayout, GAME_IDS.DICE_ESCALATOR_PVB, chatId, player.userId, [player.userId], betAmount,
            gameOutcomeTextForLog, jackpotWon ? jackpotAmountClaimed : gameData.jackpotContribution
        );

        const notes = `DE PvB Result. Player: ${player.score}, Bot: ${botFinalScore}. Jackpot Claimed: ${jackpotAmountClaimed > 0n ? formatCurrency(jackpotAmountClaimed, 'SOL') : '0'}. GameID: ${gameId}. Final Status: ${finalStatus}`;
        const balanceUpdate = await updateUserBalanceAndLedger(
            clientPayout, player.userId, payoutLamports, ledgerOutcomeCode, 
            { game_log_id: actualGameLogId, jackpot_amount_custom_field: jackpotAmountClaimed.toString(), player_score_custom: player.score, bot_score_custom: botFinalScore, player_busted_custom: player.busted, original_bet_amount: betAmount.toString() }, 
            notes,
            solPrice
        );

        if (!balanceUpdate.success) {
            throw new Error(balanceUpdate.error || "DB Error during Dice Escalator PvB payout.");
        }
        if (balanceUpdate.notifications) allNotificationsToSend.push(...balanceUpdate.notifications);
        
        if (isConclusiveOutcome) {
            // --- START OF MODIFICATION ---

            // 1. ADDED: Check for the initial bet bonus.
            if (typeof processQualifyingBetAndInitialBonus === 'function') {
                const initialBonusResult = await processQualifyingBetAndInitialBonus(clientPayout, player.userId, betAmount, gameId);
                if (initialBonusResult.jobQueued) {
                    console.log(`[ReferralCheck] Queued initial bet bonus job for user ${player.userId} from game ${gameId}.`);
                }
            }
            
            // 2. MODIFIED: Correctly call level and milestone checks.
            if (balanceUpdate.newTotalWageredLamports !== undefined) {
                if (typeof checkAndUpdateUserLevel === 'function') {
                    const levelNotifications = await checkAndUpdateUserLevel(clientPayout, player.userId, balanceUpdate.newTotalWageredLamports, solPrice, chatId);
                    allNotificationsToSend.push(...levelNotifications);
                }
                if (typeof processWagerMilestoneBonus === 'function') {
                    const milestoneNotifications = await processWagerMilestoneBonus(clientPayout, player.userId, balanceUpdate.newTotalWageredLamports, solPrice);
                    if (!milestoneNotifications.success) {
                        console.warn(`${logPrefix} Failed to process milestone bonus: ${milestoneNotifications.error}`);
                    }
                }
            }

            // --- END OF MODIFICATION ---
        }
        
        await clientPayout.query('COMMIT');
    } catch (e) {
        if (clientPayout) await clientPayout.query('ROLLBACK').catch(() => {});
        console.error(`${logPrefix} CRITICAL DB error: ${e.message}`);
        dbErrorDuringPayoutText = `\n\n⚠️ <i>Critical error settling wager. Admin notified.</i>`;
        if(typeof notifyAdmin === 'function') notifyAdmin(`🚨 CRITICAL DE PvB Payout Failure 🚨\nGame ID: <code>${escapeHTML(gameId)}</code>\nError: ${escapeHTML(e.message)}. Manual check needed.`, { parse_mode: 'HTML'});
    } finally { 
        if (clientPayout) clientPayout.release(); 
    }
    
    for (const notification of allNotificationsToSend) {
        if (notification.to === ADMIN_USER_ID && typeof notifyAdmin === 'function') {
            await notifyAdmin(notification.text, notification.options).catch(err => console.error(`Failed to send admin notification: ${err.message}`));
        } else {
            await safeSendMessage(notification.to, notification.text, notification.options).catch(err => console.error(`Failed to send game-related notification to ${notification.to}: ${err.message}`));
        }
    }

    const playerRollsDisplay = formatDiceRolls(player.rolls);
    const botRollsDisplay = formatDiceRolls(gameData.botRolls || []);

    let fullResultMessageHTML =
        `${titleEmoji} <b>${escapeHTML(finalTitle)}</b> ${titleEmoji}\n\n` +
        `Player: ${playerRefHTML}\n` +
        `Wager: <b>${wagerDisplayUSD_HTML}</b>\n\n` +
        `Your Rolls: ${playerRollsDisplay} ➠ Score: <b>${escapeHTML(String(player.score))}</b> ${player.busted ? "💥 BUSTED!" : ""}\n` +
        `Bot's Rolls: ${botRollsDisplay} ➠ Score: <b>${escapeHTML(String(botFinalScore))}</b>\n\n` +
        `------------------------------------\n` +
        `${resultTextOutcomeHTML}` +
        `${dbErrorDuringPayoutText}\n\n` +
        `<i>Thanks for playing Dice Escalator!</i>`;

    if (gameData.gameMessageId && bot) {
        await bot.deleteMessage(chatId, Number(gameData.gameMessageId)).catch(() => {});
    }
    
    const finalKeyboard = createPostGameKeyboard(GAME_IDS.DICE_ESCALATOR_PVB, betAmount);
    await safeSendMessage(chatId, fullResultMessageHTML, {
        parse_mode: 'HTML',
        reply_markup: finalKeyboard
    });
}

async function pollCompletedJackpotSessions() {
    // Very first log to confirm execution
    console.log("!!! [MainBot_PollJackpotSessions_V3_Corrected] Poller function EXECUTED - Checking for sessions. !!!");

    if (isShuttingDown) { // Use MainBot's shutdown flag
        console.log("[MainBot_PollJackpotSessions_V3_Corrected] Shutdown detected, not polling.");
        return;
    }

    if (pollCompletedJackpotSessions.isRunning) {
        // console.log("[MainBot_PollJackpotSessions_V3_Corrected] Poller already running. Skipping."); // Can be noisy
        return;
    }
    pollCompletedJackpotSessions.isRunning = true;

    const logPrefix = '[MainBot_PollJackpotSessions_V3_Corrected]';
    let client = null; // DB client for the main query

    try {
        client = await pool.connect();
        const selectQuery = `
            SELECT * FROM de_jackpot_sessions 
            WHERE (status LIKE 'completed_%' OR status LIKE 'error_%') 
              AND status NOT LIKE 'archived_%'
            ORDER BY updated_at ASC 
            LIMIT 5`; // Process a few at a time
        const completedSessionsRes = await client.query(selectQuery);

        if (completedSessionsRes.rowCount === 0) {
            // console.log(`${logPrefix} No completed/errored jackpot sessions found to process in this cycle.`); // Can be noisy
            // No need to release client here, finally block will handle it.
            return; // Exit if no sessions to process
        }

        console.log(`${logPrefix} Found ${completedSessionsRes.rowCount} potentially completed/errored jackpot session(s) to process.`);

        for (const session of completedSessionsRes.rows) {
            if (isShuttingDown) {
                console.log(`${logPrefix} Shutdown detected during session processing loop for SID:${session.session_id}.`);
                break; // Exit loop if shutting down
            }

            const sessionLogPrefix = `${logPrefix} SID:${session.session_id} MainGID:${session.main_bot_game_id}`;
            let individualSessionClient = null; // DB client for individual session updates (like error archiving)

            try {
                console.log(`${sessionLogPrefix} Processing session with DB status: '${session.status}'`);

                const mainGameData = activeGames.get(session.main_bot_game_id);

                if (!mainGameData) {
                    console.warn(`${sessionLogPrefix} Main game data (GID: ${session.main_bot_game_id}) NOT FOUND in activeGames. Archiving helper session.`);
                    // Use the main client for this archival as it's a direct DB update based on query results
                    await client.query("UPDATE de_jackpot_sessions SET status = 'archived_no_main_game_found', outcome_notes = COALESCE(outcome_notes, '') || ' MainBot: Original game not found.' WHERE session_id = $1", [session.session_id]);
                    continue; // Process next session
                }

                if (mainGameData.status !== 'jackpot_run_delegated') {
                    console.warn(`${sessionLogPrefix} Main game GID ${session.main_bot_game_id} status is '${mainGameData.status}', NOT 'jackpot_run_delegated'. Archiving helper session as potentially stale or mishandled.`);
                    await client.query("UPDATE de_jackpot_sessions SET status = 'archived_main_game_wrong_status', outcome_notes = COALESCE(outcome_notes, '') || ' MainBot: Game status was not jackpot_run_delegated.' WHERE session_id = $1", [session.session_id]);
                    // Also, consider if activeGames map for mainGameData needs cleanup if it's in a wrong state
                    activeGames.delete(session.main_bot_game_id); // Remove from active games if state is inconsistent
                    await updateGroupGameDetails(mainGameData.chatId, { removeThisId: session.main_bot_game_id }, GAME_IDS.DICE_ESCALATOR_PVB, null); // Clear group lock
                    continue;
                }

                if (mainGameData.jackpotSessionDbId !== session.session_id) {
                    console.warn(`${sessionLogPrefix} Main game GID ${session.main_bot_game_id} has jackpotSessionDbId '${mainGameData.jackpotSessionDbId}', but helper session ID is '${session.session_id}'. Mismatch. Archiving helper session.`);
                    await client.query("UPDATE de_jackpot_sessions SET status = 'archived_session_id_mismatch', outcome_notes = COALESCE(outcome_notes, '') || ' MainBot: Session ID mismatch.' WHERE session_id = $1", [session.session_id]);
                    continue;
                }

                console.log(`${sessionLogPrefix} Main game data found and validated. Current MainBot game status: '${mainGameData.status}', jackpotSessionDbId in MainBot: ${mainGameData.jackpotSessionDbId}`);

                // Safely parse score
                try {
                    let parsedScore = mainGameData.player.score; // Default to existing score
                    if (session.final_score !== null && session.final_score !== undefined) {
                        const tempScore = parseInt(session.final_score, 10);
                        if (!isNaN(tempScore)) {
                            parsedScore = tempScore;
                        } else {
                            console.warn(`${sessionLogPrefix} Could not parse session.final_score ('${session.final_score}') into an integer. Using existing score or 0.`);
                            parsedScore = mainGameData.player.score || 0; // Fallback
                        }
                    }
                    mainGameData.player.score = parsedScore;
                } catch (e) {
                    console.error(`${sessionLogPrefix} Error processing session.final_score ('${session.final_score}'): ${e.message}. Score may be inaccurate.`);
                    mainGameData.player.score = mainGameData.player.score || 0; // Fallback
                }

                // Safely parse rolls
                try {
                    // Default to existing player rolls or an empty array if session.final_rolls_json is null/undefined or fails to parse
                    mainGameData.player.rolls = JSON.parse(session.final_rolls_json || JSON.stringify(mainGameData.player.rolls || []));
                } catch (e) {
                    console.error(`${sessionLogPrefix} Error parsing session.final_rolls_json ('${session.final_rolls_json}'): ${e.message}. Player rolls might be incorrect or default to previous/empty.`);
                    // Keep existing mainGameData.player.rolls or ensure it's an array
                    mainGameData.player.rolls = Array.isArray(mainGameData.player.rolls) ? mainGameData.player.rolls : [];
                }
                
                mainGameData.outcome_notes = session.outcome_notes; // Store notes from helper

                let proceedToBotTurn = false; // Bot does not play after player's jackpot run

                if (session.status === 'completed_bust') {
                    mainGameData.player.busted = true;
                    mainGameData.status = 'player_busted'; // This status is critical for finalizeDiceEscalatorPvBGame_New
                    if (mainGameData.player.rolls && mainGameData.player.rolls.length > 0) {
                        mainGameData.lastPlayerRoll = mainGameData.player.rolls[mainGameData.player.rolls.length - 1];
                    } else {
                        mainGameData.lastPlayerRoll = sessionDataRef?.bust_on_value || DICE_ESCALATOR_BUST_ON; // Fallback if rolls array empty
                        console.warn(`${sessionLogPrefix} Player busted, but rolls array was empty. Setting lastPlayerRoll to bust_on_value.`);
                    }
                    console.log(`${sessionLogPrefix} Player BUSTED during jackpot run. MainBot Status set to: '${mainGameData.status}'. Last Roll: ${mainGameData.lastPlayerRoll}`);
                } else if (session.status === 'completed_timeout_forfeit') {
                    mainGameData.status = 'game_over_player_forfeit'; // Finalize will handle this
                    mainGameData.player.busted = true; // Treat as a bust for outcome simplicity
                    console.log(`${sessionLogPrefix} Player FORFEITED jackpot run (timeout by helper). MainBot Status set to: '${mainGameData.status}'`);
                } else if (session.status === 'completed_target_reached') {
                    mainGameData.player.busted = false;
                    mainGameData.player.stood = true;
                    mainGameData.status = 'player_stood'; // Player "stood" by reaching target
                    proceedToBotTurn = true; // MainBot needs to play its turn now
                    console.log(`${sessionLogPrefix} Player TARGET REACHED in jackpot run. MainBot Status set to: '${mainGameData.status}'. Proceeding to bot turn.`);
                } else if (session.status.startsWith('error_')) {
                    mainGameData.status = 'game_over_error_helper';
                    mainGameData.player.busted = true; // Treat helper error as a bust for outcome
                    console.error(`${sessionLogPrefix} Jackpot run ended with an error from helper: '${session.status}' - Notes: ${session.outcome_notes}`);
                } else {
                    console.warn(`${sessionLogPrefix} Unknown completed status from helper: '${session.status}'. Treating as error/bust.`);
                    mainGameData.status = 'game_over_error_helper';
                    mainGameData.player.busted = true;
                }

                activeGames.set(session.main_bot_game_id, mainGameData); // Update the game object in activeGames map

                if (proceedToBotTurn) {
                    console.log(`${sessionLogPrefix} Player completed jackpot run successfully. Proceeding to MainBot's turn (processDiceEscalatorBotTurnPvB_New).`);
                    await processDiceEscalatorBotTurnPvB_New(mainGameData);
                } else {
                    console.log(`${sessionLogPrefix} Finalizing game directly for status: ${mainGameData.status} (Player busted/forfeited/error, or bot turn not applicable).`);
                    await finalizeDiceEscalatorPvBGame_New(mainGameData, mainGameData.botScore || 0); // Bot score is likely 0
                }

                // Archive the session in the DB using the main client for this loop iteration
                await client.query("UPDATE de_jackpot_sessions SET status = 'archived_processed_by_mainbot' WHERE session_id = $1", [session.session_id]);
                console.log(`${sessionLogPrefix} Jackpot session archived as 'archived_processed_by_mainbot'.`);

            } catch (sessionError) { // Catch errors from processing a single session
                console.error(`❌ ${sessionLogPrefix} CRITICAL error processing session: ${sessionError.message}`, sessionError.stack?.substring(0, 700));
                if (typeof notifyAdmin === 'function') {
                    notifyAdmin(`🚨 *Error Processing Jackpot Session in MainBot* 🚨\nSID: \`${session.session_id}\`\nMainGID: \`${session.main_bot_game_id}\`\nError: \`${escapeMarkdownV2(String(sessionError.message || sessionError))}\`\nSession may need manual review/archival.`, {parse_mode:'MarkdownV2'});
                }
                // Attempt to archive this problematic session with an error status using a new client
                try {
                    individualSessionClient = await pool.connect(); // Use a new client for this specific update
                    await individualSessionClient.query(
                        "UPDATE de_jackpot_sessions SET status = 'archived_mainbot_processing_error', outcome_notes = COALESCE(outcome_notes, '') || ' MainBot Processing Error: " + String(sessionError.message).substring(0, 100) + "' WHERE session_id = $1 AND status NOT LIKE 'archived_%'",
                        [session.session_id]
                    );
                    console.log(`${sessionLogPrefix} Problematic jackpot session marked as 'archived_mainbot_processing_error'.`);
                } catch (archiveError) {
                    console.error(`❌ ${sessionLogPrefix} Failed to archive problematic session ${session.session_id} with error: ${archiveError.message}`);
                } finally {
                    if (individualSessionClient) individualSessionClient.release();
                }
                // Continue to the next session in the loop
            }
        } // End of for...of loop

    } catch (error) { // Catch errors from the main try block (e.g., connecting to DB, initial query)
        console.error(`❌ ${logPrefix} Outer error in polling/processing completed jackpot sessions: ${error.message}`, error.stack?.substring(0,500));
        if (typeof notifyAdmin === 'function') {
             notifyAdmin(`🚨 *CRITICAL Error in Jackpot Poller Loop* 🚨\n\n\`${escapeMarkdownV2(String(error.message || error))}\`\nCheck MainBot logs. Polling cycle may be affected.`, {parse_mode: 'MarkdownV2'});
        }
    } finally {
        if (client) client.release(); // Release the main client for this polling cycle
        pollCompletedJackpotSessions.isRunning = false; // Correctly reset the flag for this specific poller
        // console.log(`${logPrefix} Polling cycle finished. isRunning set to false.`); // Can be noisy
    }
}

// --- Dice Escalator Player vs. Player (PvP) Game Logic (HTML Revamp) ---
async function startDiceEscalatorPvPGame_New(
    initiatorUserObj, 
    opponentUserObj,  
    betAmountLamports,
    groupChatId,      
    groupChatType,    
    messageIdToDeleteAfterAccept = null,
    origin // 'unified_offer' or 'direct_challenge'
) {
    const logPrefix = `[DE_PvP_Start_V4_Origin UID1:${initiatorUserObj.telegram_id} UID2:${opponentUserObj.telegram_id} CH:${groupChatId} Origin:${origin}]`;
    
    let activeGameKeyForStorage;
    if (origin === 'unified_offer') {
        activeGameKeyForStorage = GAME_IDS.DICE_ESCALATOR_PVP_FROM_UNIFIED;
    } else { // 'direct_challenge'
        activeGameKeyForStorage = GAME_IDS.DICE_ESCALATOR_PVP; 
    }

    if (messageIdToDeleteAfterAccept && bot) {
        await bot.deleteMessage(groupChatId, Number(messageIdToDeleteAfterAccept))
            .catch(e => console.warn(`${logPrefix} Non-critical: Could not delete previous message ${messageIdToDeleteAfterAccept}: ${e.message}`));
    }

    const pvpGameId = generateGameId(GAME_IDS.DICE_ESCALATOR_PVP);
    const initiatorPlayerDisplayName = escapeHTML(getPlayerDisplayReference(initiatorUserObj));
    const opponentPlayerDisplayName = escapeHTML(getPlayerDisplayReference(opponentUserObj));

    const initiatorPlayerData = {
        userId: String(initiatorUserObj.telegram_id),
        displayName: initiatorPlayerDisplayName,
        userObj: initiatorUserObj,
        score: 0, rolls: [],
        isTurn: true, 
        busted: false, stood: false,
        status: 'awaiting_roll_emoji'
    };
    const opponentPlayerData = {
        userId: String(opponentUserObj.telegram_id),
        displayName: opponentPlayerDisplayName,
        userObj: opponentUserObj,
        score: 0, rolls: [],
        isTurn: false,
        busted: false, stood: false,
        status: 'waiting_turn'
    };

    const gameData = {
        gameId: pvpGameId,
        type: GAME_IDS.DICE_ESCALATOR_PVP,
        chatId: String(groupChatId),
        chatType: groupChatType,
        initiator: initiatorPlayerData,
        opponent: opponentPlayerData,
        betAmount: betAmountLamports,
        status: 'p1_awaiting_roll_emoji', 
        currentMessageId: null,
        createdAt: Date.now(),
        lastRollValue: null,
        currentTurnTimeoutId: null,
        _origin_key_for_limits: activeGameKeyForStorage // Store for cleanup; this will be GAME_IDS.DICE_ESCALATOR_PVP for direct challenges
    };
    activeGames.set(pvpGameId, gameData);
    // Use specific key when adding to group's active game list
    await updateGroupGameDetails(groupChatId, pvpGameId, activeGameKeyForStorage, betAmountLamports); 
    console.log(`${logPrefix} DE PvP game ${pvpGameId} created. Group lock using key ${activeGameKeyForStorage} updated. Initiator's turn.`);

    if (typeof updateDiceEscalatorPvPMessage_New === 'function') {
        await updateDiceEscalatorPvPMessage_New(gameData); 
    } else {
        console.error(`${logPrefix} CRITICAL ERROR: updateDiceEscalatorPvPMessage_New function is not defined!`);
        activeGames.delete(pvpGameId);
        await updateGroupGameDetails(groupChatId, { removeThisId: pvpGameId }, activeGameKeyForStorage, null);
        let refundClient = null;
        try {
            refundClient = await pool.connect(); await refundClient.query('BEGIN');
            await updateUserBalanceAndLedger(refundClient, initiatorUserObj.telegram_id, betAmountLamports, 'refund_de_pvp_ui_fail', {}, `DE PvP UI Fail ${pvpGameId}`);
            await updateUserBalanceAndLedger(refundClient, opponentUserObj.telegram_id, betAmountLamports, 'refund_de_pvp_ui_fail', {}, `DE PvP UI Fail ${pvpGameId}`);
            await refundClient.query('COMMIT');
        } catch(e) {
            if(refundClient) await refundClient.query('ROLLBACK');
            console.error(`${logPrefix} CRITICAL REFUND FAILURE for DE PvP UI Fail GID ${pvpGameId}: ${e.message}`);
        } finally { if(refundClient) refundClient.release(); }
        await safeSendMessage(groupChatId, "⚙️ Critical error: Could not display the Dice Escalator PvP game board. Game cancelled, bets refunded.", {parse_mode: 'HTML'});
    }
}

async function handleDiceEscalatorPvPTurnTimeout(gameId, timedOutPlayerId) {
    const logPrefix = `[DE_PvP_TurnTimeout GID:${gameId} Player:${timedOutPlayerId}]`;
    const gameData = activeGames.get(gameId);

    if (!gameData || gameData.type !== GAME_IDS.DICE_ESCALATOR_PVP || gameData.status.startsWith('game_over_')) {
        if (gameData && gameData.currentTurnTimeoutId) clearTimeout(gameData.currentTurnTimeoutId);
        return;
    }

    const activePlayer = gameData.initiator.isTurn ? gameData.initiator : (gameData.opponent.isTurn ? gameData.opponent : null);
    if (!activePlayer || activePlayer.userId !== timedOutPlayerId || activePlayer.status !== 'awaiting_roll_emoji') {
        return;
    }
    console.log(`${logPrefix} Player ${timedOutPlayerId} timed out their turn. Forfeiting.`);

    if (gameData.currentTurnTimeoutId) clearTimeout(gameData.currentTurnTimeoutId);
    gameData.currentTurnTimeoutId = null;

    let winner, loser;
    if (gameData.initiator.userId === timedOutPlayerId) {
        gameData.status = 'game_over_p1_timeout_forfeit';
        gameData.initiator.status = 'timeout_forfeit';
        gameData.opponent.status = 'win_by_opponent_timeout'; // Set opponent status
        winner = gameData.opponent; loser = gameData.initiator;
    } else {
        gameData.status = 'game_over_p2_timeout_forfeit';
        gameData.opponent.status = 'timeout_forfeit';
        gameData.initiator.status = 'win_by_opponent_timeout'; // Set initiator status
        winner = gameData.initiator; loser = gameData.opponent;
    }
    gameData.initiator.isTurn = false;
    gameData.opponent.isTurn = false;
    activeGames.set(gameId, gameData); 

    const timedOutPlayerMentionHTML = escapeHTML(loser.displayName);
    const winnerMentionHTML = escapeHTML(winner.displayName);
    const timeoutMsgHTML = `⏳ ${timedOutPlayerMentionHTML} ran out of time! ${winnerMentionHTML} wins the Dice Escalator duel by forfeit!`;
    await safeSendMessage(gameData.chatId, timeoutMsgHTML, {parse_mode:'HTML'});
    await sleep(1000);

    await resolveDiceEscalatorPvPGame_New(gameData, timedOutPlayerId);
}

// --- START OF FULL REPLACEMENT for processDiceEscalatorPvPRollByEmoji_New function ---
async function processDiceEscalatorPvPRollByEmoji_New(gameData, diceValue, userIdWhoRolled) {
    const logPrefix = `[DE_PvP_Roll_V3_Timeout UID:${userIdWhoRolled} Game:${gameData.gameId}]`;
    let currentPlayer, otherPlayer, playerKeyPrefix;

    // Ensure gameData is the authoritative version from activeGames
    const activeGameData = activeGames.get(gameData.gameId);
    if (!activeGameData) {
        console.warn(`${logPrefix} Game not found in activeGames. Aborting roll processing.`);
        return;
    }
    gameData = activeGameData; // Work with the reference from the map

    if (gameData.initiator.userId === userIdWhoRolled && gameData.initiator.isTurn) {
        currentPlayer = gameData.initiator; otherPlayer = gameData.opponent; playerKeyPrefix = 'p1';
    } else if (gameData.opponent.userId === userIdWhoRolled && gameData.opponent.isTurn) {
        currentPlayer = gameData.opponent; otherPlayer = gameData.initiator; playerKeyPrefix = 'p2';
    } else {
        console.warn(`${logPrefix} Roll from non-active player or out of turn. Roller: ${userIdWhoRolled}, P1_Turn: ${gameData.initiator.isTurn}, P2_Turn: ${gameData.opponent.isTurn}`);
        return;
    }

    if (currentPlayer.status !== 'awaiting_roll_emoji') {
        console.warn(`${logPrefix} Player ${currentPlayer.displayName} status is '${currentPlayer.status}'. Not expecting roll.`);
        return;
    }

    // Clear current turn timeout as player has made an action
    if (gameData.currentTurnTimeoutId) {
        clearTimeout(gameData.currentTurnTimeoutId);
        gameData.currentTurnTimeoutId = null;
        console.log(`${logPrefix} Cleared existing turn timeout for player ${userIdWhoRolled}.`);
    }

    const playerRefHTML = escapeHTML(currentPlayer.displayName);
    // Send a temporary message acknowledging the roll. This will be cleaned up by updateDiceEscalatorPvPMessage_New.
    const tempRollMsgText = `🎲 ${playerRefHTML} rolled a <b>${escapeHTML(String(diceValue))}</b>! Score processing...`;
    const tempRollMsg = await safeSendMessage(gameData.chatId, tempRollMsgText, { parse_mode: 'HTML' });
    if (tempRollMsg?.message_id) {
        gameData.intermediateMessageIds = [...(gameData.intermediateMessageIds || []), tempRollMsg.message_id];
    }
    await sleep(1000); // Allow user to see their roll acknowledgement briefly

    currentPlayer.rolls.push(diceValue);
    gameData.lastRollValue = diceValue; // Storing last roll might be useful for display
    gameData.lastInteractionTime = Date.now();

    if (diceValue === DICE_ESCALATOR_BUST_ON) {
        currentPlayer.busted = true;
        currentPlayer.status = 'bust'; // Player specific status
        currentPlayer.isTurn = false;
        // Overall game status reflects which player busted
        gameData.status = (playerKeyPrefix === 'p1') ? 'game_over_p1_bust' : 'game_over_p2_bust';
        console.log(`${logPrefix} Player ${playerRefHTML} BUSTED with ${diceValue}. Game status: ${gameData.status}. Score was: ${currentPlayer.score}`);
        currentPlayer.score = 0; // Score becomes 0 on bust for Dice Escalator if that's the rule, or just use .busted flag. For DE, usually just busted matters.
    } else {
        currentPlayer.score += diceValue;
        // Player's turn continues, they are still 'awaiting_roll_emoji' for their next decision (roll or stand)
        // Their status currentPlayer.status remains 'awaiting_roll_emoji'
        // gameData.status also needs to reflect it's still this player's general turn phase
        gameData.status = (playerKeyPrefix === 'p1') ? 'p1_awaiting_roll_emoji' : 'p2_awaiting_roll_emoji'; // Or a more general status if player status itself is checked by UI
        console.log(`${logPrefix} Player ${playerRefHTML} new score: ${currentPlayer.score}. Status: ${gameData.status}`);
    }
    activeGames.set(gameData.gameId, gameData); // Save changes (score, rolls, status)

    if (gameData.status.startsWith('game_over')) { // If busted
        await updateDiceEscalatorPvPMessage_New(gameData); // Show bust status on main board
        await sleep(1000); // Let user see bust message on main board
        await resolveDiceEscalatorPvPGame_New(gameData, currentPlayer.busted ? currentPlayer.userId : null);
    } else { // Not a bust, player's turn continues (they can roll again or stand)
        await updateDiceEscalatorPvPMessage_New(gameData); // Update UI, will show new score, and prompt for next action, resets timeout for the SAME player
    }
}
// --- END OF FULL REPLACEMENT for processDiceEscalatorPvPRollByEmoji_New function ---

async function updateDiceEscalatorPvPMessage_New(gameData) {
    if (!gameData || !bot) return;
    const logPrefix = `[UpdateDE_PvP_V2_Timeout GID:${gameData.gameId}]`;

    if (gameData.currentMessageId && bot) {
        await bot.deleteMessage(gameData.chatId, Number(gameData.currentMessageId)).catch(e => {});
        gameData.currentMessageId = null;
    }
    if (gameData.currentTurnTimeoutId) {
        clearTimeout(gameData.currentTurnTimeoutId);
        gameData.currentTurnTimeoutId = null;
    }
    activeGames.set(gameData.gameId, gameData); 

    const messageTextHTML = await formatDiceEscalatorGameMessage_New(gameData);
    let keyboard = { inline_keyboard: [] };
    const activePlayer = gameData.initiator.isTurn ? gameData.initiator : (gameData.opponent.isTurn ? gameData.opponent : null);

    if (activePlayer && !activePlayer.stood && !activePlayer.busted && activePlayer.status === 'awaiting_roll_emoji') {
        keyboard.inline_keyboard.push([{ text: `✋ ${escapeHTML(activePlayer.displayName)}, Stand!`, callback_data: `de_stand_pvp:${gameData.gameId}` }]);
    }
    keyboard.inline_keyboard.push([{ text: "📖 Game Rules", callback_data: `${RULES_CALLBACK_PREFIX_CONST}${GAME_IDS.DICE_ESCALATOR_UNIFIED_OFFER}` }]);

    const sentMessage = await safeSendMessage(gameData.chatId, messageTextHTML, { parse_mode: 'HTML', reply_markup: keyboard });
    if (sentMessage?.message_id) {
        gameData.currentMessageId = String(sentMessage.message_id);
        if (activePlayer && activePlayer.status === 'awaiting_roll_emoji' && !gameData.status.startsWith('game_over_')) {
            const timedOutPlayerId = activePlayer.userId;
            gameData.currentTurnTimeoutId = setTimeout(() => {
                handleDiceEscalatorPvPTurnTimeout(gameData.gameId, timedOutPlayerId);
            }, ACTIVE_GAME_TURN_TIMEOUT_MS);
            console.log(`${logPrefix} Set turn timeout ${gameData.currentTurnTimeoutId} for player ${timedOutPlayerId} in ${gameData.gameId}`);
        }
    } else {
        console.error(`${logPrefix} CRITICAL: Failed to send/update PvP game message for ${gameData.gameId}.`);
    }
    if(activeGames.has(gameData.gameId)) activeGames.set(gameData.gameId, gameData);
}

// --- START OF FULL REPLACEMENT for handleDiceEscalatorPvPStand_New function ---
async function handleDiceEscalatorPvPStand_New(gameId, userWhoClicked, originalMessageId, callbackQueryId, chatData) {
    const userIdWhoStood = String(userWhoClicked.telegram_id || userWhoClicked.id);
    const logPrefix = `[DE_PvP_Stand_V2_Timeout GID:${gameId} UID:${userIdWhoStood}]`;
    let gameData = activeGames.get(gameId);

    if (!gameData || gameData.type !== GAME_IDS.DICE_ESCALATOR_PVP) {
        if(callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "Game not found or invalid.", show_alert: true }).catch(()=>{});
        return;
    }
    // Ensure gameData is the authoritative version from activeGames map
    gameData = activeGames.get(gameId); 
    if (!gameData) { // Re-check after fetching, in case it was deleted by a concurrent process
        if(callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "Game data unavailable.", show_alert: true }).catch(()=>{});
        return;
    }


    let playerStanding, otherPlayer, playerKeyStanding;
    if (gameData.initiator.userId === userIdWhoStood && gameData.initiator.isTurn) {
        playerStanding = gameData.initiator; otherPlayer = gameData.opponent; playerKeyStanding = 'p1';
    } else if (gameData.opponent.userId === userIdWhoStood && gameData.opponent.isTurn) {
        playerStanding = gameData.opponent; otherPlayer = gameData.initiator; playerKeyStanding = 'p2';
    } else {
        if(callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, {text:"Not your turn to stand!", show_alert:true}).catch(()=>{});
        return;
    }

    if (playerStanding.stood || playerStanding.busted || playerStanding.status !== 'awaiting_roll_emoji') {
        if(callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, {text:"Cannot stand now (already stood/bust or invalid state).", show_alert:true}).catch(()=>{});
        return;
    }

    // Clear current turn timeout as player has made an action
    if (gameData.currentTurnTimeoutId) {
        clearTimeout(gameData.currentTurnTimeoutId);
        gameData.currentTurnTimeoutId = null;
        console.log(`${logPrefix} Cleared existing turn timeout for player ${userIdWhoStood} upon standing.`);
    }

    if(callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, {text: `You stand with ${playerStanding.score} points!`}).catch(()=>{});

    playerStanding.stood = true;
    playerStanding.isTurn = false;
    playerStanding.status = 'stood'; // Player specific status
    gameData.lastInteractionTime = Date.now();

    const playerStandingMentionHTML = escapeHTML(playerStanding.displayName);
    // This temporary message is good for immediate feedback
    const tempStandMsg = await safeSendMessage(gameData.chatId, `✋ <b>${playerStandingMentionHTML}</b> stands with a score of <b>${escapeHTML(String(playerStanding.score))}</b>!`, {parse_mode:'HTML'});
     if (tempStandMsg?.message_id && activeGames.has(gameData.gameId)) {
        const currentGd = activeGames.get(gameData.gameId);
        if(currentGd) {
             currentGd.intermediateMessageIds = [...(currentGd.intermediateMessageIds || []), tempStandMsg.message_id];
        }
    }
    await sleep(1000); // Allow user to see stand acknowledgement

    // Determine next game state
    if (playerKeyStanding === 'p1') { // Initiator (P1) stood
        if (otherPlayer.busted || otherPlayer.stood || otherPlayer.status === 'timeout_forfeit') { // If Opponent (P2) already finished their turn (or forfeited)
            gameData.status = 'game_over_pvp_resolved'; // Both players done, resolve game
        } else { // Opponent (P2) still needs to play or continue playing
            otherPlayer.isTurn = true;
            otherPlayer.status = 'awaiting_roll_emoji';
            otherPlayer.diceRolledThisTurn = 0; // Reset for their turn if they haven't rolled yet
            gameData.status = 'p2_awaiting_roll_emoji'; // General game status indicates P2's turn
            console.log(`${logPrefix} ${playerStandingMentionHTML} stood. Transitioning to ${otherPlayer.displayName}'s turn.`);
        }
    } else { // Opponent (P2) stood
        // If P2 stands, P1 must have already stood, busted or forfeited. Game resolves.
        gameData.status = 'game_over_pvp_resolved';
        console.log(`${logPrefix} ${playerStandingMentionHTML} stood. Both players' turns are complete or resolved. Game over.`);
    }
    activeGames.set(gameData.gameId, gameData); // Save changes

    if (gameData.status.startsWith('game_over')) {
        await updateDiceEscalatorPvPMessage_New(gameData); // Show final state before full resolution message
        await sleep(1000);
        await resolveDiceEscalatorPvPGame_New(gameData);
    } else {
        // If it's now the other player's turn
        await updateDiceEscalatorPvPMessage_New(gameData); // Update UI for next player's turn & set their timeout
    }
}
// --- END OF FULL REPLACEMENT for handleDiceEscalatorPvPStand_New function ---
// CORRECTED resolveDiceEscalatorPvPGame_New (with Deadlock and Referral Fixes)
async function resolveDiceEscalatorPvPGame_New(gameData, playerWhoForfeitedId = null) {
    const logPrefix = `[DE_PvP_Resolve_V7_FullFix GID:${gameData.gameId || 'UNKNOWN_GAME_ID'}]`;
    let allNotificationsToSend = [];

    let solPrice;
    try {
        solPrice = await getSolUsdPrice();
    } catch (priceError) {
        console.error(`${logPrefix} CRITICAL: Could not get SOL price. Level-up/milestone checks will be skipped. Error: ${priceError.message}`);
        solPrice = 0;
    }

    if (gameData.currentTurnTimeoutId) {
        clearTimeout(gameData.currentTurnTimeoutId);
        gameData.currentTurnTimeoutId = null;
    }

    activeGames.delete(gameData.gameId);
    if (gameData.chatType && gameData.chatType !== 'private') {
        await updateGroupGameDetails(gameData.chatId, { removeThisId: gameData.gameId }, gameData._origin_key_for_limits || GAME_IDS.DICE_ESCALATOR_PVP, null);
    }
    
    const p1 = gameData.initiator;
    const p2 = gameData.opponent;
    const p1MentionHTML = escapeHTML(p1.displayName);
    const p2MentionHTML = escapeHTML(p2.displayName);
    let winner = null, loser = null, isPush = false, titleEmoji = "⚔️", resultHeaderHTML = "", outcomeDetails = "", winningsFooterHTML = "";
    const totalPotLamports = gameData.betAmount * 2n;
    let p1Payout = 0n;
    let p2Payout = 0n;
    let p1LedgerCode = 'loss_de_pvp';
    let p2LedgerCode = 'loss_de_pvp';
    let gameOutcomeTextForLog = "";
    const betDisplayUSD_HTML_Resolve = escapeHTML(await formatBalanceForDisplay(gameData.betAmount, 'USD'));
    let isConclusiveOutcome = false;

    if (p1.busted) {
        isConclusiveOutcome = true;
        titleEmoji = "💥"; winner = p2; loser = p1; p2Payout = totalPotLamports;
        p2LedgerCode = 'win_de_pvp_opponent_bust'; p1LedgerCode = 'loss_de_pvp_bust';
        resultHeaderHTML = `💣 <b>${p1MentionHTML} BUSTED!</b> (Rolled a ${DICE_ESCALATOR_BUST_ON})`;
        outcomeDetails = `${p2MentionHTML} seizes victory!`;
        gameOutcomeTextForLog = `P2 wins by P1 bust`;
    } else if (p2.busted) {
        isConclusiveOutcome = true;
        titleEmoji = "💥"; winner = p1; loser = p2; p1Payout = totalPotLamports;
        p1LedgerCode = 'win_de_pvp_opponent_bust'; p2LedgerCode = 'loss_de_pvp_bust';
        resultHeaderHTML = `💣 <b>${p2MentionHTML} BUSTED!</b> (Rolled a ${DICE_ESCALATOR_BUST_ON})`;
        outcomeDetails = `${p1MentionHTML} masterfully claims the win!`;
        gameOutcomeTextForLog = `P1 wins by P2 bust`;
    } else if (gameData.status === 'game_over_p1_timeout_forfeit' || (playerWhoForfeitedId && playerWhoForfeitedId === p1.userId)) {
        isConclusiveOutcome = true;
        titleEmoji = "⏳"; winner = p2; loser = p1; p2Payout = totalPotLamports;
        p2LedgerCode = 'win_de_pvp_opponent_forfeit'; p1LedgerCode = 'loss_de_pvp_self_forfeit';
        resultHeaderHTML = `⏳ <b>${p1MentionHTML} Forfeited (Timeout)!</b>`;
        outcomeDetails = `${p2MentionHTML} wins by default!`;
        if (p1.status !== 'timeout_forfeit') p1.status = 'timeout_forfeit';
        gameOutcomeTextForLog = `P2 wins by P1 forfeit`;
    } else if (gameData.status === 'game_over_p2_timeout_forfeit' || (playerWhoForfeitedId && playerWhoForfeitedId === p2.userId)) {
        isConclusiveOutcome = true;
        titleEmoji = "⏳"; winner = p1; loser = p2; p1Payout = totalPotLamports;
        p1LedgerCode = 'win_de_pvp_opponent_forfeit'; p2LedgerCode = 'loss_de_pvp_self_forfeit';
        resultHeaderHTML = `⏳ <b>${p2MentionHTML} Forfeited (Timeout)!</b>`;
        outcomeDetails = `${p1MentionHTML} wins by default!`;
        if (p2.status !== 'timeout_forfeit') p2.status = 'timeout_forfeit';
        gameOutcomeTextForLog = `P1 wins by P2 forfeit`;
    } else if (p1.stood && p2.stood) {
        if (p1.score > p2.score) {
            isConclusiveOutcome = true;
            titleEmoji = "🏆"; winner = p1; loser = p2; p1Payout = totalPotLamports;
            p1LedgerCode = 'win_de_pvp_score';
            resultHeaderHTML = `🏆 <b>${p1MentionHTML} WINS!</b>`;
            outcomeDetails = `Their score of <b>${p1.score}</b> beats ${p2MentionHTML}'s <i>${p2.score}</i>.`;
            gameOutcomeTextForLog = `P1 wins by score (${p1.score} vs ${p2.score})`;
        } else if (p2.score > p1.score) {
            isConclusiveOutcome = true;
            titleEmoji = "🏆"; winner = p2; loser = p1; p2Payout = totalPotLamports;
            p2LedgerCode = 'win_de_pvp_score';
            resultHeaderHTML = `🏆 <b>${p2MentionHTML} WINS!</b>`;
            outcomeDetails = `Their score of <b>${p2.score}</b> beats ${p1MentionHTML}'s <i>${p1.score}</i>.`;
            gameOutcomeTextForLog = `P2 wins by score (${p2.score} vs ${p1.score})`;
        } else { // Scores are equal
            isConclusiveOutcome = false; // A push does not trigger wager bonuses
            titleEmoji = "⚖️"; isPush = true;
            resultHeaderHTML = `⚖️ <b>IT'S A DRAW!</b>`;
            outcomeDetails = `Both players stood with <b>${p1.score}</b> points.`;
            p1Payout = gameData.betAmount; p2Payout = gameData.betAmount;
            p1LedgerCode = 'push_de_pvp'; p2LedgerCode = 'push_de_pvp';
            gameOutcomeTextForLog = `Push (Draw at ${p1.score})`;
        }
    } else { 
        isConclusiveOutcome = false;
        titleEmoji = "⚙️"; isPush = true; 
        resultHeaderHTML = `⚙️ <b>Unexpected Game End</b>`; 
        outcomeDetails = `The game concluded unexpectedly. Bets refunded. P1 Status: ${p1.status}, P2 Status: ${p2.status}, Game: ${gameData.status}`;
        p1Payout = gameData.betAmount; p2Payout = gameData.betAmount;
        p1LedgerCode = 'refund_de_pvp_error'; p2LedgerCode = 'refund_de_pvp_error';
        gameOutcomeTextForLog = `Error - bets refunded (P1: ${p1.status}, P2: ${p2.status}, Game: ${gameData.status})`;
        console.warn(`${logPrefix} Undetermined DE PvP outcome for GID ${gameData.gameId}. Refunding. P1 Status: ${p1.status}, P2 Status: ${p2.status}, Game Status: ${gameData.status}`);
    }

    if (winner) {
        winningsFooterHTML = `🎉 <b>${escapeHTML(winner.displayName)}</b> wins the pot of <b>${escapeHTML(await formatBalanceForDisplay(totalPotLamports, 'USD'))}</b>!`;
    } else if (isPush) {
        winningsFooterHTML = `💰 Wagers of <b>${betDisplayUSD_HTML_Resolve}</b> each are returned.`;
    }

    const getPlayerStatusDisplay = (player) => {
        if (player.busted) return `💥 BUSTED! (Rolled ${DICE_ESCALATOR_BUST_ON})`;
        if (player.status === 'stood') return `✅ Stood at ${player.score}`;
        if (player.status === 'timeout_forfeit') return `⏳ Forfeited`;
        if (player.status === 'win_by_opponent_timeout' || player.status === 'win_by_opponent_bust') return `🏆 Winner! (${player.score})`;
        return `${player.score}`;
    };

    const finalMessageHTML = `${titleEmoji} <b>Dice Escalator PvP - Result!</b> ${titleEmoji}\n\n` +
        `<i>${p1MentionHTML} vs ${p2MentionHTML}</i>\n` +
        `Wager: <b>${betDisplayUSD_HTML_Resolve}</b> each\n\n` +
        `--- <b>Final Scores & Rolls</b> ---\n` +
        `👤 ${p1MentionHTML} (P1): ${formatDiceRolls(p1.rolls)} ➠ ${getPlayerStatusDisplay(p1)}\n` +
        `👤 ${p2MentionHTML} (P2): ${formatDiceRolls(p2.rolls)} ➠ ${getPlayerStatusDisplay(p2)}\n\n` +
        `------------------------------------\n` +
        `${resultHeaderHTML}\n${outcomeDetails}\n\n${winningsFooterHTML}`;

    let client = null;
    try {
        client = await pool.connect();
        await client.query('BEGIN');

        const actualGameLogId = await logGameResultToGamesTable(
            client,
            gameData._origin_key_for_limits || GAME_IDS.DICE_ESCALATOR_PVP,
            gameData.chatId,
            p1.userId,
            [p1.userId, p2.userId],
            gameData.betAmount,
            gameOutcomeTextForLog,
            0n
        );

        // --- DEADLOCK PREVENTION: Sort players by ID before locking/updating ---
        const [playerA, playerB] = [p1, p2].sort((a, b) => String(a.userId).localeCompare(String(b.userId)));
        console.log(`${logPrefix} Locking order established. Player A: ${playerA.userId}, Player B: ${playerB.userId}`);

        const payoutA = (playerA.userId === p1.userId) ? p1Payout : p2Payout;
        const payoutB = (playerB.userId === p1.userId) ? p1Payout : p2Payout;
        const ledgerCodeA = (playerA.userId === p1.userId) ? p1LedgerCode : p2LedgerCode;
        const ledgerCodeB = (playerB.userId === p1.userId) ? p1LedgerCode : p2LedgerCode;

        // Process Player A first
        const p1Upd = await updateUserBalanceAndLedger(client, playerA.userId, payoutA, ledgerCodeA, { game_log_id: actualGameLogId, opponent_id_custom_field: playerB.userId, player_score: playerA.score, opponent_score: playerB.score, original_bet_amount: gameData.betAmount.toString() }, `DE PvP Result vs ${playerB.displayName || playerB.userId}`, solPrice);
        if(!p1Upd.success) throw new Error(`Player A (${playerA.userId}) update failed: ${p1Upd.error}`);
        if(p1Upd.notifications) allNotificationsToSend.push(...p1Upd.notifications);

        // Process Player B second
        const p2Upd = await updateUserBalanceAndLedger(client, playerB.userId, payoutB, ledgerCodeB, { game_log_id: actualGameLogId, opponent_id_custom_field: playerA.userId, player_score: playerB.score, opponent_score: playerA.score, original_bet_amount: gameData.betAmount.toString() }, `DE PvP Result vs ${playerA.displayName || playerA.userId}`, solPrice);
        if(!p2Upd.success) throw new Error(`Player B (${playerB.userId}) update failed: ${p2Upd.error}`);
        if(p2Upd.notifications) allNotificationsToSend.push(...p2Upd.notifications);
        
        if (isConclusiveOutcome) {
            // --- START OF MODIFICATION ---

            // 1. ADDED: Check initial bet bonus for both players.
            if (typeof processQualifyingBetAndInitialBonus === 'function') {
                await processQualifyingBetAndInitialBonus(client, p1.userId, gameData.betAmount, gameId);
                await processQualifyingBetAndInitialBonus(client, p2.userId, gameData.betAmount, gameId);
            }

            // 2. MODIFIED: Correctly call level and milestone checks for both players.
            if (p1Upd.success && p1Upd.newTotalWageredLamports !== undefined) {
                const p1LevelNotifications = await checkAndUpdateUserLevel(client, p1.userId, p1Upd.newTotalWageredLamports, solPrice, gameData.chatId);
                allNotificationsToSend.push(...p1LevelNotifications);
                const p1MilestoneResult = await processWagerMilestoneBonus(client, p1.userId, p1Upd.newTotalWageredLamports, solPrice);
                if (!p1MilestoneResult.success) console.warn(`${logPrefix} Failed to process milestone bonus for P1: ${p1MilestoneResult.error}`);
            }
            if (p2Upd.success && p2Upd.newTotalWageredLamports !== undefined) {
                const p2LevelNotifications = await checkAndUpdateUserLevel(client, p2.userId, p2Upd.newTotalWageredLamports, solPrice, gameData.chatId);
                allNotificationsToSend.push(...p2LevelNotifications);
                const p2MilestoneResult = await processWagerMilestoneBonus(client, p2.userId, p2Upd.newTotalWageredLamports, solPrice);
                if (!p2MilestoneResult.success) console.warn(`${logPrefix} Failed to process milestone bonus for P2: ${p2MilestoneResult.error}`);
            }

            // --- END OF MODIFICATION ---
        }
        
        await client.query('COMMIT');
    } catch (e) { 
        if (client) await client.query('ROLLBACK'); 
        const currentMsg = finalMessageHTML; 
        const dbErrorText = `\n\n⚠️ <i>Error settling wagers. Admin notified.</i>`;
        const finalMessageTextHTMLWithError = currentMsg + dbErrorText; 
        console.error(`${logPrefix} CRITICAL DB Error: ${e.message}`);
        if (typeof notifyAdmin === 'function') notifyAdmin(`🚨 CRITICAL DE PvP Payout Failure 🚨\nGame ID: <code>${escapeHTML(gameData.gameId)}</code>\nWinner: ${winner?.displayName || 'N/A'}\nLoser: ${loser?.displayName || 'N/A'}\nError: ${escapeHTML(e.message)}. Manual check required.`, { parse_mode: 'HTML' });
        if (gameData.currentMessageId && bot) await bot.deleteMessage(String(gameData.chatId), Number(gameData.currentMessageId)).catch(()=>{});
        const finalKeyboardError = createPostGameKeyboard(GAME_IDS.DICE_ESCALATOR_PVP, gameData.betAmount);
        await safeSendMessage(String(gameData.chatId), finalMessageTextHTMLWithError, { parse_mode: 'HTML', reply_markup: finalKeyboardError });
        return; 
    } finally { if (client) client.release(); }
    
    // Send all collected notifications AFTER the transaction is closed
    for (const notification of allNotificationsToSend) {
        if (notification.to === ADMIN_USER_ID && typeof notifyAdmin === 'function') {
            await notifyAdmin(notification.text, notification.options).catch(err => console.error(`Failed to send admin notification: ${err.message}`));
        } else {
            await safeSendMessage(notification.to, notification.text, notification.options).catch(err => console.error(`Failed to send game-related notification to ${notification.to}: ${err.message}`));
        }
    }

    if (gameData.currentMessageId && bot) {
        await bot.deleteMessage(String(gameData.chatId), Number(gameData.currentMessageId)).catch(() => {});
    }
    
    const finalKeyboardSuccess = createPostGameKeyboard(GAME_IDS.DICE_ESCALATOR_PVP, betAmount);
    await safeSendMessage(String(gameData.chatId), finalMessageHTML, { parse_mode: 'HTML', reply_markup: finalKeyboardSuccess });
}
// --- END OF FULL REPLACEMENT for resolveDiceEscalatorPvPGame_New function ---
// --- End of Part 5b, Section 1 (COMPLETE DICE ESCALATOR LOGIC - GRANULAR ACTIVE GAME LIMITS) ---
// --- Start of Part 5b, Section 2 (Dice 21 / Blackjack-style game logic) ---
// SEGMENT 1 of 2 (Message Handling V7: Immediate Deletion of Player's Hit/Stand Prompt on Hit - GRANULAR ACTIVE GAME LIMITS)
//-------------------------------------------------------------------------------------------------
// Assumed dependencies as before.

async function getSingleDiceRollViaHelper(gameId, chatIdForLog, userIdForRoll, rollPurposeNote, handlerType = null) {
    const logPrefix = `[GetSingleDiceRollHelper GID:${gameId} Purpose:"${rollPurposeNote}" UID:${userIdForRoll || 'BOT_INTERNAL'} HType:${handlerType || 'ANY'}]`;
    let client = null;
    let requestId = null;
    let specificErrorMessage = `Failed to obtain dice roll for "${rollPurposeNote}" via Helper Bot. Handler: ${handlerType || 'ANY'}.`;
    let isTimeoutErrorFlag = false;

    try {
        client = await pool.connect(); // Use a connection from the pool for the insert
        // Pass handlerType to insertDiceRollRequest
        const requestResult = await insertDiceRollRequest(client, gameId, String(chatIdForLog), userIdForRoll, '🎲', rollPurposeNote, handlerType);
        if (!requestResult.success || !requestResult.requestId) {
            specificErrorMessage = requestResult.error || `Database error when creating roll request for "${rollPurposeNote}" (Handler: ${handlerType}).`;
            console.error(`${logPrefix} ${specificErrorMessage}`);
            // Release client before throwing if acquired
            if(client) client.release();
            client = null;
            throw new Error(specificErrorMessage);
        }
        requestId = requestResult.requestId;
        client.release(); client = null; // Release client after successful insert

        let attempts = 0;
        while (attempts < DICE_ROLL_POLLING_MAX_ATTEMPTS) {
            await sleep(DICE_ROLL_POLLING_INTERVAL_MS);
            if (isShuttingDown) {
                specificErrorMessage = "System shutdown initiated while waiting for Helper Bot dice roll response.";
                console.warn(`${logPrefix} ${specificErrorMessage}`);
                throw new Error(specificErrorMessage);
            }

            client = await pool.connect(); // Get a new client for polling getDiceRollRequestResult
            const statusResult = await getDiceRollRequestResult(client, requestId); // Assumes getDiceRollRequestResult is defined elsewhere
            client.release(); client = null; // Release client after poll

            if (statusResult.success && statusResult.status === 'completed') {
                if (typeof statusResult.roll_value === 'number' && statusResult.roll_value >= 1 && statusResult.roll_value <= 6) {
                    return { roll: statusResult.roll_value, error: false };
                } else {
                    specificErrorMessage = `Helper Bot returned a completed roll for "${rollPurposeNote}" (Request ID: ${requestId}), but the dice value was invalid: '${statusResult.roll_value}'.`;
                    console.error(`${logPrefix} ${specificErrorMessage}`);
                    throw new Error(specificErrorMessage); // This will be caught by the outer catch
                }
            } else if (statusResult.success && statusResult.status === 'error') {
                specificErrorMessage = statusResult.notes || `Helper Bot explicitly reported an error for "${rollPurposeNote}" (Request ID: ${requestId}).`;
                console.error(`${logPrefix} ${specificErrorMessage}`);
                throw new Error(specificErrorMessage); // This will be caught by the outer catch
            }
            // If status is still 'pending' or unknown, continue loop
            attempts++;
        }

        isTimeoutErrorFlag = true; // If loop finishes, it's a timeout
        specificErrorMessage = `Timeout after ${attempts} attempts waiting for Helper Bot response for dice roll: "${rollPurposeNote}" (Request ID: ${requestId}). Handler: ${handlerType || 'ANY'}.`;
        throw new Error(specificErrorMessage);

    } catch (error) {
        // Ensure client is released if an error occurred at any point after it was acquired
        if (client) {
            client.release();
            client = null;
        }
        
        const finalErrorMessageForReturn = error.message || specificErrorMessage;
        console.error(`${logPrefix} Final error state in getSingleDiceRollViaHelper (Handler: ${handlerType || 'ANY'}): ${finalErrorMessageForReturn}`);
        
        if (requestId) { // If request was made, try to mark it as error/timeout in DB
            let markErrorClient = null;
            try {
                markErrorClient = await pool.connect();
                const statusToUpdate = isTimeoutErrorFlag ? 'timeout' : 'error';
                // Make sure notes concatenation is safe or limit length
                const noteUpdate = `MainBotPollErr: ${String(finalErrorMessageForReturn).substring(0,100)}`;
                await markErrorClient.query(
                    "UPDATE dice_roll_requests SET status=$1, notes=COALESCE(notes, '') || E'\\n' || $2 WHERE request_id=$3 AND status = 'pending'",
                    [statusToUpdate, noteUpdate, requestId]
                );
            } catch (dbMarkError) {
                console.error(`${logPrefix} CRITICAL: Failed to mark roll request ${requestId} as failed/timeout in DB from MainBot: ${dbMarkError.message}`);
            } finally {
                if (markErrorClient) markErrorClient.release();
            }
        }
        return { error: true, message: finalErrorMessageForReturn, isTimeout: isTimeoutErrorFlag };
    }
}

// --- Dice 21 Main Command Handler (UPDATED FOR LOCKS AND TIMEOUTS) ---
// --- START OF FULL REPLACEMENT for handleStartDice21Command function ---
async function handleStartDice21Command(msg, betAmountLamports, targetUsernameRaw = null, gameModeArg = null) {
    const userId = String(msg.from.id || msg.from.telegram_id);
    const chatId = String(msg.chat.id);
    const chatType = msg.chat.type;
    const logPrefix = `[D21_OfferOrDirect_V4_GranLimit UID:${userId} CH:${chatId} Type:${chatType}]`;

    const isDirectChallengeOfferAttempt = (targetUsernameRaw != null);
    // MODIFIED CALL to checkUserActiveGameLimit and NEW ERROR MESSAGE
    const activeUserGameCheck = await checkUserActiveGameLimit(userId, isDirectChallengeOfferAttempt, null); 
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = escapeHTML(getPlayerDisplayReference(msg.from));
        const blockingGameType = activeUserGameCheck.details.type;
        const cleanGameName = getCleanGameName(blockingGameType); // Using the new helper
        const alertMessage = `✨ ${userDisplayName}, you already have a pending offer or active game for <b>${escapeHTML(cleanGameName)}</b>. ✨`;
        await safeSendMessage(chatId, alertMessage, { parse_mode: 'HTML' });
        return;
    }
    // END OF MODIFICATION

    console.log(`${logPrefix} Command /d21 received. Bet: ${betAmountLamports}, TargetUser: ${targetUsernameRaw || 'None'}, GameModeArg: ${gameModeArg || 'None'}`);

    let initiatorUserObj = await getOrCreateUser(userId, msg.from.username, msg.from.first_name, msg.from.last_name);
    if (!initiatorUserObj) {
        await safeSendMessage(chatId, "Apologies, your player profile couldn't be accessed right now.<br>Please use the <code>/start</code> command with me first, and then try initiating the Dice 21 game again.", { parse_mode: 'HTML' });
        return;
    }
    const initiatorPlayerRefHTML = escapeHTML(getPlayerDisplayReference(initiatorUserObj));

    if (chatType === 'private') {
        await safeSendMessage(chatId, `🎲 Greetings, ${initiatorPlayerRefHTML}!<br><br>The Dice 21 game, including direct challenges, must be initiated in a <b>group chat</b>.<br>Please use <code>/d21 &lt;bet&gt; [@username]</code> there to start the action.`, { parse_mode: 'HTML' });
        return;
    }

    if (typeof betAmountLamports !== 'bigint' || betAmountLamports <= 0n) {
        await safeSendMessage(chatId, `🃏 Salutations, ${initiatorPlayerRefHTML}! To begin a game of Dice 21, please specify a valid positive bet amount using USD or SOL.<br>For example: <code>/d21 10</code> or <code>/d21 0.2 sol</code>.`, { parse_mode: 'HTML' });
        return;
    }
    const betDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(betAmountLamports, 'USD'));

    if (BigInt(initiatorUserObj.balance) < betAmountLamports) {
        const needed = betAmountLamports - BigInt(initiatorUserObj.balance);
        await safeSendMessage(chatId, `${initiatorPlayerRefHTML}, your casino balance is currently too low for a <b>${betDisplayUSD_HTML}</b> Dice 21 game.<br>You require approximately <b>${escapeHTML(await formatBalanceForDisplay(needed, 'USD'))}</b> more for this particular wager.`, {
            parse_mode: 'HTML',
            reply_markup: { inline_keyboard: [[{ text: "💰 Top Up Balance (DM)", callback_data: QUICK_DEPOSIT_CALLBACK_ACTION_CONST }]] }
        });
        return;
    }

    let targetUserObject = null;
    let isDirectChallenge = (targetUsernameRaw != null);

    if (isDirectChallenge) {
        targetUserObject = await findRecipientUser(targetUsernameRaw);
        if (!targetUserObject || !targetUserObject.telegram_id) {
            await safeSendMessage(chatId, `😕 Player ${escapeHTML(targetUsernameRaw)} not found. To make a general Dice 21 offer, use <code>/d21 ${escapeHTML(String(betAmountLamports/LAMPORTS_PER_SOL))}</code>.`, { parse_mode: 'HTML' });
            return;
        } else if (String(targetUserObject.telegram_id) === userId) {
            await safeSendMessage(chatId, `😅 You can't directly challenge yourself, ${initiatorPlayerRefHTML}! To make a general offer, use <code>/d21 ${escapeHTML(String(betAmountLamports/LAMPORTS_PER_SOL))}</code>.`, { parse_mode: 'HTML' });
            return;
        }
    }

    const gameSession = await getGroupSession(chatId, msg.chat.title || `Group Chat ${chatId}`);
    let offerActivityKeyForLock;
    let limit;

    if (isDirectChallenge) {
        offerActivityKeyForLock = GAME_IDS.DICE_21_DIRECT_CHALLENGE_OFFER; 
        const currentDirectChallenges = gameSession.activeGamesByTypeInGroup.get(offerActivityKeyForLock) || [];
        limit = GAME_ACTIVITY_LIMITS.DIRECT_CHALLENGES[offerActivityKeyForLock] || 1; 
        if (currentDirectChallenges.length >= limit) {
            await safeSendMessage(chatId, `⏳ ${initiatorPlayerRefHTML}, the limit of ${limit} concurrent direct Dice 21 challenge(s) in this group is active. Please wait.`, { parse_mode: 'HTML' });
            return;
        }
    } else { // Unified Offer
        offerActivityKeyForLock = GAME_IDS.DICE_21_UNIFIED_OFFER;
        const currentUnifiedOffers = gameSession.activeGamesByTypeInGroup.get(offerActivityKeyForLock) || [];
        limit = GAME_ACTIVITY_LIMITS.UNIFIED_OFFERS[GAME_IDS.DICE_21_UNIFIED_OFFER] || GAME_ACTIVITY_LIMITS.UNIFIED_OFFERS[GAME_IDS.DICE_21] || 1;
        if (currentUnifiedOffers.length >= limit) {
            await safeSendMessage(chatId, `⏳ ${initiatorPlayerRefHTML}, the limit of ${limit} concurrent Dice 21 offer(s) in this group is active. Please wait.`, { parse_mode: 'HTML' });
            return;
        }
    }

    let offerId;
    let offerData;
    let clientBetPlacement = null;
    let timeoutDuration;

    try {
        clientBetPlacement = await pool.connect();
        await clientBetPlacement.query('BEGIN');

        if (isDirectChallenge) {
            offerId = generateGameId(`dd21_${userId.slice(-3)}_${String(targetUserObject.telegram_id).slice(-3)}`);
            timeoutDuration = DIRECT_CHALLENGE_ACCEPT_TIMEOUT_MS;

            const betResultDirect = await updateUserBalanceAndLedger(clientBetPlacement, userId, BigInt(-betAmountLamports), 'bet_placed_d21_direct_challenge_offer', { custom_offer_id: offerId, opponent_id_custom_field: targetUserObject.telegram_id }, `Direct Dice 21 Challenge Offer to ${targetUserObject.username || targetUserObject.telegram_id}`);
            if (!betResultDirect.success) throw new Error(betResultDirect.error || "Failed to place your bet for the direct challenge.");
            initiatorUserObj.balance = betResultDirect.newBalanceLamports;

            const targetPlayerRefHTML = escapeHTML(getPlayerDisplayReference(targetUserObject));
            const groupChallengeTextHTML = `Hey ${targetPlayerRefHTML}❗\n\n${initiatorPlayerRefHTML} has challenged you to a game of <b>Dice 21 (Blackjack)</b> for <b>${betDisplayUSD_HTML}</b>! You have ${timeoutDuration / 1000} seconds to respond.`;
            const groupChallengeKeyboard = {
                inline_keyboard: [
                    [{ text: "✅ Accept Challenge", callback_data: `d21_direct_accept:${offerId}` }],
                    [{ text: "❌ Decline Challenge", callback_data: `d21_direct_decline:${offerId}` }],
                    [{ text: "🚫 Withdraw My Challenge", callback_data: `d21_direct_cancel:${offerId}` }]
                ]
            };
            const sentGroupMessage = await safeSendMessage(chatId, groupChallengeTextHTML, { parse_mode: 'HTML', reply_markup: groupChallengeKeyboard });
            if (!sentGroupMessage || !sentGroupMessage.message_id) throw new Error("Could not send the direct challenge message.");

            offerData = {
                type: GAME_IDS.DIRECT_PVP_CHALLENGE, offerId: offerId, gameId: offerId, initiatorId: userId,
                initiatorUserObj: initiatorUserObj, initiatorMentionHTML: initiatorPlayerRefHTML,
                targetUserId: String(targetUserObject.telegram_id), targetUserObj: targetUserObject, targetUserMentionHTML: targetPlayerRefHTML,
                betAmount: betAmountLamports, originalGroupId: chatId, offerMessageIdInGroup: String(sentGroupMessage.message_id),
                chatTitle: msg.chat.title || `Group Chat ${chatId}`, status: 'pending_direct_challenge_response',
                gameToStart: GAME_IDS.DICE_21_PVP,
                _offerKeyUsedForGroupLock: GAME_IDS.DICE_21_DIRECT_CHALLENGE_OFFER, 
                creationTime: Date.now(), timeoutId: null
            };
        } else { // Unified Offer
            offerId = generateGameId(GAME_IDS.DICE_21_UNIFIED_OFFER);
            timeoutDuration = UNIFIED_OFFER_TIMEOUT_MS;

            const betResultUnified = await updateUserBalanceAndLedger(clientBetPlacement, userId, BigInt(-betAmountLamports), 'bet_placed_d21_unified_offer', { custom_offer_id: offerId }, `Dice 21 Unified Offer`);
            if (!betResultUnified.success) throw new Error(betResultUnified.error || "Failed to place your bet for the unified offer.");
            initiatorUserObj.balance = betResultUnified.newBalanceLamports;

            const offerMessageTextHTML = `🎲 <b>Dice 21 Challenge by ${initiatorPlayerRefHTML}!</b> 🎲\n\n` +
                `${initiatorPlayerRefHTML} has thrown down the gauntlet for a thrilling game of Dice 21, with a hefty wager of <b>${betDisplayUSD_HTML}</b> on the line!\n\n` +
                `Will any brave challengers step up for a Player vs Player showdown?\n` +
                `Or will ${initiatorPlayerRefHTML} choose to battle wits with our expert Bot Dealer. This offer expires in ${timeoutDuration / 1000} seconds. Bet refunded on timeout.`;
            const offerKeyboard = {
                inline_keyboard: [
                    [{ text: "⚔️ Accept PvP Challenge!", callback_data: `d21_accept_pvp_challenge:${offerId}` }],
                    [{ text: "🤖 Play Against the Bot Dealer", callback_data: `d21_accept_bot_game:${offerId}` }],
                    [{ text: "🚫 Cancel This Offer (Initiator Only)", callback_data: `d21_cancel_unified_offer:${offerId}` }]
                ]
            };
            const sentOfferMessage = await safeSendMessage(chatId, offerMessageTextHTML, { parse_mode: 'HTML', reply_markup: offerKeyboard });
            if (!sentOfferMessage?.message_id) throw new Error("Could not send the unified offer message.");

            offerData = {
                type: GAME_IDS.DICE_21_UNIFIED_OFFER, gameId: offerId, chatId: String(chatId), chatType,
                initiatorId: userId, initiatorMention: initiatorPlayerRefHTML, 
                initiatorUserObj, betAmount: betAmountLamports, status: 'waiting_for_choice',
                creationTime: Date.now(), gameSetupMessageId: String(sentOfferMessage.message_id), timeoutId: null
            };
        }

        await clientBetPlacement.query('COMMIT');
        activeGames.set(offerId, offerData);
        await updateGroupGameDetails(chatId, offerId, offerActivityKeyForLock, betAmountLamports); 
        console.log(`${logPrefix} Offer ${offerId} (Type: ${offerData.type}, Group Lock Key: ${offerActivityKeyForLock}) created. Bet placed. Lock updated.`);

        offerData.timeoutId = setTimeout(async () => {
            const timedOutOffer = activeGames.get(offerId);
            if (timedOutOffer && (timedOutOffer.status === 'waiting_for_choice' || timedOutOffer.status === 'pending_direct_challenge_response')) {
                console.log(`${logPrefix} Offer ${offerId} (Type: ${timedOutOffer.type}) for Dice 21 has timed out.`);
                activeGames.delete(offerId);
                const keyForTimeoutRemoval = timedOutOffer._offerKeyUsedForGroupLock || offerActivityKeyForLock;
                await updateGroupGameDetails(chatId, { removeThisId: offerId }, keyForTimeoutRemoval, null);
                console.log(`${logPrefix} Cleared group lock for timed-out D21 offer ${offerId} using key ${keyForTimeoutRemoval}.`);


                let refundClientTimeout = null;
                try {
                    refundClientTimeout = await pool.connect();
                    await refundClientTimeout.query('BEGIN');
                    const refundReason = timedOutOffer.type === GAME_IDS.DIRECT_PVP_CHALLENGE ? 'direct_challenge_expired_unanswered' : 'unified_offer_expired_unanswered';
                    const refundNotes = `Refund for expired ${timedOutOffer.type === GAME_IDS.DIRECT_PVP_CHALLENGE ? 'direct Dice 21 challenge' : 'unified Dice 21 offer'} ${offerId}.`;
                    await updateUserBalanceAndLedger(refundClientTimeout, timedOutOffer.initiatorId, timedOutOffer.betAmount, `refund_d21_${refundReason}`, { custom_offer_id: offerId }, refundNotes);
                    await refundClientTimeout.query('COMMIT');
                } catch (e) {
                    if (refundClientTimeout) await refundClientTimeout.query('ROLLBACK').catch(() => {});
                    console.error(`${logPrefix} CRITICAL: Failed to refund initiator ${timedOutOffer.initiatorId} for timed out D21 offer ${offerId}: ${e.message}`);
                    if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL REFUND FAILURE for timed out D21 offer ${offerId}, Initiator: ${timedOutOffer.initiatorId}. Error: ${e.message}`);
                } finally {
                    if (refundClientTimeout) refundClientTimeout.release();
                }

                const messageIdToEdit = timedOutOffer.offerMessageIdInGroup || timedOutOffer.gameSetupMessageId;
                const currentBetDisplayHTML_Timeout = escapeHTML(await formatBalanceForDisplay(timedOutOffer.betAmount, 'USD'));
                const initiatorMentionForTimeout = timedOutOffer.initiatorMentionHTML || timedOutOffer.initiatorMention || escapeHTML(getPlayerDisplayReference(timedOutOffer.initiatorUserObj || {id: timedOutOffer.initiatorId}));
                const targetMentionForTimeout = timedOutOffer.targetUserMentionHTML || escapeHTML(getPlayerDisplayReference(timedOutOffer.targetUserObj || {}));

                const timeoutMessageHTML = timedOutOffer.type === GAME_IDS.DIRECT_PVP_CHALLENGE ?
                    `⏳ The Dice 21 challenge from ${initiatorMentionForTimeout} to ${targetMentionForTimeout} for <b>${currentBetDisplayHTML_Timeout}</b> has expired unanswered. Initiator's bet refunded.` :
                    `⏳ The Dice 21 offer by ${initiatorMentionForTimeout} for <b>${currentBetDisplayHTML_Timeout}</b> has expired unanswered. Initiator's bet refunded.`;

                if (messageIdToEdit && bot) {
                    await bot.editMessageText(timeoutMessageHTML, {
                        chat_id: String(chatId), message_id: Number(messageIdToEdit),
                        parse_mode: 'HTML', reply_markup: {}
                    }).catch(e => console.warn(`${logPrefix} Failed to edit expired D21 offer message ${messageIdToEdit}: ${e.message}`));
                }
            }
        }, timeoutDuration);
        activeGames.set(offerId, offerData); 

    } catch (error) {
        if (clientBetPlacement) await clientBetPlacement.query('ROLLBACK').catch(() => {});
        console.error(`${logPrefix} Error creating Dice 21 offer or placing bet: ${error.message}`);
        await safeSendMessage(chatId, `⚠️ Error creating your Dice 21 offer: ${escapeHTML(error.message)}. Please try again.`, { parse_mode: 'HTML' });
        if (offerId && activeGames.has(offerId)) {
            activeGames.delete(offerId);
            const keyForErrorCleanup = offerData?._offerKeyUsedForGroupLock || offerActivityKeyForLock;
            if(keyForErrorCleanup) await updateGroupGameDetails(chatId, { removeThisId: offerId }, keyForErrorCleanup, null);
        }
    } finally {
        if (clientBetPlacement) clientBetPlacement.release();
    }
}

// --- Callback Handlers for Unified Dice 21 Offer (UPDATED FOR LOCKS AND TIMEOUTS) ---
// --- START OF FULL REPLACEMENT for handleDice21AcceptBotGame function ---
async function handleDice21AcceptBotGame(offerId, initiatorUserObjFromCb, originalOfferMessageId, originalChatId, originalChatTypeFromRouter, callbackQueryId = null) {
    const initiatorId = String(initiatorUserObjFromCb.id || initiatorUserObjFromCb.telegram_id);
    const logPrefix = `[D21_AcceptBotCB_V3_GranLimit GID:${offerId} UID:${initiatorId}]`;
    const offerData = activeGames.get(offerId);
    const initiatorRefHTML = escapeHTML(getPlayerDisplayReference(initiatorUserObjFromCb));

    // --- NEW USER ACTIVE GAME LIMIT CHECK ---
    // Pass offerId as gameIdBeingActioned, as the user is actioning this specific offer.
    const activeUserGameCheck = await checkUserActiveGameLimit(initiatorId, false, offerId); 
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = initiatorRefHTML; // Already have this
        const blockingGameType = activeUserGameCheck.details.type;
        const cleanGameName = getCleanGameName(blockingGameType);
        let alertMessage = `✨ ${userDisplayName}, you're already in a game of ${escapeHTML(cleanGameName)}. ✨ Finish it first!`;
        alertMessage = alertMessage.substring(0, 200); // Telegram alert length limit

        if (callbackQueryId) {
            await bot.answerCallbackQuery(callbackQueryId, { text: alertMessage, show_alert: true }).catch(() => {});
        } else {
            // Fallback if no callbackQueryId (though less likely for this handler type)
            const fullAlertMessageForChat = `✨ ${userDisplayName}, you already have a pending offer or active game for <b>${escapeHTML(cleanGameName)}</b>. Please finish it before starting a new one. ✨`;
            await safeSendMessage(originalChatId, fullAlertMessageForChat, { parse_mode: 'HTML' });
        }
        return;
    }
    // --- END OF NEW USER ACTIVE GAME LIMIT CHECK ---

    if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId).catch(() => {}); // Answer basic callback quickly if not blocked

    if (!offerData || offerData.type !== GAME_IDS.DICE_21_UNIFIED_OFFER || offerData.status !== 'waiting_for_choice') {
        console.warn(`${logPrefix} ${initiatorRefHTML} tried to accept PvB for invalid D21 offer ${offerId}. Status: ${offerData?.status}, Type: ${offerData?.type}`);
        const msgIdToClear = offerData?.gameSetupMessageId || originalOfferMessageId;
        if (msgIdToClear && bot) {
            await bot.editMessageText("This Dice 21 offer is no longer active or has expired.", {
                chat_id: originalChatId, message_id: Number(msgIdToClear),
                parse_mode: 'HTML', reply_markup: {}
            }).catch(e => {});
        }
        return;
    }
    if (offerData.initiatorId !== initiatorId) {
        console.warn(`${logPrefix} User ${initiatorRefHTML} (ID: ${initiatorId}) tried to accept PvB for D21 offer by ${offerData.initiatorMention}. Denied.`);
        // No need to answer callback again if it was already answered, or if this is a secondary check
        return;
    }

    const gameSession = await getGroupSession(originalChatId);
    const activeGameKeyToCheck = GAME_IDS.DICE_21; 
    const currentActiveD21Games = gameSession.activeGamesByTypeInGroup.get(activeGameKeyToCheck) || [];
    const limitActive = GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[activeGameKeyToCheck] || 1;

    if (currentActiveD21Games.length >= limitActive) {
        // This message is for group limit, not personal limit, so it's different.
        await safeSendMessage(originalChatId, `⏳ Sorry ${initiatorRefHTML}, the max limit of ${limitActive} active Dice 21 game(s) in this group has been reached. Please wait.`, { parse_mode: 'HTML'});
        return;
    }

    if (offerData.timeoutId) clearTimeout(offerData.timeoutId);
    // Callback was answered above or by the limit check if it triggered.
    // If not answered yet and not blocked, can answer here.
    // However, the blocking check above for personal limit *will* answer if it blocks.
    // If personal limit passes, and group limit passes, then we proceed.

    console.log(`${logPrefix} Initiator ${offerData.initiatorMention || initiatorRefHTML} selected PvB from D21 offer ${offerId}.`);
    offerData.status = 'bot_game_accepted';
    activeGames.set(offerId, offerData); 

    await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.DICE_21_UNIFIED_OFFER, null);
    activeGames.delete(offerId); 

    await startDice21PvBGame(
        originalChatId,
        offerData.initiatorUserObj,
        offerData.betAmount,
        Number(offerData.gameSetupMessageId || originalOfferMessageId),
        false,
        null, 
        originalChatTypeFromRouter
    );
}
// --- END OF FULL REPLACEMENT for handleDice21AcceptBotGame function ---

// --- START OF FULL REPLACEMENT for handleDice21AcceptPvPChallenge function ---
async function handleDice21AcceptPvPChallenge(offerId, joinerUserObjFromCb, originalOfferMessageId, originalChatId, originalChatType, callbackQueryId = null) {
    const joinerId = String(joinerUserObjFromCb.id || joinerUserObjFromCb.telegram_id);
    const logPrefix = `[D21_AcceptPvPCB_V3_GranLimit GID:${offerId} JoinerID:${joinerId}]`;
    let offerData = activeGames.get(offerId);
    const joinerRefHTML = escapeHTML(getPlayerDisplayReference(joinerUserObjFromCb));

    // --- NEW USER ACTIVE GAME LIMIT CHECK ---
    // Pass offerId as gameIdBeingActioned, as the user is actioning this specific offer.
    const activeUserGameCheck = await checkUserActiveGameLimit(joinerId, false, offerId); 
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = joinerRefHTML; // Already have this
        const blockingGameType = activeUserGameCheck.details.type;
        const cleanGameName = getCleanGameName(blockingGameType);
        let alertMessage = `✨ ${userDisplayName}, you're already in a game of ${escapeHTML(cleanGameName)}. ✨ Finish it first!`;
        alertMessage = alertMessage.substring(0, 200); // Telegram alert length limit

        if (callbackQueryId) {
            await bot.answerCallbackQuery(callbackQueryId, { text: alertMessage, show_alert: true }).catch(() => {});
        } else {
            // Fallback if no callbackQueryId 
            const fullAlertMessageForChat = `✨ ${userDisplayName}, you already have a pending offer or active game for <b>${escapeHTML(cleanGameName)}</b>. Please finish it before starting a new one. ✨`;
            await safeSendMessage(originalChatId, fullAlertMessageForChat, { parse_mode: 'HTML' });
        }
        return;
    }
    // --- END OF NEW USER ACTIVE GAME LIMIT CHECK ---

    if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId).catch(() => {}); // Answer basic callback quickly if not blocked

    if (!offerData || offerData.type !== GAME_IDS.DICE_21_UNIFIED_OFFER || offerData.status !== 'waiting_for_choice') {
        const msgIdToClear = offerData?.gameSetupMessageId || originalOfferMessageId;
        if (msgIdToClear && bot) {
            await bot.editMessageText("This Dice 21 game offer has expired or is no longer available for PvP.", {
                chat_id: originalChatId, message_id: Number(msgIdToClear),
                parse_mode: 'HTML', reply_markup: {}
            }).catch(e => {});
        }
        return;
    }
    if (offerData.initiatorId === joinerId) {
        await safeSendMessage(originalChatId, `😅 ${joinerRefHTML}, you can't accept your own Dice 21 challenge!`, {parse_mode: 'HTML'});
        return;
    }

    const gameSession = await getGroupSession(originalChatId);
    const activeGameKeyToCheck = GAME_IDS.DICE_21_PVP_FROM_UNIFIED;
    const currentActiveD21Games = gameSession.activeGamesByTypeInGroup.get(activeGameKeyToCheck) || [];
    const limitActive = GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[activeGameKeyToCheck] || 1;

    if (currentActiveD21Games.length >= limitActive) {
        await safeSendMessage(originalChatId, `⏳ Sorry ${joinerRefHTML}, the max limit of ${limitActive} active Dice 21 PvP (from unified) game(s) in this group has been reached. Please wait.`, { parse_mode: 'HTML'});
        return;
    }

    const betAmount = offerData.betAmount;
    const betDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(betAmount, 'USD'));

    let currentJoinerUserObj = await getOrCreateUser(joinerId, joinerUserObjFromCb.username, joinerUserObjFromCb.first_name, joinerUserObjFromCb.last_name);
    if (!currentJoinerUserObj || BigInt(currentJoinerUserObj.balance) < betAmount) {
        await safeSendMessage(originalChatId, `${joinerRefHTML}, your balance is too low for this <b>${betDisplayUSD_HTML}</b> Dice 21 PvP. Top up!`, {
            parse_mode: 'HTML', reply_markup: { inline_keyboard: [[{ text: "💰 Add Funds (DM)", callback_data: QUICK_DEPOSIT_CALLBACK_ACTION_CONST }]] }
        });
        return;
    }
    let currentInitiatorUserObj = await getOrCreateUser(offerData.initiatorId);
    if (!currentInitiatorUserObj || BigInt(currentInitiatorUserObj.balance) < betAmount) {
        const initiatorMentionHTML_Fail = offerData.initiatorMention || escapeHTML(getPlayerDisplayReference(currentInitiatorUserObj || {telegram_id: offerData.initiatorId}));
        if (offerData.timeoutId) clearTimeout(offerData.timeoutId);
        activeGames.delete(offerId);
        await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.DICE_21_UNIFIED_OFFER, null);
        const cancelTextHTML = `The Dice 21 PvP offer from ${initiatorMentionHTML_Fail} (for <b>${betDisplayUSD_HTML}</b>) was auto-cancelled. Initiator has insufficient funds.`;
        const msgIdToEdit = offerData.gameSetupMessageId || originalOfferMessageId;
        if(msgIdToEdit && bot) await bot.editMessageText(cancelTextHTML, { chat_id: originalChatId, message_id: Number(msgIdToEdit), parse_mode: 'HTML', reply_markup: {} }).catch(async () => {await safeSendMessage(originalChatId, cancelTextHTML, {parse_mode: 'HTML'});});
        else { await safeSendMessage(originalChatId, cancelTextHTML, {parse_mode: 'HTML'});}
        return;
    }

    if (offerData.timeoutId) clearTimeout(offerData.timeoutId);
    offerData.status = 'pvp_accepted';
    activeGames.set(offerData.gameId, offerData); 

    const offerMessageIdToDelete = offerData.gameSetupMessageId || originalOfferMessageId;
    if (offerMessageIdToDelete && bot) {
        await bot.deleteMessage(originalChatId, Number(offerMessageIdToDelete)).catch(e => {});
    }

    let clientBet = null;
    const pvpGameId = generateGameId(GAME_IDS.DICE_21_PVP);
    try {
        clientBet = await pool.connect(); await clientBet.query('BEGIN');
        const joinBetRes = await updateUserBalanceAndLedger(clientBet, joinerId, BigInt(-betAmount), 'bet_placed_dice21_pvp_join', { game_id_custom_field: pvpGameId, opponent_id_custom_field: offerData.initiatorId }, `PvP Dice 21 Join vs ${offerData.initiatorMention}`);
        if (!joinBetRes.success) throw new Error(`Joiner (${joinerRefHTML}) bet failed: ${joinBetRes.error}`);
        currentJoinerUserObj.balance = joinBetRes.newBalanceLamports;
        await clientBet.query('COMMIT');

        await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.DICE_21_UNIFIED_OFFER, null);
        activeGames.delete(offerId); 

        await startDice21PvPInitialDeal(
            pvpGameId,
            currentInitiatorUserObj,
            currentJoinerUserObj,
            offerData.betAmount,
            originalChatId,
            originalChatType,
            null, 
            'unified_offer'
        );

    } catch (e) {
        if (clientBet) await clientBet.query('ROLLBACK').catch(()=>{});
        console.error(`${logPrefix} CRITICAL error creating D21 PvP game ${pvpGameId}: ${e.message}`);
        await safeSendMessage(originalChatId, `⚙️ Error starting Dice 21 PvP: \`${escapeHTML(e.message)}\`. Game cancelled.`, { parse_mode: 'HTML'});

        if(activeGames.has(offerId)) activeGames.delete(offerId); 
        const currentUnifiedOffersCheck = await getGroupSession(originalChatId);
        if (currentUnifiedOffersCheck.activeGamesByTypeInGroup.get(GAME_IDS.DICE_21_UNIFIED_OFFER)?.includes(offerId)){
             await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.DICE_21_UNIFIED_OFFER, null);
        }

        if (e.message.toLowerCase().includes("joiner bet failed")) {
            let refundClient = null;
            try {
                refundClient = await pool.connect(); await refundClient.query('BEGIN');
                await updateUserBalanceAndLedger(refundClient, offerData.initiatorId, offerData.betAmount, 'refund_d21_pvp_opponent_bet_fail', { custom_offer_id: offerId }, `Refund D21 offer ${offerId} due to joiner bet fail`);
                await refundClient.query('COMMIT');
            } catch (refErr) { if (refundClient) await refundClient.query('ROLLBACK'); console.error(`${logPrefix} CRITICAL REFUND FAILURE for initiator on D21 PvP joiner bet fail: ${refErr.message}`); }
            finally { if (refundClient) refundClient.release(); }
        }
        return;
    } finally {
        if (clientBet) clientBet.release();
    }
}
// --- END OF FULL REPLACEMENT for handleDice21AcceptPvPChallenge function ---

// --- START OF FULL REPLACEMENT for handleDice21CancelUnifiedOffer function ---
async function handleDice21CancelUnifiedOffer(offerId, initiatorUserObjFromCb, originalOfferMessageId, originalChatId, callbackQueryId = null) {
    const initiatorId = String(initiatorUserObjFromCb.id || initiatorUserObjFromCb.telegram_id);
    const logPrefix = `[D21_CancelOffer_V3_GranLimit GID:${offerId} UID:${initiatorId}]`;
    const offerData = activeGames.get(offerId);
    const initiatorRefHTML = escapeHTML(getPlayerDisplayReference(initiatorUserObjFromCb));

    if (!offerData || offerData.type !== GAME_IDS.DICE_21_UNIFIED_OFFER || offerData.status !== 'waiting_for_choice') {
        if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "This offer is no longer valid.", show_alert: false }).catch(() => {});
        return;
    }
    if (offerData.initiatorId !== initiatorId) {
        if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "Only the initiator can cancel.", show_alert: true }).catch(() => {});
        return;
    }

    if (offerData.timeoutId) clearTimeout(offerData.timeoutId);
    if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "Cancelling Dice 21 offer and refunding bet..." }).catch(() => {});

    activeGames.delete(offerId);
    // MODIFIED: Use the correct key for unified offer removal
    await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.DICE_21_UNIFIED_OFFER, null);

    let refundClient = null;
    try {
        refundClient = await pool.connect();
        await refundClient.query('BEGIN');
        await updateUserBalanceAndLedger(refundClient, initiatorId, offerData.betAmount, 'refund_d21_offer_cancelled', { custom_offer_id: offerId }, `Refund for cancelled Dice 21 unified offer ${offerId}`);
        await refundClient.query('COMMIT');
    } catch(e) {
        if(refundClient) await refundClient.query('ROLLBACK');
        console.error(`${logPrefix} CRITICAL: Failed to refund initiator ${initiatorId} for cancelled D21 offer ${offerId}: ${e.message}`);
        if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL REFUND FAILURE for D21 cancelled offer ${offerId}, Initiator: ${initiatorId}. Error: ${e.message}`);
    } finally {
        if(refundClient) refundClient.release();
    }

    const betDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(offerData.betAmount, 'USD'));
    const confirmationMessageHTML = `🚫 Offer Cancelled!\nThe Dice 21 challenge by ${initiatorRefHTML} for <b>${betDisplayUSD_HTML}</b> has been withdrawn. Bet refunded.`;
    const messageIdToEdit = Number(originalOfferMessageId || offerData.gameSetupMessageId);
    if (messageIdToEdit && bot) {
        await bot.editMessageText(confirmationMessageHTML, { chat_id: originalChatId, message_id: messageIdToEdit, parse_mode: 'HTML', reply_markup: {} }).catch(async () => {
            await safeSendMessage(originalChatId, confirmationMessageHTML, { parse_mode: 'HTML' });
        });
    } else {
        await safeSendMessage(originalChatId, confirmationMessageHTML, { parse_mode: 'HTML' });
    }
}
// --- END OF FULL REPLACEMENT for handleDice21CancelUnifiedOffer function ---

// --- REVISED Player vs. Bot (PvB) Dice 21 Game Logic (V7: Refined Player Hit & Bot Turn Messaging) ---
async function startDice21PvBGame(chatId, initiatorUserObj, betAmountLamports, originalCmdOrOfferMsgId, isPrivateChatStart = false, unifiedOfferIdIfAny = null, chatTypeFromCaller) {
    const userId = String(initiatorUserObj.telegram_id);
    const currentChatType = chatTypeFromCaller || (isPrivateChatStart ? 'private' : 'group');
    const logPrefix = `[D21_PvB_Start_V9_GranLimit UID:${userId} CH:${chatId}]`; // V9
    
    // Key for active PvB D21 games
    const activeGameActivityKey = GAME_IDS.DICE_21; 

    const playerRefHTML = escapeHTML(getPlayerDisplayReference(initiatorUserObj));
    const betDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(betAmountLamports, 'USD'));

    if (unifiedOfferIdIfAny && originalCmdOrOfferMsgId && bot && currentChatType !== 'private') {
        await bot.deleteMessage(chatId, Number(originalCmdOrOfferMsgId)).catch(e => {});
    } else if (originalCmdOrOfferMsgId && bot && (isPrivateChatStart || chatId === userId)) { // If command was in DM
        await bot.deleteMessage(chatId, Number(originalCmdOrOfferMsgId)).catch(() => {});
    }

    let client = null;
    const gameIdForActivePvB = generateGameId(GAME_IDS.DICE_21); // Use base ID for PvB game object type

    try {
        // Bet is assumed to be already deducted if coming from an offer.
        // If this function is called for a "Play Again" (not currently implemented by play_again buttons),
        // bet deduction would need to happen here or be passed as confirmed.
        console.log(`${logPrefix} Bet of ${betAmountLamports} for user ${userId} assumed to be already deducted (from offer).`);

        const gameDataPvB = {
            type: GAME_IDS.DICE_21, // General type for the active game object
            gameId: gameIdForActivePvB, 
            chatId: String(chatId),
            chatType: currentChatType,
            playerId: userId, 
            playerRef: playerRefHTML,
            userObj: initiatorUserObj, 
            betAmount: betAmountLamports,
            playerScore: 0, botScore: 0, playerHandRolls: [], botHandRolls: [],
            status: 'player_initial_roll_1_prompted',
            gameMessageId: null,
            intermediateMessageIds: [],
            lastInteractionTime: Date.now(),
            turnTimeoutId: null 
        };
        activeGames.set(gameIdForActivePvB, gameDataPvB);

        if (currentChatType !== 'private') {
            // Use specific key for active PvB D21 games in group lock
            await updateGroupGameDetails(chatId, gameIdForActivePvB, activeGameActivityKey, betAmountLamports);
        }
        // Ensure the unified offer object is deleted if this game started from one
        if (unifiedOfferIdIfAny && activeGames.has(unifiedOfferIdIfAny)) { 
            activeGames.delete(unifiedOfferIdIfAny);
        }

        const titleHTML = `🎲 <b>Dice 21 vs. Bot Dealer</b> 🎲`;
        const initialPromptTextHTML = `${titleHTML}\n\n` +
            `Player: ${playerRefHTML}\n` +
            `Wager: <b>${betDisplayUSD_HTML}</b>\n\n` +
            `It's your turn, ${playerRefHTML}!\n` +
            `Please send your <b>first</b> 🎲 dice emoji to roll. (Turn timeout: ${ACTIVE_GAME_TURN_TIMEOUT_MS / 1000}s)`;

        const initialPromptMsg = await safeSendMessage(chatId, initialPromptTextHTML, { parse_mode: 'HTML' });
        if (initialPromptMsg?.message_id) {
            const gd = activeGames.get(gameIdForActivePvB);
            if (gd) {
                gd.gameMessageId = initialPromptMsg.message_id;
                gd.turnTimeoutId = setTimeout(() => {
                    if(typeof handleDice21PvBTurnTimeout === 'function') handleDice21PvBTurnTimeout(gameIdForActivePvB);
                    else console.error(`${logPrefix} handleDice21PvBTurnTimeout not defined!`);
                }, ACTIVE_GAME_TURN_TIMEOUT_MS);
                activeGames.set(gameIdForActivePvB, gd); 
                console.log(`${logPrefix} Game ${gameIdForActivePvB} started. Player prompted for 1st die. Timeout set.`);
            }
        } else {
            throw new Error("Failed to send initial prompt message for Dice 21. Cannot track game UI.");
        }
    } catch (error) {
        console.error(`${logPrefix} Error starting Dice 21 PvB game: ${error.message}`);
        const finalUserErrorMessageText = `⚙️ <b>Game Setup Error</b>\n${playerRefHTML}, we hit a snag setting up your Dice 21 game for <b>${betDisplayUSD_HTML}</b>.\nDetails: <code>${escapeHTML(error.message || "Unknown setup error")}</code>\nYour bet was placed. Please contact support if the game doesn't resolve or if you need a refund.`;
        await safeSendMessage(userId, finalUserErrorMessageText, { parse_mode: 'HTML' }); 

        activeGames.delete(gameIdForActivePvB); // Delete if created
        if (currentChatType !== 'private') {
            await updateGroupGameDetails(chatId, { removeThisId: gameIdForActivePvB }, activeGameActivityKey, null); // Clear group lock
        }
        if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL D21 PvB START ERROR: User ${userId}, Game ${gameIdForActivePvB}, Bet ${betAmountLamports}. Error: ${error.message}. Bet was likely taken. Manual check possibly needed.`);
    } finally {
        if (client) client.release(); // client was not used in this version of startDice21PvBGame if bet is pre-deducted
    }
}
// END OF SEGMENT 1 of 2 for "Part 5b, Section 2"
// --- Start of Part 5b, Section 2 (Dice 21 / Blackjack-style game logic) ---
// SEGMENT 2 of 2 (PvB Continued, PvP Functions MODIFIED FOR HTML DISPLAY, TIMEOUTS, & GRANULAR ACTIVE GAME LIMITS)
//-------------------------------------------------------------------------------------------------
// (Continues from Segment 1 of 2)

// --- Player vs. Bot (PvB) Dice 21 Gameplay Logic (Continued) ---

// --- START OF NEW updateDice21PvBMessage function ---
async function updateDice21PvBMessage(gameData, interimStatusMessageHTML = null) {
    // Ensure gameData is the actual reference from activeGames map
    const activeGameData = activeGames.get(gameData.gameId);
    if (!activeGameData) {
        console.warn(`[UpdateD21PvBMsg] Game GID:${gameData.gameId} no longer active. Cannot update message.`);
        return;
    }
    // Use the active reference for all modifications
    gameData = activeGameData;

    const logPrefix = `[UpdateD21PvBMsg GID:${gameData.gameId} Status:${gameData.status}]`;
    console.log(`${logPrefix} Updating D21 PvB game message. Interim: ${!!interimStatusMessageHTML}`);

    // Clear any previous turn timeout if one was set by this function
    if (gameData.turnTimeoutId) {
        clearTimeout(gameData.turnTimeoutId);
        gameData.turnTimeoutId = null;
    }

    // Delete previous intermediate messages if any (e.g., individual roll announcements)
    if (gameData.intermediateMessageIds && gameData.intermediateMessageIds.length > 0) {
        for (const mid of gameData.intermediateMessageIds) {
            if (bot && mid) await bot.deleteMessage(String(gameData.chatId), Number(mid)).catch(() => {});
        }
        gameData.intermediateMessageIds = []; // Clear after attempting deletion
    }

    // Delete the old main game message
    if (gameData.gameMessageId && bot) {
        await bot.deleteMessage(String(gameData.chatId), Number(gameData.gameMessageId)).catch(e => {
            if (e.code !== 'ETELEGRAM' || (e.response && e.response.body &&
                !(e.response.body.description?.includes("message to delete not found") ||
                  e.response.body.description?.includes("message can't be deleted")))) {
                console.warn(`${logPrefix} Non-critical: Failed to delete previous main game message ID ${gameData.gameMessageId}: ${e.message}`);
            }
        });
        gameData.gameMessageId = null; // Mark as deleted
    }

    const playerRefHTML = gameData.playerRef || escapeHTML(getPlayerDisplayReference(gameData.userObj || { id: gameData.playerId }));
    const betDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(gameData.betAmount, 'USD'));
    let titleHTML = `🎲 <b>Dice 21 vs. Bot Dealer</b> 🎲`;
    let messageTextHTML = `${titleHTML}\n\n` +
        `Player: ${playerRefHTML}\n` +
        `Wager: <b>${betDisplayUSD_HTML}</b>\n\n` +
        `Your Hand: ${formatDiceRolls(gameData.playerHandRolls)} Score: <b>${gameData.playerScore}</b>\n`;

    // Bot's hand display (partially hidden or fully shown based on state)
    let botHandDisplay = "";
    if (gameData.status === 'player_blackjack' || gameData.status === 'bot_rolling' || gameData.status === 'game_over_bot_played' || gameData.status.startsWith('game_over_')) {
        // Show full bot hand if player has blackjack, bot is playing, or game is over
        botHandDisplay = formatDiceRolls(gameData.botHandRolls);
    } else if (gameData.botHandRolls.length > 0) {
        // Show only first card of bot if game is ongoing and bot isn't actively playing yet
        botHandDisplay = `${formatDiceRolls([gameData.botHandRolls[0]])} ${TILE_EMOJI_HIDDEN}`;
    } else {
        botHandDisplay = `${TILE_EMOJI_HIDDEN} ${TILE_EMOJI_HIDDEN}`; // Both hidden initially
    }
    messageTextHTML += `Bot Dealer's Hand: ${botHandDisplay} Score: ${gameData.status === 'player_blackjack' || gameData.status === 'bot_rolling' || gameData.status.startsWith('game_over_') ? `<b>${gameData.botScore}</b>` : `<b>?</b>`}\n\n`;

    if (interimStatusMessageHTML) {
        messageTextHTML += `${interimStatusMessageHTML}\n\n`;
    }

    const keyboardRows = [];
    let promptActionText = "";

    switch (gameData.status) {
        case 'player_initial_roll_1_prompted':
            promptActionText = `Please send your <b>first</b> 🎲 dice to roll.`;
            keyboardRows.push([{ text: "🚫 Forfeit Game", callback_data: `d21_pvb_cancel:${gameData.gameId}` }]);
            break;
        case 'player_initial_roll_2_prompted':
            promptActionText = `Your score: <b>${gameData.playerScore}</b>. Send your <b>second</b> 🎲 dice!`;
            keyboardRows.push([{ text: "🚫 Forfeit Game", callback_data: `d21_pvb_cancel:${gameData.gameId}` }]);
            break;
        case 'player_blackjack': // Player has natural blackjack
            promptActionText = `✨ BLACKJACK! ✨ Bot is revealing its hand...`;
            // No actions for player here
            break;
        case 'player_turn_hit_stand_prompt':
            promptActionText = `Your score: <b>${gameData.playerScore}</b>. Send 🎲 to <b>Hit</b>, or <b>Stand</b>?`;
            keyboardRows.push([
                { text: `✅ Stand (Score: ${gameData.playerScore})`, callback_data: `d21_stand:${gameData.gameId}` },
                { text: "🚫 Forfeit Game", callback_data: `d21_pvb_cancel:${gameData.gameId}` }
            ]);
            break;
        case 'player_action_processing_stand':
            promptActionText = `You stood with <b>${gameData.playerScore}</b>. Bot Dealer's turn... 🤖`;
            break;
        case 'bot_rolling':
            promptActionText = `Bot Dealer is playing... Current Bot Score: <b>${gameData.botScore}</b>`;
            break;
        case 'game_over_player_bust':
        case 'game_over_bot_played':
        case 'game_over_player_forfeit':
        case 'game_over_bot_error':
        case 'game_over_error_ui_update':
            promptActionText = "<i>Game is concluding...</i>";
            // Finalization will handle the result message and post-game keyboard
            break;
        default:
            promptActionText = "Processing...";
    }
    messageTextHTML += `${promptActionText}`;
    if (!gameData.status.startsWith('game_over_') && gameData.status !== 'player_blackjack' && gameData.status !== 'bot_rolling' && gameData.status !== 'player_action_processing_stand') {
         messageTextHTML += `\n<i>(Turn timeout: ${ACTIVE_GAME_TURN_TIMEOUT_MS / 1000}s)</i>`;
    }


    if (keyboardRows.length > 0 && !gameData.status.startsWith('game_over_')) {
         keyboardRows.push([{ text: "📖 Game Rules", callback_data: `${RULES_CALLBACK_PREFIX_CONST}${GAME_IDS.DICE_21}` }]);
    }

    const messageOptions = {
        parse_mode: 'HTML',
        reply_markup: (keyboardRows.length > 0) ? { inline_keyboard: keyboardRows } : {},
        disable_web_page_preview: true
    };

    const newMsg = await safeSendMessage(String(gameData.chatId), messageTextHTML, messageOptions);

    if (newMsg?.message_id) {
        gameData.gameMessageId = String(newMsg.message_id);
        // Set turn timeout only if it's player's active turn to roll/choose
        if (gameData.status === 'player_initial_roll_1_prompted' ||
            gameData.status === 'player_initial_roll_2_prompted' ||
            gameData.status === 'player_turn_hit_stand_prompt') {
            gameData.turnTimeoutId = setTimeout(() => {
                const currentTimeoutGameData = activeGames.get(gameData.gameId);
                 if (currentTimeoutGameData && currentTimeoutGameData.turnTimeoutId !== null) {
                    handleDice21PvBTurnTimeout(gameData.gameId);
                }
            }, ACTIVE_GAME_TURN_TIMEOUT_MS);
            console.log(`${logPrefix} Player turn. Timeout SET: ${gameData.turnTimeoutId} for status ${gameData.status}`);
        } else {
            console.log(`${logPrefix} Not player's action turn or game over, no new timeout set. Status: ${gameData.status}`);
        }
    } else {
        console.error(`${logPrefix} CRITICAL: Failed to send/update PvB game message for GID ${gameData.gameId}.`);
        // If UI update fails, the game might be stuck.
        if (!gameData.status.startsWith('game_over_')) {
            gameData.status = 'game_over_error_ui_update'; // Mark as errored
            if (gameData.turnTimeoutId) clearTimeout(gameData.turnTimeoutId);
            gameData.turnTimeoutId = null;
            console.error(`${logPrefix} UI update failed for GID ${gameData.gameId}. Game may be stuck.`);
            if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL UI FAIL D21 PvB GID:${gameData.gameId}`);
            // Attempt to finalize with error, which should refund if appropriate or log loss
            await finalizeDice21PvBGame(gameData);
        }
    }
    // Save changes (like new messageId, cleared timeoutId, or new timeoutId) back to activeGames
    activeGames.set(gameData.gameId, gameData);
}
// --- END OF NEW updateDice21PvBMessage function ---
// NEW: Timeout handler for PvB Dice 21 player turns
async function handleDice21PvBTurnTimeout(gameId) {
    const logPrefix = `[D21_PvB_TurnTimeout_V2 GID:${gameId}]`; // V2 for consistency
    const gameData = activeGames.get(gameId);

    if (!gameData || gameData.type !== GAME_IDS.DICE_21 ||
        !(gameData.status === 'player_initial_roll_1_prompted' ||
          gameData.status === 'player_initial_roll_2_prompted' ||
          gameData.status === 'player_turn_hit_stand_prompt')) {
        console.log(`${logPrefix} Timeout fired but game ${gameId} not found or not in a state awaiting player action. Status: ${gameData?.status}.`);
        if (gameData && gameData.turnTimeoutId) { 
            clearTimeout(gameData.turnTimeoutId);
            gameData.turnTimeoutId = null;
        }
        return;
    }

    console.log(`${logPrefix} Player ${gameData.playerId} timed out in Dice 21 PvB (Status: ${gameData.status}). Game forfeited.`);

    if (gameData.turnTimeoutId) {
        clearTimeout(gameData.turnTimeoutId);
        gameData.turnTimeoutId = null;
    }

    gameData.status = 'game_over_player_forfeit';
    activeGames.set(gameId, gameData); 

    let client = null;
    try {
        client = await pool.connect();
        await client.query('BEGIN');
        await updateUserBalanceAndLedger(client, gameData.playerId, 0n, 
            'loss_dice21_pvb_timeout_forfeit',
            { game_id_custom_field: gameId, score_at_forfeit: gameData.playerScore, bet_amount: gameData.betAmount },
            `Dice 21 PvB game ${gameId} forfeited by player ${gameData.playerId} due to turn timeout.`
        );
        await client.query('COMMIT');
    } catch (dbError) {
        if (client) await client.query('ROLLBACK').catch(() => {});
        console.error(`${logPrefix} DB error logging timeout forfeit for game ${gameId}: ${dbError.message}`);
        if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL D21 PvB TIMEOUT FORFEIT LOGGING FAILURE GID: ${gameId}, User: ${gameData.playerId}. Error: ${dbError.message}`);
    } finally {
        if (client) client.release();
    }
    await finalizeDice21PvBGame(gameData);
}

// REVISED handleDice21PvBCancel (collects gameMessageId for final deletion)
async function handleDice21PvBCancel(gameId, userObj, originalMessageId, callbackQueryId, chatData) {
    const playerId = String(userObj.id || userObj.telegram_id);
    const chatId = String(chatData.id);
    let gameData = activeGames.get(gameId);
    const logPrefix = `[D21_PvBCancel GID:${gameId} UID:${playerId} V8_TimeoutClear]`;
    const playerRefHTML = escapeHTML(getPlayerDisplayReference(userObj)); // Use HTML escape

    if (!gameData || gameData.type !== GAME_IDS.DICE_21 || gameData.playerId !== playerId) {
        if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "⚠️ This Dice 21 game is not currently active or it doesn't belong to you.", show_alert: true }).catch(()=>{});
        return;
    }

    if (gameData.status.startsWith('game_over_') || gameData.status === 'bot_rolling' || gameData.status === 'bot_turn_pending_rolls' || gameData.status === 'finalizing' || gameData.status === 'player_blackjack' || gameData.status === 'player_action_processing_stand') {
        if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "⚠️ Too late to cancel! The game is already resolving or past that point.", show_alert: true }).catch(()=>{});
        return;
    }

    if (gameData.turnTimeoutId) { 
        clearTimeout(gameData.turnTimeoutId);
        gameData.turnTimeoutId = null;
        console.log(`${logPrefix} Cleared active turn timeout due to forfeit.`);
    }

    if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, {text: "Processing your game forfeit..."}).catch(()=>{});

    if (gameData.gameMessageId && bot) {
        await bot.deleteMessage(chatId, Number(gameData.gameMessageId)).catch(() => {console.warn(`${logPrefix} Could not delete prompt message ${gameData.gameMessageId} on forfeit.`);});
        gameData.gameMessageId = null;
    }
    // Delete intermediate messages if any
    for (const mid of gameData.intermediateMessageIds || []) {
        if (bot) await bot.deleteMessage(chatId, mid).catch(() => {});
    }
    gameData.intermediateMessageIds = [];

    console.log(`${logPrefix} Player ${playerRefHTML} is forfeiting PvB Dice 21 game ${gameId}.`);
    let client;
    try {
        client = await pool.connect(); await client.query('BEGIN');
        const forfeitLogResult = await updateUserBalanceAndLedger(client, playerId, 0n,
            'loss_dice21_pvb_forfeit',
            { game_id_custom_field: gameId, final_player_score_before_forfeit: gameData.playerScore, bet_amount: gameData.betAmount },
            `Player ${playerRefHTML} forfeited PvB Dice 21 game ${gameId}. Wager lost.` 
        );
        if (!forfeitLogResult.success) {
             console.error(`${logPrefix} DB Error logging forfeit: ${forfeitLogResult.error}.`);
        }
        await client.query('COMMIT');

        gameData.status = 'game_over_player_forfeit';
        activeGames.set(gameId, gameData); // Update game data before finalizing

        await finalizeDice21PvBGame(gameData);

    } catch (e) {
        if (client) await client.query('ROLLBACK').catch((rbErr) => {console.error(`${logPrefix} DB Rollback Exception on forfeit: ${rbErr.message}`)});
        console.error(`${logPrefix} CRITICAL DB Error processing forfeit for game ${gameId}: ${e.message}.`);
        await safeSendMessage(playerId, `An unexpected server error occurred while processing your forfeit for the Dice 21 game, ${playerRefHTML}. Please contact support.`, { parse_mode: 'HTML' });
        if(typeof notifyAdmin === 'function') {
            notifyAdmin(`🚨 D21 PvB Forfeit Processing DB Error 🚨\nGame ID: \`${escapeHTML(gameId)}\`, User: ${playerRefHTML} (\`${escapeHTML(String(playerId))}\`)\nError: \`${escapeHTML(e.message)}\`.`, {parse_mode:'HTML'}); // Use HTML
        }
        let gdOnError = activeGames.get(gameId); // Re-fetch in case it was changed
        if (gdOnError) {
            gdOnError.status = 'game_over_error_ui_update'; // A generic error state
            await finalizeDice21PvBGame(gdOnError); // Attempt to finalize even on error
        } else {
            // If gameData was somehow removed before this, ensure lock is potentially cleared
            activeGames.delete(gameId); // Ensure it's removed if not already
             if (gameData.chatType !== 'private' && chatId) {
                 await updateGroupGameDetails(chatId, { removeThisId: gameId }, GAME_IDS.DICE_21, null);
             }
        }
    } finally { if (client) client.release(); }
}

// --- START OF NEW processDice21PvBRollByEmoji function (for D21 PvB Player Hits) ---
async function processDice21PvBRollByEmoji(gameData, diceValue, msg) {
    // msg is passed to get userId, but gameData should already have playerId for PvB
    const rollerId = String(msg.from.id || msg.from.telegram_id);
    const logPrefix = `[D21_PvBRoll_Emoji_V1 UID:${rollerId} GID:${gameData.gameId}]`;

    if (!gameData || gameData.type !== GAME_IDS.DICE_21) {
        console.warn(`${logPrefix} Incorrect game type: ${gameData?.type}. Expected DICE_21.`);
        return;
    }

    // Verify it's the correct player and game status for a roll
    if (gameData.playerId !== rollerId ||
        !(gameData.status === 'player_initial_roll_1_prompted' ||
          gameData.status === 'player_initial_roll_2_prompted' ||
          gameData.status === 'player_turn_hit_stand_prompt')) {
        console.warn(`${logPrefix} Roll received from UID ${rollerId} but not their turn or game status is ${gameData.status}. Expected player: ${gameData.playerId}. Ignoring.`);
        // User's dice emoji message was already deleted by the main handler.
        // Optionally, send a message if they weren't supposed to roll.
        // await safeSendMessage(gameData.chatId, "It's not your turn to roll, or the game is not awaiting a roll.", {parse_mode: 'HTML'});
        return;
    }

    console.log(`${logPrefix} Processing roll of ${diceValue} for player ${gameData.playerId} in status ${gameData.status}.`);

    // Clear any active turn timeout for the player
    if (gameData.turnTimeoutId) {
        clearTimeout(gameData.turnTimeoutId);
        gameData.turnTimeoutId = null;
        console.log(`${logPrefix} Cleared turn timeout for player ${gameData.playerId}.`);
    }

    gameData.playerHandRolls.push(diceValue);
    gameData.playerScore += diceValue;
    gameData.lastInteractionTime = Date.now();

    const playerRefHTML = gameData.playerRef || escapeHTML(getPlayerDisplayReference(gameData.userObj || {id: gameData.playerId})); // Fallback for playerRef
    let statusUpdateMessageHTML = `🎲 ${playerRefHTML} rolled a <b>${diceValue}</b>!`;

    if (gameData.status === 'player_initial_roll_1_prompted') {
        gameData.status = 'player_initial_roll_2_prompted';
        statusUpdateMessageHTML += `\nYour score: <b>${gameData.playerScore}</b>. Send your second 🎲 dice!`;
        activeGames.set(gameData.gameId, gameData);
        await updateDice21PvBMessage(gameData, statusUpdateMessageHTML); // Update UI, will set new timeout
    } else if (gameData.status === 'player_initial_roll_2_prompted') {
        statusUpdateMessageHTML += `\nYour starting hand total: <b>${gameData.playerScore}</b>.`;
        if (gameData.playerScore === DICE_21_TARGET_SCORE) { // Natural Blackjack
            console.log(`${logPrefix} Player hit Blackjack on initial deal!`);
            gameData.status = 'player_blackjack'; // Special status for natural blackjack
            activeGames.set(gameData.gameId, gameData);
            // Update message to show blackjack, then proceed to bot's turn (or finalize if bot also has BJ)
            await updateDice21PvBMessage(gameData, `${statusUpdateMessageHTML}\n✨ BLACKJACK! ✨`);
            await sleep(1500); // Pause for player to see
            if (typeof processDice21BotTurn === 'function') {
                await processDice21BotTurn(gameData);
            } else {
                console.error(`${logPrefix} CRITICAL: processDice21BotTurn function not defined!`);
                gameData.status = 'game_over_bot_error'; // Fallback error state
                await finalizeDice21PvBGame(gameData);
            }
        } else {
            gameData.status = 'player_turn_hit_stand_prompt';
            activeGames.set(gameData.gameId, gameData);
            await updateDice21PvBMessage(gameData, statusUpdateMessageHTML); // Update UI for Hit/Stand choice
        }
    } else if (gameData.status === 'player_turn_hit_stand_prompt') { // Player chose to Hit
        statusUpdateMessageHTML += `\nYour new score: <b>${gameData.playerScore}</b>.`;
        if (gameData.playerScore > DICE_21_TARGET_SCORE) {
            console.log(`${logPrefix} Player BUSTED with score ${gameData.playerScore}.`);
            gameData.status = 'game_over_player_bust';
            activeGames.set(gameData.gameId, gameData);
            await updateDice21PvBMessage(gameData, `${statusUpdateMessageHTML}\n💥 BUSTED! 💥`);
            await sleep(1500);
            await finalizeDice21PvBGame(gameData);
        } else if (gameData.playerScore === DICE_21_TARGET_SCORE) {
            console.log(`${logPrefix} Player hit 21. Auto-standing.`);
            gameData.status = 'player_action_processing_stand'; // Player stands on 21
            activeGames.set(gameData.gameId, gameData);
            await updateDice21PvBMessage(gameData, `${statusUpdateMessageHTML}\n🎯 Perfect 21! You stand.`);
            await sleep(1500);
            if (typeof processDice21BotTurn === 'function') {
                await processDice21BotTurn(gameData);
            } else {
                console.error(`${logPrefix} CRITICAL: processDice21BotTurn function not defined!`);
                gameData.status = 'game_over_bot_error';
                await finalizeDice21PvBGame(gameData);
            }
        } else {
            // Score < 21, still player's turn to Hit or Stand
            gameData.status = 'player_turn_hit_stand_prompt';
            activeGames.set(gameData.gameId, gameData);
            await updateDice21PvBMessage(gameData, statusUpdateMessageHTML);
        }
    } else {
        console.warn(`${logPrefix} Roll processed in an unexpected status: ${gameData.status}`);
        activeGames.set(gameData.gameId, gameData); // Save changes like score if any
        await updateDice21PvBMessage(gameData, statusUpdateMessageHTML + "\n🤔 Unexpected game state.");
    }
}
// --- END OF NEW processDice21PvBRollByEmoji function ---
// --- START OF NEW handleDice21PvBStand function ---
async function handleDice21PvBStand(gameId, userObj, originalMessageId, callbackQueryId, chatData) {
    const userId = String(userObj.id || userObj.telegram_id);
    const logPrefix = `[D21_PvBStand GID:${gameId} UID:${userId}]`;
    let gameData = activeGames.get(gameId);

    if (!gameData || gameData.type !== GAME_IDS.DICE_21 || gameData.playerId !== userId || gameData.status !== 'player_turn_hit_stand_prompt') {
        await bot.answerCallbackQuery(callbackQueryId, { text: "⚠️ Not your turn to stand or game state is invalid.", show_alert: true }).catch(() => {});
        return;
    }

    console.log(`${logPrefix} Player ${userId} chose to stand with score ${gameData.playerScore}.`);

    // Clear any active turn timeout for the player
    if (gameData.turnTimeoutId) {
        clearTimeout(gameData.turnTimeoutId);
        gameData.turnTimeoutId = null;
        console.log(`${logPrefix} Cleared turn timeout for player ${userId}.`);
    }

    await bot.answerCallbackQuery(callbackQueryId, { text: `You stand with ${gameData.playerScore}. Bot's turn...` }).catch(() => {});

    gameData.status = 'player_action_processing_stand'; // Indicate player has stood, now bot's turn
    gameData.lastInteractionTime = Date.now();
    activeGames.set(gameData.gameId, gameData); // Save status change

    const playerRefHTML = gameData.playerRef || escapeHTML(getPlayerDisplayReference(gameData.userObj || {id: gameData.playerId}));
    const standMessageHTML = `✋ ${playerRefHTML} stands with a score of <b>${gameData.playerScore}</b>.\nNow it's the Bot Dealer's turn... 🤖`;

    // Update the main game message to reflect the stand
    // updateDice21PvBMessage will delete the old message and send a new one.
    await updateDice21PvBMessage(gameData, standMessageHTML);
    await sleep(1500); // Brief pause for player to see the stand update

    // Proceed to bot's turn
    if (typeof processDice21BotTurn === 'function') {
        await processDice21BotTurn(gameData);
    } else {
        console.error(`${logPrefix} CRITICAL: processDice21BotTurn function not defined! Cannot proceed to bot's turn.`);
        // Attempt to finalize with an error to prevent game from being stuck
        gameData.status = 'game_over_bot_error'; // A generic error state
        activeGames.set(gameData.gameId, gameData);
        await finalizeDice21PvBGame(gameData);
    }
}
// --- END OF NEW handleDice21PvBStand function ---

// --- START OF NEW processDice21BotTurn function ---
async function processDice21BotTurn(gameData) {
    const gameId = gameData.gameId;
    const chatId = gameData.chatId;
    const playerId = gameData.playerId; // For logging/context if needed
    const logPrefix = `[D21_BotTurn GID:${gameId} ForPlayerUID:${playerId}]`;

    if (!gameData || (gameData.status !== 'player_action_processing_stand' && gameData.status !== 'player_blackjack')) {
        console.warn(`${logPrefix} Bot turn called in unexpected status: ${gameData.status}. Aborting bot turn.`);
        if (gameData.status !== 'player_blackjack') { // If player didn't have BJ, this is likely an error
            gameData.status = 'game_over_bot_error'; 
            activeGames.set(gameId, gameData);
            await finalizeDice21PvBGame(gameData);
        } else { // Player had Blackjack, bot just reveals hand (rolls if needed) and game finalizes
            if (gameData.botHandRolls.length === 0) { 
                console.log(`${logPrefix} Player has Blackjack. Bot revealing its initial hand.`);
                for (let i = 0; i < 2; i++) { // Bot gets two dice
                    // MODIFIED CALL below: Added 'DICE_21_ROLL'
                    const rollResult = await getSingleDiceRollViaHelper(gameId, chatId, null, `D21 Bot Initial Roll ${i + 1} (vs Player BJ)`, 'DICE_21_ROLL');
                    if (rollResult.error) {
                        console.error(`${logPrefix} Error getting Bot Roll ${i + 1} (vs Player BJ): ${rollResult.message}. Using fallback.`);
                        gameData.botHandRolls.push(rollDie());
                    } else {
                        gameData.botHandRolls.push(rollResult.roll);
                    }
                    gameData.botScore = gameData.botHandRolls.reduce((sum, r) => sum + r, 0);
                }
            }
            gameData.status = 'game_over_bot_played'; 
            activeGames.set(gameId, gameData);
            await updateDice21PvBMessage(gameData, "Bot reveals hand after player Blackjack."); // Update message to show bot's hand
            await sleep(1500);
            await finalizeDice21PvBGame(gameData);
        }
        return;
    }

    console.log(`${logPrefix} Bot Dealer's turn. Player score: ${gameData.playerScore}.`);
    gameData.status = 'bot_rolling'; 
    activeGames.set(gameId, gameData);

    let botDealingMessage = "🤖 Bot Dealer is revealing its hand...\n";
    await updateDice21PvBMessage(gameData, botDealingMessage);
    await sleep(1000);

    // Initial two dice for the bot if not already dealt (e.g., if player stood normally)
    if (gameData.botHandRolls.length === 0) {
        for (let i = 0; i < 2; i++) {
            // MODIFIED CALL below: Added 'DICE_21_ROLL'
            const rollResult = await getSingleDiceRollViaHelper(gameId, chatId, null, `D21 Bot Initial Roll ${i + 1}`, 'DICE_21_ROLL');
            let currentRollValue;
            if (rollResult.error) {
                console.error(`${logPrefix} Error getting Bot Roll ${i + 1}: ${rollResult.message}. Using fallback.`);
                currentRollValue = rollDie();
            } else {
                currentRollValue = rollResult.roll;
            }
            gameData.botHandRolls.push(currentRollValue);
            gameData.botScore = gameData.botHandRolls.reduce((sum, r) => sum + r, 0);
            activeGames.set(gameId, gameData); 

            if (i === 0) { 
                botDealingMessage += `Bot's first die: <b>${currentRollValue}</b> 🎲\n`;
            } else { 
                botDealingMessage += `Bot's second die: <b>${currentRollValue}</b> 🎲. Total: <b>${gameData.botScore}</b>\n`;
            }
            await updateDice21PvBMessage(gameData, botDealingMessage);
            await sleep(1500);
        }
    }

    // Bot hits based on strategy
    while (gameData.botScore < DICE_21_BOT_STAND_SCORE && gameData.botScore <= DICE_21_TARGET_SCORE) {
        if (isShuttingDown) { console.log(`${logPrefix} Shutdown during bot's turn.`); break; }

        botDealingMessage += `Bot score is ${gameData.botScore}. Bot hits! 🤖\n`;
        await updateDice21PvBMessage(gameData, botDealingMessage);
        await sleep(1000);

        // MODIFIED CALL below: Added 'DICE_21_ROLL'
        const rollResult = await getSingleDiceRollViaHelper(gameId, chatId, null, `D21 Bot Hit Roll ${gameData.botHandRolls.length + 1}`, 'DICE_21_ROLL');
        let hitRollValue;
        if (rollResult.error) {
            console.error(`${logPrefix} Error getting Bot Hit Roll: ${rollResult.message}. Using fallback.`);
            hitRollValue = rollDie();
        } else {
            hitRollValue = rollResult.roll;
        }

        gameData.botHandRolls.push(hitRollValue);
        gameData.botScore += hitRollValue;
        activeGames.set(gameId, gameData); 

        botDealingMessage += `Bot draws a <b>${hitRollValue}</b> 🎲. Bot total: <b>${gameData.botScore}</b>\n`;
        await updateDice21PvBMessage(gameData, botDealingMessage);
        await sleep(1500);

        if (gameData.botScore > DICE_21_TARGET_SCORE) {
            botDealingMessage += `💥 Bot BUSTED with <b>${gameData.botScore}</b>!\n`;
            await updateDice21PvBMessage(gameData, botDealingMessage);
            await sleep(1000);
            break; 
        }
    }

    if (gameData.botScore >= DICE_21_BOT_STAND_SCORE && gameData.botScore <= DICE_21_TARGET_SCORE) {
        botDealingMessage += `✋ Bot stands with <b>${gameData.botScore}</b>.\n`;
        await updateDice21PvBMessage(gameData, botDealingMessage);
        await sleep(1000);
    }

    gameData.status = 'game_over_bot_played';
    activeGames.set(gameData.gameId, gameData);
    await finalizeDice21PvBGame(gameData);
}
// --- END OF NEW processDice21BotTurn function ---

// CORRECTED finalizeDice21PvBGame
// CORRECTED finalizeDice21PvBGame (with Referral Fixes)
async function finalizeDice21PvBGame(gameData) {
    const logPrefix = `[D21_PvB_Finalize_V12_FullFix GID:${gameData.gameId}]`;
    const activeGameActivityKey = GAME_IDS.DICE_21; 
    let allNotificationsToSend = [];

    let solPrice;
    try {
        solPrice = await getSolUsdPrice();
    } catch (priceError) {
        console.error(`${logPrefix} CRITICAL: Could not get SOL price. Level-up/milestone checks will be skipped. Error: ${priceError.message}`);
        solPrice = 0;
    }

    if (gameData.turnTimeoutId) {
        clearTimeout(gameData.turnTimeoutId);
        gameData.turnTimeoutId = null;
    }

    const { gameId, chatId, playerId, playerRef, betAmount, userObj, status: finalStatus, playerHandRolls, botHandRolls, botScore, playerScore, chatType } = gameData;

    activeGames.delete(gameId);
    if (chatType && chatType !== 'private') {
        await updateGroupGameDetails(chatId, { removeThisId: gameId }, activeGameActivityKey, null);
    }

    let resultTitle = "🏁 Dice 21 Result 🏁";
    let resultOutcomeText = "";
    let payoutLamports = 0n;
    let playerBlackjack = (playerScore === DICE_21_TARGET_SCORE && playerHandRolls.length === 2);
    const betDisplayUSDShort = await formatBalanceForDisplay(betAmount, 'USD', 2);
    let ledgerOutcomeCode = 'loss_dice21_pvb'; 
    let gameOutcomeTextForLog = "";
    let isConclusiveOutcome = false;

    if (finalStatus === 'game_over_player_bust') {
        isConclusiveOutcome = true;
        resultTitle = "💥 Player Busts!";
        resultOutcomeText = `Your score: <b>${escapeHTML(String(playerScore))}</b>. Bot wins <b>${escapeHTML(betDisplayUSDShort)}</b>.`;
        ledgerOutcomeCode = 'loss_dice21_pvb_player_bust';
        gameOutcomeTextForLog = `Player busts (Score: ${playerScore})`;
    } else if (finalStatus === 'game_over_player_forfeit') { 
        isConclusiveOutcome = true;
        resultTitle = "🚫 Game Forfeited";
        resultOutcomeText = `You forfeited the game. Bot wins <b>${escapeHTML(betDisplayUSDShort)}</b>.`;
        ledgerOutcomeCode = 'loss_dice21_pvb_timeout_forfeit';
        gameOutcomeTextForLog = `Player forfeits (Score: ${playerScore})`;
    } else if (finalStatus === 'game_over_bot_error' || finalStatus === 'game_over_error_ui_update') {
        isConclusiveOutcome = false;
        resultTitle = "⚙️ Game Error";
        resultOutcomeText = `Technical issue. Bet <b>${escapeHTML(betDisplayUSDShort)}</b> refunded.`;
        payoutLamports = betAmount; 
        ledgerOutcomeCode = 'refund_dice21_pvb_error';
        gameOutcomeTextForLog = `Game error - refund (Player: ${playerScore}, Bot: ${botScore})`;
    } else if (finalStatus === 'game_over_bot_played' || finalStatus === 'player_blackjack') { 
        const finalBotScore = (botHandRolls && botHandRolls.length > 0) ? botScore : 0;
        if (playerBlackjack && (finalBotScore !== DICE_21_TARGET_SCORE || (botHandRolls && botHandRolls.length > 2))) {
            isConclusiveOutcome = true;
            resultTitle = "✨🎉 BLACKJACK!";
            const profitBlackjack = betAmount * 15n / 10n; 
            payoutLamports = betAmount + profitBlackjack;
            resultOutcomeText = `Natural 21! You win <b>${escapeHTML(await formatBalanceForDisplay(payoutLamports, 'USD', 2))}</b>!`;
            ledgerOutcomeCode = 'win_dice21_pvb_blackjack';
            gameOutcomeTextForLog = `Player Blackjack (Bot score: ${finalBotScore})`;
        } else if (botScore > DICE_21_TARGET_SCORE) {
            isConclusiveOutcome = true;
            resultTitle = "🎉 Player Wins!";
            payoutLamports = betAmount * 2n;
            resultOutcomeText = `Bot BUSTED (<b>${escapeHTML(String(botScore))}</b>)! You win <b>${escapeHTML(await formatBalanceForDisplay(payoutLamports, 'USD', 2))}</b>!`;
            ledgerOutcomeCode = 'win_dice21_pvb_bot_bust';
            gameOutcomeTextForLog = `Player wins - Bot busts (Player: ${playerScore}, Bot: ${botScore})`;
        } else if (playerScore > botScore) {
            isConclusiveOutcome = true;
            resultTitle = "🎉 Player Wins!";
            payoutLamports = betAmount * 2n;
            resultOutcomeText = `Your <b>${escapeHTML(String(playerScore))}</b> beats Bot's <b>${escapeHTML(String(botScore))}</b>. You win <b>${escapeHTML(await formatBalanceForDisplay(payoutLamports, 'USD', 2))}</b>!`;
            ledgerOutcomeCode = 'win_dice21_pvb_score';
            gameOutcomeTextForLog = `Player wins by score (${playerScore} vs ${botScore})`;
        } else if (botScore > playerScore) {
            isConclusiveOutcome = true;
            resultTitle = "🤖 Bot Wins";
            resultOutcomeText = `Bot's <b>${escapeHTML(String(botScore))}</b> beats your <b>${escapeHTML(String(playerScore))}</b>. You lost <b>${escapeHTML(betDisplayUSDShort)}</b>.`;
            ledgerOutcomeCode = 'loss_dice21_pvb_score';
            gameOutcomeTextForLog = `Bot wins by score (${botScore} vs ${playerScore})`;
        } else { // Push
            isConclusiveOutcome = false;
            resultTitle = "⚖️ Push!";
            resultOutcomeText = `Scores tied at <b>${escapeHTML(String(playerScore))}</b>. Bet <b>${escapeHTML(betDisplayUSDShort)}</b> returned.`;
            payoutLamports = betAmount;
            ledgerOutcomeCode = 'push_dice21_pvb';
            gameOutcomeTextForLog = `Push (Draw at ${playerScore})`;
        }
    } else {
        isConclusiveOutcome = false;
        resultTitle = "❓ Game Undetermined";
        resultOutcomeText = `Unexpected status: <code>${escapeHTML(String(finalStatus))}</code>. Bet <b>${escapeHTML(betDisplayUSDShort)}</b> refunded.`;
        payoutLamports = betAmount;
        ledgerOutcomeCode = 'refund_dice21_pvb_unknown_status';
        gameOutcomeTextForLog = `Undetermined status ${finalStatus} - refund`;
    }

    let dbErrorDuringPayoutText = "";
    let client = null;
    try {
        client = await pool.connect(); await client.query('BEGIN');
        const actualGameLogId = await logGameResultToGamesTable(
            client, GAME_IDS.DICE_21, chatId, playerId, [playerId], betAmount, gameOutcomeTextForLog, 0n
        );

        const notes = `Dice 21 PvB Result: ${finalStatus}. Payout: ${payoutLamports}. Player Hand: ${playerHandRolls.join(',')}. Bot Hand: ${botHandRolls.join(',')}.`;
        const balanceUpdateResult = await updateUserBalanceAndLedger(
            client, playerId, payoutLamports, ledgerOutcomeCode, { game_log_id: actualGameLogId, original_bet_amount: betAmount.toString() }, notes, solPrice
        );

        if (!balanceUpdateResult.success) {
            await client.query('ROLLBACK'); 
            throw new Error(balanceUpdateResult.error || "DB Error during Dice 21 PvB payout/ledger update.");
        }
        if (balanceUpdateResult.notifications) allNotificationsToSend.push(...balanceUpdateResult.notifications);

        if (isConclusiveOutcome) {
            // --- START OF MODIFICATION ---

            // 1. ADDED: Check for the initial bet bonus.
            if (typeof processQualifyingBetAndInitialBonus === 'function') {
                const initialBonusResult = await processQualifyingBetAndInitialBonus(client, userId, betAmount, gameId);
                if (initialBonusResult.jobQueued) {
                    console.log(`[ReferralCheck] Queued initial bet bonus job for user ${userId} from game ${gameId}.`);
                }
            }
            
            // 2. MODIFIED: Correctly call level and milestone checks.
            if (balanceUpdateResult.newTotalWageredLamports !== undefined) {
                const levelNotifications = await checkAndUpdateUserLevel(client, playerId, balanceUpdateResult.newTotalWageredLamports, solPrice, chatId);
                allNotificationsToSend.push(...levelNotifications);
                const milestoneResult = await processWagerMilestoneBonus(client, playerId, balanceUpdateResult.newTotalWageredLamports, solPrice);
                if (!milestoneResult.success) {
                    console.warn(`${logPrefix} Failed to process milestone bonus: ${milestoneResult.error}`);
                }
            }

            // --- END OF MODIFICATION ---
        }

        await client.query('COMMIT');
    } catch (e) {
        if (client) await client.query('ROLLBACK').catch(()=>{});
        dbErrorDuringPayoutText = `\n\n⚠️ <i>Critical error settling wager: ${escapeHTML(e.message)}. Admin notified.</i>`;
        console.error(`${logPrefix} CRITICAL DB error during finalization: ${e.message}`);
        if(typeof notifyAdmin === 'function') notifyAdmin(`🚨 CRITICAL D21 PvB Payout/Ledger Failure 🚨\nGame ID: \`${escapeHTML(gameId)}\` User: ${escapeHTML(String(playerId))}\nAmount Due: ${payoutLamports}\nDB Error: \`${escapeHTML(e.message)}\`. MANUAL CHECK REQUIRED.`, {parse_mode: 'MarkdownV2'});
    } finally {
        if (client) client.release();
    }

    for (const notification of allNotificationsToSend) {
        if (notification.to === ADMIN_USER_ID && typeof notifyAdmin === 'function') {
            await notifyAdmin(notification.text, notification.options).catch(err => console.error(`Failed to send admin notification: ${err.message}`));
        } else {
            await safeSendMessage(notification.to, notification.text, notification.options).catch(err => console.error(`Failed to send game-related notification to ${notification.to}: ${err.message}`));
        }
    }

    const playerRefHTMLFinal = escapeHTML(playerRef);
    let conciseFinalMessageHTML = `<b>${escapeHTML(resultTitle)}</b>\n` +
                                  `You (${playerRefHTMLFinal}): <b>${escapeHTML(String(playerScore))}</b> ${formatDiceRolls(playerHandRolls)}\n` +
                                  `Bot: <b>${escapeHTML(String(botScore))}</b> ${formatDiceRolls(botHandRolls)}\n` +
                                  `${resultOutcomeText}` +
                                  `${dbErrorDuringPayoutText}`;

    const finalKeyboard = createPostGameKeyboard(GAME_IDS.DICE_21, betAmount);
    await safeSendMessage(chatId, conciseFinalMessageHTML, { parse_mode: 'HTML', reply_markup: finalKeyboard });

    const messagesToDelete = [...(gameData.intermediateMessageIds || [])];
    if (gameData.gameMessageId) messagesToDelete.push(gameData.gameMessageId);
    for (const msgId of messagesToDelete) {
        if (bot && msgId) await bot.deleteMessage(chatId, Number(msgId)).catch(e => {});
    }
}

// --- Player vs. Player (PvP) Dice 21 Specific Logic (MODIFIED FOR HTML & TIMEOUTS & GRANULAR LOCKING) ---

async function startDice21PvPInitialDeal(pvpGameId, initiatorUserObj, opponentUserObj, betAmountLamports, groupChatId, groupChatType, originalOfferMessageIdToDelete, origin // 'unified_offer' or 'direct_challenge'
) {
    const logPrefix = `[D21_PvP_InitialDeal_V3_Origin GID:${pvpGameId} Origin:${origin}]`; 
    
    let activeGameKeyForStorage;
    if (origin === 'unified_offer') {
        activeGameKeyForStorage = GAME_IDS.DICE_21_PVP_FROM_UNIFIED;
    } else { // 'direct_challenge'
        activeGameKeyForStorage = GAME_IDS.DICE_21_PVP; 
    }
    // This function is called *after* the calling callback (handleDice21AcceptPvPChallenge or handleDirectChallengeResponse)
    // has already checked the limit for 'activeGameKeyForStorage' and deducted joiner's bet if needed.
    // Initiator's bet was taken at offer time.

    console.log(`${logPrefix} Starting initial deal. Initiator: ${initiatorUserObj.username}, Opponent: ${opponentUserObj.username}. Active Game Key: ${activeGameKeyForStorage}`);

    const initiatorMentionHTML = escapeHTML(getPlayerDisplayReference(initiatorUserObj));
    const opponentMentionHTML = escapeHTML(getPlayerDisplayReference(opponentUserObj));
    const betDisplayHTML = escapeHTML(await formatBalanceForDisplay(betAmountLamports, 'USD'));

    const gameData = {
        type: GAME_IDS.DICE_21_PVP, 
        gameId: pvpGameId, 
        chatId: String(groupChatId), 
        chatType: groupChatType, 
        betAmount: betAmountLamports,
        initiator: { userId: String(initiatorUserObj.telegram_id), mention: initiatorMentionHTML, userObj: initiatorUserObj, hand: [], score: 0, status: 'waiting_for_hand', isTurn: false },
        opponent: { userId: String(opponentUserObj.telegram_id), mention: opponentMentionHTML, userObj: opponentUserObj, hand: [], score: 0, status: 'waiting_for_hand', isTurn: false },
        status: 'dealing_initial_hands', 
        creationTime: Date.now(), 
        currentMessageId: null, 
        currentTurnTimeoutId: null,
        _origin_key_for_limits: activeGameKeyForStorage // Store for cleanup
    };
    activeGames.set(pvpGameId, gameData);
    // Register this new active PvP game in the group session using its specific key
    await updateGroupGameDetails(groupChatId, pvpGameId, activeGameKeyForStorage, betAmountLamports);
    console.log(`${logPrefix} D21 PvP game ${pvpGameId} registered with group lock key: ${activeGameKeyForStorage}.`);

    const initialMessageTextHTML = `⚔️ <b>Dice 21 PvP: ${initiatorMentionHTML} vs ${opponentMentionHTML}</b> ⚔️\n` +
                                  `Bet: <b>${betDisplayHTML}</b> each.\n\n` +
                                  `The Helper Bot is now dealing the initial two dice to each player. Please wait for the reveal! ⏳`;

    const sentInitialMessage = await safeSendMessage(gameData.chatId, initialMessageTextHTML, { parse_mode: 'HTML' });
    if (!sentInitialMessage?.message_id) {
        console.error(`${logPrefix} CRITICAL: Failed to send initial dealing message for PvP game ${pvpGameId}.`);
        activeGames.delete(pvpGameId);
        await updateGroupGameDetails(gameData.chatId, { removeThisId: pvpGameId }, activeGameKeyForStorage, null); // Clear lock
        if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL D21 PvP Start UI Fail GID:${pvpGameId}. Bets taken. Manual refund check for both players needed.`);
        // Note: Bets for both players were confirmed before this function was called. This is a critical failure.
        return;
    }
    gameData.currentMessageId = sentInitialMessage.message_id;
    activeGames.set(pvpGameId, gameData); // Save message ID

    let initiatorFaulted = false;
    for (let i = 0; i < 2; i++) {
        const rollResult = await getSingleDiceRollViaHelper(pvpGameId, gameData.chatId, gameData.initiator.userId, `Initiator D21 PvP Die ${i+1}`);
        if (rollResult.error) { initiatorFaulted = true; break; }
        gameData.initiator.hand.push(rollResult.roll); gameData.initiator.score += rollResult.roll;
        const rollMsg = await safeSendMessage(gameData.chatId, `🎲 ${initiatorMentionHTML} received a die (Card ${i+1}/2 from Helper Bot)...`, {parse_mode:'HTML'}); // Keep it vague initially
        if(rollMsg?.message_id && activeGames.has(pvpGameId)) activeGames.get(pvpGameId).intermediateMessageIds = [...(activeGames.get(pvpGameId).intermediateMessageIds || []), rollMsg.message_id];
        if (i < 1) await sleep(1000);
    }
    activeGames.set(pvpGameId, gameData); // Save initiator's hand
    if (initiatorFaulted) { gameData.status = 'game_over_error_deal_initiator'; await finalizeDice21PvPGame(gameData); return; }
    await sleep(1500);

    let opponentFaulted = false;
    for (let i = 0; i < 2; i++) {
        const rollResult = await getSingleDiceRollViaHelper(pvpGameId, gameData.chatId, gameData.opponent.userId, `Opponent D21 PvP Die ${i+1}`);
        if (rollResult.error) { opponentFaulted = true; break; }
        gameData.opponent.hand.push(rollResult.roll); gameData.opponent.score += rollResult.roll;
        const rollMsg = await safeSendMessage(gameData.chatId, `🎲 ${opponentMentionHTML} received a die (Card ${i+1}/2 from Helper Bot)...`, {parse_mode:'HTML'});
        if(rollMsg?.message_id && activeGames.has(pvpGameId)) activeGames.get(pvpGameId).intermediateMessageIds = [...(activeGames.get(pvpGameId).intermediateMessageIds || []), rollMsg.message_id];
        if (i < 1) await sleep(1000);
    }
    activeGames.set(pvpGameId, gameData); // Save opponent's hand
    if (opponentFaulted) { gameData.status = 'game_over_error_deal_opponent'; await finalizeDice21PvPGame(gameData); return; }
    await sleep(1500);

    // Delete intermediate "received a die" messages
    const currentFullGameData = activeGames.get(pvpGameId);
    if (currentFullGameData?.intermediateMessageIds) {
        for (const mid of currentFullGameData.intermediateMessageIds) {
            if(bot && mid) await bot.deleteMessage(String(groupChatId), mid).catch(()=>{});
        }
        currentFullGameData.intermediateMessageIds = [];
        activeGames.set(pvpGameId, currentFullGameData);
    }

    const p1Score = gameData.initiator.score; const p2Score = gameData.opponent.score;
    const p1HasBJ = p1Score === DICE_21_TARGET_SCORE && gameData.initiator.hand.length === 2;
    const p2HasBJ = p2Score === DICE_21_TARGET_SCORE && gameData.opponent.hand.length === 2;

    if (p1HasBJ && p2HasBJ) gameData.status = 'game_over_push_both_blackjack';
    else if (p1HasBJ) gameData.status = 'game_over_initiator_blackjack';
    else if (p2HasBJ) gameData.status = 'game_over_opponent_blackjack';
    else {
        gameData.initiator.isTurn = true; gameData.initiator.status = 'playing_turn';
        gameData.opponent.status = 'waiting_turn'; // Ensure opponent is waiting
        gameData.status = 'initiator_turn';
    }
    activeGames.set(pvpGameId, gameData);

    if (gameData.status.startsWith('game_over')) {
        await finalizeDice21PvPGame(gameData);
    } else {
        await updateDice21PvPGameMessage(gameData); 
    }
}

// --- START OF FULL REPLACEMENT for updateDice21PvPGameMessage function ---
async function updateDice21PvPGameMessage(gameData, isFinal = false, customMessageContent = null) {
    if (!gameData) { // Basic guard for passed gameData
        console.warn(`[UpdateD21PvPMsg] Initial gameData parameter is null/undefined. Cannot update.`);
        return;
    }

    let activeGameDataRef = gameData; // By default, trust the passed gameData if it's the final call
    if (!isFinal) {
        // Only re-fetch from activeGames if it's NOT the final update call from finalizeDice21PvPGame,
        // to ensure we're working with the most up-to-date object in the map for ongoing game updates.
        const tempFetchedGameData = activeGames.get(gameData.gameId);
        if (!tempFetchedGameData) {
            console.warn(`[UpdateD21PvPMsg] Game GID:${gameData.gameId} not found in activeGames (non-final update). Cannot update message.`);
            return;
        }
        activeGameDataRef = tempFetchedGameData; // Use the version from the map for ongoing updates
    }
    // Use the authoritative version for the rest of the function
    gameData = activeGameDataRef;

    const logPrefix = `[D21_PvP_UpdateMsg_V3_GranLimit GID:${gameData.gameId} Final:${isFinal}]`;
    const currentMainMessageId = gameData.currentMessageId;

    // Clear previous intermediate messages (like individual roll announcements)
    // This should be done regardless of whether it's a final update or not, to clean up before sending a new main message
    if (gameData.intermediateMessageIds && gameData.intermediateMessageIds.length > 0) {
        console.log(`${logPrefix} Clearing ${gameData.intermediateMessageIds.length} intermediate messages.`);
        for (const mid of gameData.intermediateMessageIds) {
            if (bot && mid) {
                await bot.deleteMessage(String(gameData.chatId), Number(mid)).catch(e => {
                    if (e.code !== 'ETELEGRAM' || (e.response && e.response.body &&
                        !(e.response.body.description?.includes("message to delete not found") ||
                          e.response.body.description?.includes("message can't be deleted")))) {
                        // console.warn(`${logPrefix} Non-critical: Failed to delete intermediate message ID ${mid}: ${e.message}`); // Can be noisy
                    }
                });
            }
        }
        gameData.intermediateMessageIds = []; // Clear the array after attempting deletion
    }

    // Clear existing turn timeout if any, new one will be set if needed
    if (gameData.currentTurnTimeoutId) {
        clearTimeout(gameData.currentTurnTimeoutId);
        gameData.currentTurnTimeoutId = null;
        console.log(`${logPrefix} Cleared existing turn timeout.`);
    }

    // Delete old main game message before sending/editing a new one
    if (currentMainMessageId && bot) {
        await bot.deleteMessage(String(gameData.chatId), Number(currentMainMessageId)).catch(e => {
             if (e.code !== 'ETELEGRAM' || (e.response && e.response.body &&
                !(e.response.body.description?.includes("message to delete not found") ||
                  e.response.body.description?.includes("message can't be deleted")))) {
                // console.warn(`${logPrefix} Non-critical: Failed to delete previous main game message ID ${currentMainMessageId}: ${e.message}`); // Can be noisy
            }
        });
        gameData.currentMessageId = null; // Mark as deleted
    }

    let messageTextHTML;
    let keyboard = { inline_keyboard: [] };
    const p1MentionHTML = escapeHTML(gameData.initiator.mention || getPlayerDisplayReference(gameData.initiator.userObj));
    const p2MentionHTML = escapeHTML(gameData.opponent.mention || getPlayerDisplayReference(gameData.opponent.userObj));
    const betDisplayHTML_Update = escapeHTML(await formatBalanceForDisplay(gameData.betAmount, 'USD'));

    if (customMessageContent) { // Typically used for the final result message
        messageTextHTML = customMessageContent;
        if (isFinal) { // If it's the final summary message from finalizeDice21PvPGame
            keyboard = createPostGameKeyboard(GAME_IDS.DICE_21_PVP, gameData.betAmount);
        } else if (keyboard.inline_keyboard.length === 0) { // If custom but not final, maybe add rules or back button
             keyboard.inline_keyboard.push([{ text: "📖 Game Rules", callback_data: `${RULES_CALLBACK_PREFIX_CONST}${GAME_IDS.DICE_21}` }]);
        }
    } else { // Construct standard game state message
        const p1 = gameData.initiator;
        const p2 = gameData.opponent;
        const p1StatusIcon = p1.status === 'stood' ? "✅ Stood" : (p1.status === 'bust' ? "💥 BUST" : (p1.status === 'blackjack' ? "✨ BJ!" : (p1.status === 'timeout_forfeit' ? "⏳ Forfeit" : "")));
        const p2StatusIcon = p2.status === 'stood' ? "✅ Stood" : (p2.status === 'bust' ? "💥 BUST" : (p2.status === 'blackjack' ? "✨ BJ!" : (p2.status === 'timeout_forfeit' ? "⏳ Forfeit" : "")));

        messageTextHTML = `⚔️ <b>Dice 21 PvP: ${p1MentionHTML} vs ${p2MentionHTML}</b> ⚔️\n` +
            `Bet: <b>${betDisplayHTML_Update}</b> each.\n\n` +
            `Player 1: ${p1MentionHTML}\n` +
            `Hand: ${formatDiceRolls(p1.hand)} Score: <b>${escapeHTML(String(p1.score))}</b> ${p1StatusIcon}\n\n` +
            `Player 2: ${p2MentionHTML}\n` +
            `Hand: ${formatDiceRolls(p2.hand)} Score: <b>${escapeHTML(String(p2.score))}</b> ${p2StatusIcon}\n\n`;

        let currentActionPromptHTML = "";
        const buttonsForKeyboard = [];
        const activePlayer = p1.isTurn ? p1 : (p2.isTurn ? p2 : null);

        if (activePlayer && activePlayer.status === 'playing_turn' && !gameData.status.startsWith('game_over_')) {
            const currentPlayerMentionHTMLSafe = escapeHTML(activePlayer.mention || getPlayerDisplayReference(activePlayer.userObj));
            currentActionPromptHTML = `It's YOUR turn, ${currentPlayerMentionHTMLSafe}! Send 🎲 to <b>Hit</b>, or <b>Stand</b>. (Turn timeout: ${ACTIVE_GAME_TURN_TIMEOUT_MS / 1000}s)`;
            buttonsForKeyboard.push([{ text: `✅ Stand (Score: ${activePlayer.score})`, callback_data: `d21_pvp_stand:${gameData.gameId}:${activePlayer.userId}` }]);
        } else if (gameData.status.startsWith('game_over_')) {
            currentActionPromptHTML = "🏁 Game concluding... Results incoming!";
        } else if (p1.status === 'stood' && p2.status === 'waiting_turn' && !p2.isTurn) {
             currentActionPromptHTML = `Waiting for ${p2MentionHTML} to begin their turn...`;
        } else if (p2.status === 'stood' && p1.status === 'waiting_turn' && !p1.isTurn) {
            currentActionPromptHTML = `Waiting for ${p1MentionHTML} to begin their turn...`;
        } else {
            currentActionPromptHTML = "Waiting for next turn or resolution...";
        }
        messageTextHTML += currentActionPromptHTML;

        if (!gameData.status.startsWith('game_over_')) {
            buttonsForKeyboard.push([{ text: "📖 Game Rules (Dice 21)", callback_data: `${RULES_CALLBACK_PREFIX_CONST}${GAME_IDS.DICE_21}` }]);
        }
        if (buttonsForKeyboard.length > 0) keyboard = { inline_keyboard: buttonsForKeyboard };
    }

    const messageOptions = {
        parse_mode: 'HTML',
        reply_markup: (keyboard.inline_keyboard && keyboard.inline_keyboard.length > 0) ? keyboard : {},
        disable_web_page_preview: true
    };

    const newMainMsg = await safeSendMessage(String(gameData.chatId), messageTextHTML, messageOptions);

    if (newMainMsg?.message_id) {
        gameData.currentMessageId = String(newMainMsg.message_id);
        const activePlayerForTimeout = gameData.initiator.isTurn ? gameData.initiator : (gameData.opponent.isTurn ? gameData.opponent : null);

        if (!isFinal && activePlayerForTimeout && activePlayerForTimeout.status === 'playing_turn' && !gameData.status.startsWith('game_over_')) {
            const timedOutPlayerId = activePlayerForTimeout.userId;
            gameData.currentTurnTimeoutId = setTimeout(async () => {
                const currentTimeoutGameData = activeGames.get(gameData.gameId);
                if (currentTimeoutGameData && currentTimeoutGameData.currentTurnTimeoutId !== null && String(currentTimeoutGameData.currentTurnTimeoutId) === String(gameData.currentTurnTimeoutId) ) { // Check if this specific timeout is still valid
                     handleDice21PvPTurnTimeout(gameData.gameId, timedOutPlayerId);
                } else {
                    console.log(`${logPrefix} Timeout ${gameData.currentTurnTimeoutId} for player ${timedOutPlayerId} was cleared or changed. Ignoring this timeout execution.`);
                }
            }, ACTIVE_GAME_TURN_TIMEOUT_MS);
            console.log(`${logPrefix} New main message sent (ID: ${newMainMsg.message_id}). Player turn timeout SET for ${timedOutPlayerId}: ${gameData.currentTurnTimeoutId}`);
        } else {
            console.log(`${logPrefix} New main message sent (ID: ${newMainMsg.message_id}). Not player's turn, game over, or final summary; no new turn timeout set. Current Status: ${gameData.status}`);
        }
    } else {
        console.error(`${logPrefix} CRITICAL: Failed to send new PvP main game message for GID ${gameData.gameId}.`);
        if (!isFinal && !gameData.status.startsWith('game_over_')) {
            gameData.status = 'game_over_error_ui_update';
            if (gameData.currentTurnTimeoutId) clearTimeout(gameData.currentTurnTimeoutId);
            gameData.currentTurnTimeoutId = null;
            console.error(`${logPrefix} UI update failed for GID ${gameData.gameId}. Game marked as errored. Finalization should occur.`);
            if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL UI FAIL D21 PvP GID:${gameData.gameId}`);
            // Call finalize directly if UI fails mid-game to ensure cleanup and refund if necessary
            await finalizeDice21PvPGame(gameData);
        }
    }

    // Save gameData back to activeGames map only if it's not the final update triggered by finalizeDice21PvPGame
    // finalizeDice21PvPGame will handle deleting it from activeGames after this call.
    if (!isFinal && activeGames.has(gameData.gameId)) {
        activeGames.set(gameData.gameId, gameData);
    }
}
// --- END OF FULL REPLACEMENT for updateDice21PvPGameMessage function ---
// --- START OF NEW processDice21PvPRoll function (for D21 PvP Hits) ---
async function processDice21PvPRoll(gameData, diceValue, rollerId) {
    const logPrefix = `[D21_PvPRoll GID:${gameData.gameId} Roller:${rollerId}]`;
    console.log(`${logPrefix} Processing PvP roll. Value: ${diceValue}`);

    let currentPlayer;
    let otherPlayer;
    let playerKey; // 'initiator' or 'opponent'

    if (gameData.initiator.userId === rollerId && gameData.initiator.isTurn && gameData.initiator.status === 'playing_turn') {
        currentPlayer = gameData.initiator;
        otherPlayer = gameData.opponent;
        playerKey = 'initiator';
    } else if (gameData.opponent.userId === rollerId && gameData.opponent.isTurn && gameData.opponent.status === 'playing_turn') {
        currentPlayer = gameData.opponent;
        otherPlayer = gameData.initiator;
        playerKey = 'opponent';
    } else {
        console.warn(`${logPrefix} Roll from non-active player, not their turn, or incorrect status. Roller: ${rollerId}. Current turns/statuses - I:${gameData.initiator.isTurn}/${gameData.initiator.status}, O:${gameData.opponent.isTurn}/${gameData.opponent.status}. Ignoring roll.`);
        // The dice emoji message itself is deleted by the main message handler
        return;
    }

    // Clear current turn timeout for the active player
    if (gameData.currentTurnTimeoutId) {
        clearTimeout(gameData.currentTurnTimeoutId);
        gameData.currentTurnTimeoutId = null;
        console.log(`${logPrefix} Cleared turn timeout for player ${rollerId}.`);
    }

    currentPlayer.hand.push(diceValue);
    currentPlayer.score += diceValue;
    gameData.lastInteractionTime = Date.now();

    const playerRefHTML = escapeHTML(currentPlayer.mention); // Ensure 'mention' is available or use getPlayerDisplayReference
    const hitMessageText = `🎲 ${playerRefHTML} hits and gets a <b>${diceValue}</b>! Their new score: <b>${currentPlayer.score}</b>.`;

    // Send a temporary message about the roll. This will be cleaned up by the next updateDice21PvPGameMessage call.
    const tempMsg = await safeSendMessage(gameData.chatId, hitMessageText, { parse_mode: 'HTML' });
    if (tempMsg?.message_id) {
        const currentGd = activeGames.get(gameData.gameId); // Re-fetch to be safe
        if (currentGd) {
            currentGd.intermediateMessageIds = [...(currentGd.intermediateMessageIds || []), tempMsg.message_id];
            // No need to activeGames.set(gameData.gameId, currentGd) here just for this,
            // as gameData is a reference and will be set before major state changes or finalization.
        }
    }
    await sleep(1500); // Allow players to see the hit message

    if (currentPlayer.score > DICE_21_TARGET_SCORE) {
        console.log(`${logPrefix} Player ${playerRefHTML} BUSTED with score ${currentPlayer.score}.`);
        currentPlayer.status = 'bust';
        currentPlayer.isTurn = false;
        gameData.status = (playerKey === 'initiator') ? 'game_over_initiator_bust_during_turn' : 'game_over_opponent_bust_during_turn';
        activeGames.set(gameData.gameId, gameData); // Save state before finalizing
        await finalizeDice21PvPGame(gameData);
    } else if (currentPlayer.score === DICE_21_TARGET_SCORE) {
        console.log(`${logPrefix} Player ${playerRefHTML} hit 21. Auto-standing.`);
        currentPlayer.status = 'stood'; // Player stands on 21
        currentPlayer.isTurn = false;

        // Determine next state based on who hit 21
        if (playerKey === 'initiator') { // Initiator hit 21
            if (otherPlayer.status === 'bust' || otherPlayer.status === 'stood' || otherPlayer.status === 'blackjack' || otherPlayer.status === 'timeout_forfeit' || otherPlayer.status === 'lost_to_blackjack') {
                gameData.status = 'game_over_both_played_final'; // Other player already finished
            } else {
                // Other player's turn
                otherPlayer.isTurn = true;
                otherPlayer.status = 'playing_turn';
                gameData.status = 'opponent_turn';
            }
        } else { // Opponent hit 21 (Initiator must have already stood or finished their turn)
            gameData.status = 'game_over_both_played_final';
        }
        activeGames.set(gameData.gameId, gameData); // Save state

        if (gameData.status.startsWith('game_over_')) {
            await finalizeDice21PvPGame(gameData);
        } else {
            await updateDice21PvPGameMessage(gameData); // Update UI for opponent's turn or refresh
        }
    } else {
        // Player hit, score is < 21, their turn continues
        // Status ('playing_turn') remains, isTurn remains true
        activeGames.set(gameData.gameId, gameData); // Save new hand/score
        await updateDice21PvPGameMessage(gameData); // Refresh UI and reset timeout for the same player
    }
}
// --- END OF NEW processDice21PvPRoll function ---

async function handleDice21PvPStand(gameId, userIdWhoStood, originalMessageId, callbackQueryId, chatData) {
    const gameData = activeGames.get(gameId);
    const logPrefix = `[D21_Stand_PvP_V3_GranLimit GID:${gameId} UID:${userIdWhoStood}]`; // V3

    if (callbackQueryId) await bot.answerCallbackQuery(callbackQueryId).catch(() => {});
    if (!gameData || gameData.type !== GAME_IDS.DICE_21_PVP || gameData.status.startsWith('game_over_')) return;

    if (gameData.currentTurnTimeoutId) { 
        clearTimeout(gameData.currentTurnTimeoutId);
        gameData.currentTurnTimeoutId = null;
    }

    let playerStanding, otherPlayer, playerKeyStanding;
    if (gameData.initiator.userId === userIdWhoStood && gameData.initiator.isTurn) {
        playerStanding = gameData.initiator; otherPlayer = gameData.opponent; playerKeyStanding = 'initiator';
    } else if (gameData.opponent.userId === userIdWhoStood && gameData.opponent.isTurn) {
        playerStanding = gameData.opponent; otherPlayer = gameData.initiator; playerKeyStanding = 'opponent';
    } else { 
        // If it's not the player's turn, they shouldn't be able to stand.
        console.warn(`${logPrefix} Stand attempt from non-active player or out of turn.`);
        return; 
    }

    if (playerStanding.status !== 'playing_turn' || (playerStanding.hand && playerStanding.hand.length < 2)) {
        // Cannot stand before initial 2 dice, or if not in playing_turn state
        console.warn(`${logPrefix} Invalid stand attempt. Status: ${playerStanding.status}, Hand length: ${playerStanding.hand?.length}`);
        return;
    }


    playerStanding.status = 'stood'; 
    playerStanding.isTurn = false;
    gameData.lastInteractionTime = Date.now();

    const playerStandingMentionHTML = escapeHTML(playerStanding.mention);
    const standAnnouncementTextHTML = `✋ ${playerStandingMentionHTML} stands with <b>${escapeHTML(String(playerStanding.score))}</b>!`;
    // We don't want to delete the main game message here, updateDice21PvPGameMessage will handle it.
    // Let's send a temporary message if needed or rely on updateDice21PvPGameMessage.
    // For now, let updateDice21PvPGameMessage handle the primary UI update.
    await safeSendMessage(gameData.chatId, standAnnouncementTextHTML, {parse_mode:'HTML'});
    await sleep(1000); // Brief pause for players to see the stand action

    if (playerKeyStanding === 'initiator') { 
        if (otherPlayer.status === 'bust' || otherPlayer.status === 'stood' || otherPlayer.status === 'blackjack' || otherPlayer.status === 'lost_to_blackjack' || otherPlayer.status === 'timeout_forfeit') {
            gameData.status = 'game_over_both_played_final';
        } else {
            otherPlayer.isTurn = true; otherPlayer.status = 'playing_turn';
            gameData.status = 'opponent_turn';
        }
    } else { // Opponent (P2) stood
        // P1 must have already stood, busted, or had blackjack for P2 to be playing.
        gameData.status = 'game_over_both_played_final';
    }
    activeGames.set(gameId, gameData);

    if (gameData.status.startsWith('game_over')) {
        await finalizeDice21PvPGame(gameData);
    } else {
        await updateDice21PvPGameMessage(gameData); 
    }
}

// CORRECTED finalizeDice21PvPGame (with Deadlock and Referral Fixes)
async function finalizeDice21PvPGame(gameData) {
    const { gameId, chatId, betAmount, initiator, opponent, chatType, status: finalStatus, _origin_key_for_limits } = gameData;
    const logPrefix = `[D21_PvP_Finalize_V7_FullFix GID:${gameData.gameId || 'UNKNOWN_GAME_ID'}]`;
    const activeGameKeyToClear = _origin_key_for_limits || GAME_IDS.DICE_21_PVP;
    let allNotificationsToSend = [];

    let solPrice;
    try {
        solPrice = await getSolUsdPrice();
    } catch (priceError) {
        console.error(`${logPrefix} CRITICAL: Could not get SOL price. Level-up/milestone checks will be skipped. Error: ${priceError.message}`);
        solPrice = 0;
    }

    activeGames.delete(gameData.gameId);
    if (chatType && chatType !== 'private') {
        await updateGroupGameDetails(chatId, { removeThisId: gameId }, activeGameKeyToClear, null);
    }

    if (!initiator || !opponent) {
        console.error(`${logPrefix} CRITICAL: initiator or opponent object missing.`);
        await safeSendMessage(chatId, "⚙️ Critical error resolving Dice 21 PvP. Admin notified.", {parse_mode: "HTML"});
        return;
    }

    const p1 = initiator; const p2 = opponent;
    const p1MentionHTML = escapeHTML(p1.mention || getPlayerDisplayReference(p1.userObj));
    const p2MentionHTML = escapeHTML(p2.mention || getPlayerDisplayReference(p2.userObj));
    let p1Payout = 0n; let p2Payout = 0n;
    let p1LedgerCode = 'loss_dice21_pvp'; let p2LedgerCode = 'loss_dice21_pvp';
    let resultTextHTML = "";
    let gameOutcomeTextForLog = "";
    const totalPotLamports = betAmount * 2n;
    const betDisplayHTML_Final = escapeHTML(await formatBalanceForDisplay(betAmount, 'USD'));
    const target = DICE_21_TARGET_SCORE;
    let titleEmoji = "🏁";
    let isConclusiveOutcome = false;

    const p1Blackjack = (p1.score === DICE_21_TARGET_SCORE && p1.hand && p1.hand.length === 2);
    const p2Blackjack = (p2.score === DICE_21_TARGET_SCORE && p2.hand && p2.hand.length === 2);

    if (finalStatus === 'game_over_error_deal_initiator' || finalStatus === 'game_over_error_deal_opponent' || finalStatus === 'game_over_error_ui_update' || finalStatus === 'game_over_error_helper_bot' || finalStatus === 'game_over_error_timeout_logic') {
        isConclusiveOutcome = false;
        titleEmoji = "⚙️"; resultTextHTML = `A technical error occurred. Bets (<b>${betDisplayHTML_Final}</b> each) refunded.`;
        p1Payout = betAmount; p2Payout = betAmount;
        p1LedgerCode = 'refund_dice21_pvp_error'; p2LedgerCode = 'refund_dice21_pvp_error';
        gameOutcomeTextForLog = `Error - bets refunded (Status: ${finalStatus})`;
    } else if (finalStatus === 'game_over_initiator_timeout_forfeit') {
        isConclusiveOutcome = true;
        titleEmoji = "⏳🏆"; resultTextHTML = `${p1MentionHTML} timed out! ${p2MentionHTML} wins <b>${escapeHTML(await formatBalanceForDisplay(totalPotLamports, 'USD'))}</b> by default!`;
        p2Payout = totalPotLamports; p2LedgerCode = 'win_dice21_pvp_forfeit'; p1LedgerCode = 'loss_dice21_pvp_forfeit';
        gameOutcomeTextForLog = `P2 wins by P1 forfeit`;
    } else if (finalStatus === 'game_over_opponent_timeout_forfeit') {
        isConclusiveOutcome = true;
        titleEmoji = "⏳🏆"; resultTextHTML = `${p2MentionHTML} timed out! ${p1MentionHTML} wins <b>${escapeHTML(await formatBalanceForDisplay(totalPotLamports, 'USD'))}</b> by default!`;
        p1Payout = totalPotLamports; p1LedgerCode = 'win_dice21_pvp_forfeit'; p2LedgerCode = 'loss_dice21_pvp_forfeit';
        gameOutcomeTextForLog = `P1 wins by P2 forfeit`;
    } else if (finalStatus === 'game_over_push_both_blackjack' || (p1Blackjack && p2Blackjack)) {
        isConclusiveOutcome = false;
        titleEmoji = "✨⚖️✨"; resultTextHTML = `DOUBLE BLACKJACK! Both hit <b>${target}</b>! PUSH. Bets (<b>${betDisplayHTML_Final}</b> each) returned.`;
        p1Payout = betAmount; p2Payout = betAmount;
        p1LedgerCode = 'push_dice21_pvp_blackjack'; p2LedgerCode = 'push_dice21_pvp_blackjack';
        gameOutcomeTextForLog = `Push - Double Blackjack`;
    } else if (finalStatus === 'game_over_initiator_blackjack' || p1Blackjack) {
        isConclusiveOutcome = true;
        titleEmoji = "✨🏆"; const blackjackProfitP1 = betAmount * 15n / 10n; p1Payout = betAmount + blackjackProfitP1;
        resultTextHTML = `${p1MentionHTML} hits BLACKJACK! Wins <b>${escapeHTML(await formatBalanceForDisplay(p1Payout, 'USD'))}</b>!`;
        p1LedgerCode = 'win_dice21_pvp_blackjack'; p2LedgerCode = 'loss_dice21_pvp_vs_blackjack';
        gameOutcomeTextForLog = `P1 Blackjack wins`;
    } else if (finalStatus === 'game_over_opponent_blackjack' || p2Blackjack) {
        isConclusiveOutcome = true;
        titleEmoji = "✨🏆"; const blackjackProfitP2 = betAmount * 15n / 10n; p2Payout = betAmount + blackjackProfitP2;
        resultTextHTML = `${p2MentionHTML} hits BLACKJACK! Wins <b>${escapeHTML(await formatBalanceForDisplay(p2Payout, 'USD'))}</b>!`;
        p2LedgerCode = 'win_dice21_pvp_blackjack'; p1LedgerCode = 'loss_dice21_pvp_vs_blackjack';
        gameOutcomeTextForLog = `P2 Blackjack wins`;
    } else if (p1.status === 'bust' || finalStatus === 'game_over_initiator_bust_during_turn') {
        isConclusiveOutcome = true;
        titleEmoji = "💥🏆"; p2Payout = totalPotLamports;
        resultTextHTML = `${p1MentionHTML} BUSTED (<b>${escapeHTML(String(p1.score))}</b>)! ${p2MentionHTML} wins <b>${escapeHTML(await formatBalanceForDisplay(p2Payout, 'USD'))}</b>!`;
        p2LedgerCode = 'win_dice21_pvp_opponent_bust'; p1LedgerCode = 'loss_dice21_pvp_bust';
        gameOutcomeTextForLog = `P2 wins - P1 busts (P1: ${p1.score})`;
    } else if (p2.status === 'bust' || finalStatus === 'game_over_opponent_bust_during_turn') {
        isConclusiveOutcome = true;
        titleEmoji = "💥🏆"; p1Payout = totalPotLamports;
        resultTextHTML = `${p2MentionHTML} BUSTED (<b>${escapeHTML(String(p2.score))}</b>)! ${p1MentionHTML} wins <b>${escapeHTML(await formatBalanceForDisplay(p1Payout, 'USD'))}</b>!`;
        p1LedgerCode = 'win_dice21_pvp_opponent_bust'; p2LedgerCode = 'loss_dice21_pvp_bust';
        gameOutcomeTextForLog = `P1 wins - P2 busts (P2: ${p2.score})`;
    } else {
        const p1_finalScore = p1.score; const p2_finalScore = p2.score;
        if (p1_finalScore > p2_finalScore) {
            isConclusiveOutcome = true;
            titleEmoji = "🏆"; p1Payout = totalPotLamports;
            resultTextHTML = `${p1MentionHTML} WINS with <b>${escapeHTML(String(p1.score))}</b> vs ${p2MentionHTML}'s <b>${escapeHTML(String(p2.score))}</b>! Wins <b>${escapeHTML(await formatBalanceForDisplay(p1Payout, 'USD'))}</b>!`;
            p1LedgerCode = 'win_dice21_pvp_score'; p2LedgerCode = 'loss_dice21_pvp_score';
            gameOutcomeTextForLog = `P1 wins by score (${p1.score} vs ${p2.score})`;
        } else if (p2_finalScore > p1_finalScore) {
            isConclusiveOutcome = true;
            titleEmoji = "🏆"; p2Payout = totalPotLamports;
            resultTextHTML = `${p2MentionHTML} WINS with <b>${escapeHTML(String(p2.score))}</b> vs ${p1MentionHTML}'s <b>${escapeHTML(String(p1.score))}</b>! Wins <b>${escapeHTML(await formatBalanceForDisplay(p2Payout, 'USD'))}</b>!`;
            p2LedgerCode = 'win_dice21_pvp_score'; p1LedgerCode = 'loss_dice21_pvp_score';
            gameOutcomeTextForLog = `P2 wins by score (${p2.score} vs ${p1.score})`;
        } else { // Push
            isConclusiveOutcome = false;
            titleEmoji = "⚖️"; resultTextHTML = `PUSH! Tied at <b>${escapeHTML(String(p1.score))}</b>! Bets (<b>${betDisplayHTML_Final}</b> each) returned.`;
            p1Payout = betAmount; p2Payout = betAmount;
            p1LedgerCode = 'push_dice21_pvp'; p2LedgerCode = 'push_dice21_pvp';
            gameOutcomeTextForLog = `Push (Draw at ${p1.score})`;
        }
    }

    let dbErrorTextForUserHTML = ""; let client = null;
    try {
        client = await pool.connect(); await client.query('BEGIN');
        const actualGameLogId = await logGameResultToGamesTable(
            client, activeGameKeyToClear, chatId, p1.userId, [p1.userId, p2.userId], betAmount, gameOutcomeTextForLog, 0n
        );

        // --- DEADLOCK PREVENTION: Sort players by ID before locking/updating ---
        const [playerA, playerB] = [p1, p2].sort((a, b) => String(a.userId).localeCompare(String(b.userId)));
        console.log(`${logPrefix} Locking order established. Player A: ${playerA.userId}, Player B: ${playerB.userId}`);

        const payoutA = (playerA.userId === p1.userId) ? p1Payout : p2Payout;
        const payoutB = (playerB.userId === p1.userId) ? p1Payout : p2Payout;
        const ledgerCodeA = (playerA.userId === p1.userId) ? p1LedgerCode : p2LedgerCode;
        const ledgerCodeB = (playerB.userId === p1.userId) ? p1LedgerCode : p2LedgerCode;

        // Process Player A first
        const p1Update = await updateUserBalanceAndLedger(client, playerA.userId, payoutA, ledgerCodeA, { game_log_id: actualGameLogId, opponent_id_custom_field: playerB.userId, player_score: playerA.score, opponent_score: playerB.score, original_bet_amount: betAmount.toString() }, `Dice 21 PvP vs ${playerB.displayName || playerB.userId}`, solPrice);
        if(!p1Update.success) throw new Error(`Player A (${playerA.userId}) update failed: ${p1Update.error}`);
        if(p1Update.notifications) allNotificationsToSend.push(...p1Update.notifications);

        // Process Player B second
        const p2Update = await updateUserBalanceAndLedger(client, playerB.userId, payoutB, ledgerCodeB, { game_log_id: actualGameLogId, opponent_id_custom_field: playerA.userId, player_score: playerB.score, opponent_score: playerA.score, original_bet_amount: betAmount.toString() }, `Dice 21 PvP vs ${playerA.displayName || playerA.userId}`, solPrice);
        if(!p2Update.success) throw new Error(`Player B (${playerB.userId}) update failed: ${p2Update.error}`);
        if(p2Update.notifications) allNotificationsToSend.push(...p2Update.notifications);

        if (isConclusiveOutcome) {
            // --- START OF MODIFICATION ---

            // 1. ADDED: Check initial bet bonus for both players.
            if (typeof processQualifyingBetAndInitialBonus === 'function') {
                await processQualifyingBetAndInitialBonus(client, p1.userId, betAmount, gameId);
                await processQualifyingBetAndInitialBonus(client, p2.userId, betAmount, gameId);
            }

            // 2. MODIFIED: Correctly call level and milestone checks for both players.
            if (p1Update.success && p1Update.newTotalWageredLamports !== undefined) {
                const p1LevelNotifications = await checkAndUpdateUserLevel(client, p1.userId, p1Update.newTotalWageredLamports, solPrice, chatId);
                allNotificationsToSend.push(...p1LevelNotifications);
                const p1MilestoneResult = await processWagerMilestoneBonus(client, p1.userId, p1Update.newTotalWageredLamports, solPrice);
                if (!p1MilestoneResult.success) console.warn(`${logPrefix} Failed to process milestone bonus for P1: ${p1MilestoneResult.error}`);
            }
            if (p2Update.success && p2Update.newTotalWageredLamports !== undefined) {
                const p2LevelNotifications = await checkAndUpdateUserLevel(client, p2.userId, p2Update.newTotalWageredLamports, solPrice, chatId);
                allNotificationsToSend.push(...p2LevelNotifications);
                const p2MilestoneResult = await processWagerMilestoneBonus(client, p2.userId, p2Update.newTotalWageredLamports, solPrice);
                if (!p2MilestoneResult.success) console.warn(`${logPrefix} Failed to process milestone bonus for P2: ${p2MilestoneResult.error}`);
            }

            // --- END OF MODIFICATION ---
        }
        
        await client.query('COMMIT');
    } catch (e) {
        if (client) await client.query('ROLLBACK').catch(()=>{});
        dbErrorTextForUserHTML = `\n\n⚠️ <b>Balance Update Error.</b> Staff notified.`;
        console.error(`${logPrefix} CRITICAL DB error: ${e.message}`);
        if (typeof notifyAdmin === 'function') notifyAdmin(`🚨 CRITICAL D21 PvP Payout Failure 🚨\nGame ID: <code>${escapeHTML(gameId)}</code>\nError: ${escapeHTML(e.message)}. MANUAL CHECK REQUIRED.`, {parse_mode: 'HTML'});
    } finally { if (client) client.release(); }

    // Send all collected notifications AFTER the transaction is closed
    for (const notification of allNotificationsToSend) {
        if (notification.to === ADMIN_USER_ID && typeof notifyAdmin === 'function') {
            await notifyAdmin(notification.text, notification.options).catch(err => console.error(`Failed to send admin notification: ${err.message}`));
        } else {
            await safeSendMessage(notification.to, notification.text, notification.options).catch(err => console.error(`Failed to send game-related notification to ${notification.to}: ${err.message}`));
        }
    }

    const p1StatusIconDisplay = p1.status === 'bust' ? "💥BUST" : (p1Blackjack ? "✨BJ!" : (p1.status === 'stood' ? `✅${p1.score}` : (p1.status === 'timeout_forfeit' ? '⏳Forfeit' : `${p1.score}`)));
    const p2StatusIconDisplay = p2.status === 'bust' ? "💥BUST" : (p2Blackjack ? "✨BJ!" : (p2.status === 'stood' ? `✅${p2.score}` : (p2.status === 'timeout_forfeit' ? '⏳Forfeit' : `${p2.score}`)));

    const fullResultMessageHTML = `${titleEmoji} <b>Dice 21 PvP - Game Over!</b> ${titleEmoji}\n\n` +
        `<i>${p1MentionHTML} vs ${p2MentionHTML} (Bet: ${betDisplayHTML_Final} each)</i>\n\n` +
        `<b>${p1MentionHTML}:</b> ${p1StatusIconDisplay} ${formatDiceRolls(p1.hand || [])}\n` +
        `<b>${p2MentionHTML}:</b> ${p2StatusIconDisplay} ${formatDiceRolls(p2.hand || [])}\n\n` +
        `------------------------------------\n${resultTextHTML}${dbErrorTextForUserHTML}`;

    const finalKeyboard = createPostGameKeyboard(activeGameKeyToClear, gameData.betAmount);
    await safeSendMessage(gameData.chatId, fullResultMessageHTML, { parse_mode: 'HTML', reply_markup: finalKeyboard });

    const messagesToDelete = [...(gameData.intermediateMessageIds || [])];
    if (gameData.currentMessageId) messagesToDelete.push(gameData.currentMessageId);
    for (const msgId of messagesToDelete) {
        if (bot && msgId) await bot.deleteMessage(gameData.chatId, Number(msgId)).catch(e => {});
    }
}

// New function: handleDice21PvPTurnTimeout
async function handleDice21PvPTurnTimeout(gameId, timedOutPlayerId) {
    const logPrefix = `[D21_PvP_TimeoutHdlr_V2 GID:${gameId} TimedOutUID:${timedOutPlayerId}]`;
    const gameData = activeGames.get(gameId);

    if (!gameData || gameData.type !== GAME_IDS.DICE_21_PVP || gameData.status.startsWith('game_over_')) {
        if (gameData && gameData.currentTurnTimeoutId) clearTimeout(gameData.currentTurnTimeoutId);
        return;
    }

    const activePlayer = gameData.initiator.isTurn ? gameData.initiator : (gameData.opponent.isTurn ? gameData.opponent : null);
    if (!activePlayer || activePlayer.userId !== timedOutPlayerId || activePlayer.status !== 'playing_turn') {
        // Timeout for wrong player or game not awaiting their action
        // Clear timeout if it belongs to this gameData, to prevent zombies
        if (gameData.currentTurnTimeoutId) {
            clearTimeout(gameData.currentTurnTimeoutId);
            gameData.currentTurnTimeoutId = null;
            // No need to save to activeGames here, as no state change relevant to this timeout event.
        }
        return; 
    }
    console.log(`${logPrefix} Processing turn timeout for player ${timedOutPlayerId}.`);

    if (gameData.currentTurnTimeoutId) clearTimeout(gameData.currentTurnTimeoutId);
    gameData.currentTurnTimeoutId = null;

    let timedOutPlayerMentionHTML, opponentMentionHTML;
    if (gameData.initiator.userId === timedOutPlayerId) {
        gameData.initiator.status = 'timeout_forfeit'; 
        gameData.opponent.status = 'win_by_forfeit'; // Opponent wins
        gameData.status = 'game_over_initiator_timeout_forfeit';
        timedOutPlayerMentionHTML = escapeHTML(gameData.initiator.mention); 
        opponentMentionHTML = escapeHTML(gameData.opponent.mention);
    } else { // Opponent timed out
        gameData.opponent.status = 'timeout_forfeit'; 
        gameData.initiator.status = 'win_by_forfeit'; // Initiator wins
        gameData.status = 'game_over_opponent_timeout_forfeit';
        timedOutPlayerMentionHTML = escapeHTML(gameData.opponent.mention); 
        opponentMentionHTML = escapeHTML(gameData.initiator.mention);
    }
    gameData.initiator.isTurn = false; gameData.opponent.isTurn = false; // No one's turn now
    activeGames.set(gameId, gameData); // Save the new statuses

    if (gameData.currentMessageId && bot) await bot.deleteMessage(gameData.chatId, gameData.currentMessageId).catch(()=>{});
    gameData.currentMessageId = null; // Message will be replaced by finalize

    const timeoutMessageToChatHTML = `⏳ Player ${timedOutPlayerMentionHTML} ran out of time to make a move!<br>${opponentMentionHTML} wins the Dice 21 duel by default.`;
    // Send a temporary message, finalize will send the full result card
    const sentMsg = await safeSendMessage(gameData.chatId, timeoutMessageToChatHTML, { parse_mode: 'HTML' });
    if(sentMsg?.message_id && activeGames.has(gameId)) { // Update gameMessageId if needed for finalize
        const gd = activeGames.get(gameId); 
        if(gd) gd.currentMessageId = sentMsg.message_id; // Store this temp message ID
    }
    await sleep(1000); // Brief pause
    await finalizeDice21PvPGame(gameData); // Finalize handles DB and proper result message
}
// --- End of Part 5b section 2 ---
// --- Start of Part 5c, Section 1 (FULLY UPDATED FOR HELPER BOT DICE ROLLS & HTML MESSAGING + DEBUG LOGS) ---
// index.js - Part 5c, Section 1: Over/Under 7 Game Logic & Handlers
// (This entire block is placed after Original Part 5b, Section 2 in the new order)
//-------------------------------------------------------------------------------------------------
// Assumed dependencies from previous Parts (ensure escapeHTML is defined elsewhere)

// --- Over/Under 7 Game Logic ---

async function handleStartOverUnder7Command(msg, betAmountLamports) {
    const userId = String(msg.from.id || msg.from.telegram_id);
    const chatId = String(msg.chat.id);
    const LOG_PREFIX_OU7_START = `[OU7_Start_V3_Issue1And2 UID:${userId} CH:${chatId}]`; // Updated version

    const activeUserGameCheck = await checkUserActiveGameLimit(userId, false, null); 
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = escapeHTML(getPlayerDisplayReference(msg.from));
        const blockingGameType = activeUserGameCheck.details.type;
        const cleanGameName = getCleanGameName(blockingGameType); 
        const alertMessage = `✨ ${userDisplayName}, you already have a pending offer or active game for <b>${escapeHTML(cleanGameName)}</b>. ✨`;
        await safeSendMessage(chatId, alertMessage, { parse_mode: 'HTML' });
        return;
    }

    if (typeof betAmountLamports !== 'bigint' || betAmountLamports <= 0n) {
        console.error(`${LOG_PREFIX_OU7_START} Invalid betAmountLamports: ${betAmountLamports}. Sending error message.`);
        await safeSendMessage(chatId, "🎲 Oops! There was an issue with the bet amount for Over/Under 7. Please try starting the game again with a valid bet.", { parse_mode: 'HTML' });
        return;
    }

    let userObj = await getOrCreateUser(userId, msg.from.username, msg.from.first_name, msg.from.last_name);
    if (!userObj) {
        console.warn(`${LOG_PREFIX_OU7_START} Failed to get/create user. Sending error message.`);
        await safeSendMessage(chatId, "😕 Apologies! We couldn't fetch your player profile to start Over/Under 7. Please try <code>/start</code> again.", { parse_mode: 'HTML' });
        return;
    }
    const playerRefHTML = escapeHTML(getPlayerDisplayReference(userObj));
    const betDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(betAmountLamports, 'USD'));

    if (BigInt(userObj.balance) < betAmountLamports) {
        const needed = betAmountLamports - BigInt(userObj.balance);
        const neededDisplayHTML = escapeHTML(await formatBalanceForDisplay(needed, 'USD'));
        await safeSendMessage(chatId, `${playerRefHTML}, your casino funds are a bit shy for an Over/Under 7 game at <b>${betDisplayUSD_HTML}</b>. You'd need approximately <b>${neededDisplayHTML}</b> more. Care to top up?`, {
            parse_mode: 'HTML',
            reply_markup: { inline_keyboard: [[{ text: "💰 Add Funds (DM)", callback_data: QUICK_DEPOSIT_CALLBACK_ACTION_CONST }]] }
        });
        return;
    }

    const gameSession = await getGroupSession(chatId, msg.chat.title);
    const activeGameKey = GAME_IDS.OVER_UNDER_7; 
    const currentActiveOU7Games = gameSession.activeGamesByTypeInGroup.get(activeGameKey) || [];
    const limitActive = GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[activeGameKey] || 1;

    if (currentActiveOU7Games.length >= limitActive) {
        await safeSendMessage(chatId, `⏳ ${playerRefHTML}, the limit of ${limitActive} concurrent Over/Under 7 game(s) in this group has been reached. Please wait.`, { parse_mode: 'HTML' });
        return;
    }

    const gameId = generateGameId(GAME_IDS.OVER_UNDER_7);
    let client = null;
    let totalWageredForLevelCheck; 

    try {
        client = await pool.connect();
        await client.query('BEGIN');
        const balanceUpdateResult = await updateUserBalanceAndLedger(
            client, userId, BigInt(-betAmountLamports),
            'bet_placed_ou7', { game_id_custom_field: gameId }, // game_id_custom_field for ledger note
            `Bet for Over/Under 7 game ${gameId}`
        );

        if (!balanceUpdateResult || !balanceUpdateResult.success) {
            await client.query('ROLLBACK');
            console.error(`${LOG_PREFIX_OU7_START} Wager placement failed: ${balanceUpdateResult?.error || 'Unknown error'}.`);
            await safeSendMessage(chatId, `${playerRefHTML}, your Over/Under 7 wager of <b>${betDisplayUSD_HTML}</b> couldn't be placed: <code>${escapeHTML(balanceUpdateResult?.error || "Wallet error")}</code>.`, { parse_mode: 'HTML' });
            return;
        }
        totalWageredForLevelCheck = balanceUpdateResult.newTotalWageredLamports;
        await client.query('COMMIT'); 
        userObj.balance = balanceUpdateResult.newBalanceLamports;
    } catch (dbError) {
        if (client) await client.query('ROLLBACK').catch(rbErr => console.error(`${LOG_PREFIX_OU7_START} DB Rollback Error: ${rbErr.message}`));
        console.error(`${LOG_PREFIX_OU7_START} Database error during OU7 bet processing: ${dbError.message}`);
        await safeSendMessage(chatId, "⚙️ A database disturbance prevented your Over/Under 7 game. Please try again.", { parse_mode: 'HTML' });
        return;
    } finally {
        if (client) client.release();
    }

    const gameData = {
        type: GAME_IDS.OVER_UNDER_7, gameId, chatId, userId,
        playerRef: playerRefHTML, userObj, betAmount: betAmountLamports,
        playerChoice: null, diceRolls: [], diceSum: null,
        status: 'waiting_player_choice', gameMessageId: null,
        lastInteractionTime: Date.now(),
        timeoutId: null,
        totalWageredForLevelCheck: totalWageredForLevelCheck // Store for later use
    };
    activeGames.set(gameId, gameData);
    await updateGroupGameDetails(chatId, gameId, activeGameKey, betAmountLamports);
    console.log(`${LOG_PREFIX_OU7_START} Game ${gameId} started, active games lock updated for ${activeGameKey}. Status: ${gameData.status}`);

    const titleHTML = `🎲 <b>Over/Under 7 Showdown</b> 🎲`;
    const initialMessageTextHTML = `${titleHTML}\n\n${playerRefHTML}, you've wagered <b>${betDisplayUSD_HTML}</b>. The dice await!\n\nPredict the sum of <b>${escapeHTML(String(OU7_DICE_COUNT))} dice</b>: Under 7, Exactly 7, or Over 7? Make your choice below! 👇\n<i>(You have ${INSTANT_GAME_ACTION_TIMEOUT_MS / 1000} seconds to choose)</i>`;
    const keyboard = {
        inline_keyboard: [
            [{ text: "📉 Under 7 (Sum 2-6)", callback_data: `ou7_choice:${gameId}:under` }],
            [{ text: "🎯 Exactly 7 (BIG PAYOUT!)", callback_data: `ou7_choice:${gameId}:seven` }],
            [{ text: "📈 Over 7 (Sum 8-12)", callback_data: `ou7_choice:${gameId}:over` }],
            [{ text: `📖 Game Rules`, callback_data: `${RULES_CALLBACK_PREFIX_CONST}${GAME_IDS.OVER_UNDER_7}` }]
        ]
    };
    const sentMessage = await safeSendMessage(chatId, initialMessageTextHTML, { parse_mode: 'HTML', reply_markup: keyboard });

    if (sentMessage?.message_id) {
        gameData.gameMessageId = sentMessage.message_id;
        gameData.timeoutId = setTimeout(async () => {
            if (typeof handleOverUnder7ChoiceTimeout === 'function') {
                handleOverUnder7ChoiceTimeout(gameId);
            } else {
                console.error(`${LOG_PREFIX_OU7_START} CRITICAL: handleOverUnder7ChoiceTimeout function not defined for game ${gameId}!`);
                const fallbackGameData = activeGames.get(gameId);
                if (fallbackGameData && fallbackGameData.status === 'waiting_player_choice') {
                    activeGames.delete(gameId);
                    await updateGroupGameDetails(chatId, { removeThisId: gameId }, activeGameKey, null);
                     if(fallbackGameData.gameMessageId && bot) await bot.deleteMessage(chatId, fallbackGameData.gameMessageId).catch(()=>{});
                    await safeSendMessage(chatId, `${playerRefHTML}, your OU7 game timed out due to an internal error. Bet may be lost. Contact support.`, {parse_mode:'HTML'});
                }
            }
        }, INSTANT_GAME_ACTION_TIMEOUT_MS); 
    } else {
        console.error(`${LOG_PREFIX_OU7_START} Failed to send OU7 game message for ${gameId}. Bet was taken. Refunding.`);
        let refundClient = null;
        try {
            refundClient = await pool.connect(); await refundClient.query('BEGIN');
            await updateUserBalanceAndLedger(refundClient, userId, betAmountLamports, 'refund_ou7_setup_fail', { game_id_custom_field: gameId }, `Refund OU7 game ${gameId} (message send fail)`);
            await refundClient.query('COMMIT');
        } catch (err) {
            if (refundClient) await refundClient.query('ROLLBACK');
            console.error(`${LOG_PREFIX_OU7_START} CRITICAL: Refund failed for ${gameId}: ${err.message}`);
        } finally { if (refundClient) refundClient.release(); }
        activeGames.delete(gameId);
        await updateGroupGameDetails(chatId, { removeThisId: gameId }, activeGameKey, null); 
    }
}

// NEW: Timeout Handler for OU7 initial choice
async function handleOverUnder7ChoiceTimeout(gameId) {
    const logPrefix = `[OU7_ChoiceTimeout_V2_Issue1And2 GID:${gameId}]`; // V2
    const gameData = activeGames.get(gameId);

    if (!gameData || gameData.type !== GAME_IDS.OVER_UNDER_7 || gameData.status !== 'waiting_player_choice') {
        console.log(`${logPrefix} Timeout for ${gameId} but game not found or not in correct state. Status: ${gameData?.status}.`);
        if (gameData && gameData.timeoutId) clearTimeout(gameData.timeoutId);
        return;
    }
    console.log(`${logPrefix} Player ${gameData.userId} timed out for OU7 choice. Game forfeited, bet lost.`);

    if (gameData.timeoutId) clearTimeout(gameData.timeoutId);
    gameData.timeoutId = null;

    activeGames.delete(gameId); 
    await updateGroupGameDetails(String(gameData.chatId), { removeThisId: gameId }, GAME_IDS.OVER_UNDER_7, null); 

    let client = null;
    let balanceUpdateSucceeded = false;
    try {
        client = await pool.connect();
        await client.query('BEGIN');

        // *** NEW: Log game to 'games' table ***
        const actualGameLogId = await logGameResultToGamesTable(
            client,
            GAME_IDS.OVER_UNDER_7,
            gameData.chatId,
            gameData.userId,
            [gameData.userId],
            gameData.betAmount,
            "Player Forfeit (Choice Timeout)",
            0n // No jackpot contribution
        );
        // *** END OF NEW ***

        const forfeitUpdateResult = await updateUserBalanceAndLedger(
            client, gameData.userId, 0n, 
            'loss_ou7_choice_timeout', 
            { game_log_id: actualGameLogId, original_bet_amount: gameData.betAmount.toString() }, // Pass actualGameLogId
            `Player forfeited OU7 game ${gameId} due to choice timeout. Bet lost.`
        );

        if (forfeitUpdateResult.success) {
            balanceUpdateSucceeded = true;
            // *** MODIFIED PART: Call checkAndUpdateUserLevel ***
            // A timeout forfeit means the wager was played (and lost).
            // Use totalWageredForLevelCheck stored in gameData.
            if (gameData.totalWageredForLevelCheck !== undefined && typeof checkAndUpdateUserLevel === 'function') {
                await checkAndUpdateUserLevel(client, gameData.userId, gameData.totalWageredForLevelCheck);
            }
            // *** END OF MODIFIED PART ***
            await client.query('COMMIT');
        } else {
            await client.query('ROLLBACK');
            throw new Error(forfeitUpdateResult.error || "DB Error logging OU7 timeout forfeit.");
        }
    } catch (dbError) {
        if (client && !balanceUpdateSucceeded) await client.query('ROLLBACK').catch(() => {});
        console.error(`${logPrefix} DB error logging forfeit for OU7 game ${gameId}: ${dbError.message}`);
        if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL OU7 TIMEOUT FORFEIT LOGGING FAILURE GID: ${gameId}, User: ${gameData.userId}. Error: ${escapeMarkdownV2(dbError.message)}`, {parse_mode: 'MarkdownV2'});
    } finally {
        if (client) client.release();
    }

    const playerRefHTML = gameData.playerRef || escapeHTML(getPlayerDisplayReference(gameData.userObj || { id: gameData.userId, first_name: "Player" }));
    const betDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(gameData.betAmount, 'USD'));
    const timeoutMessageText = `⏰ ${playerRefHTML}, your Over/Under 7 game (Bet: <b>${betDisplayUSD_HTML}</b>) timed out as no choice was made.\nYour bet has been forfeited.`;

    const messageIdToEdit = Number(gameData.gameMessageId);
    if (bot && messageIdToEdit) {
        await bot.editMessageText(timeoutMessageText, {
            chat_id: String(gameData.chatId), message_id: messageIdToEdit,
            parse_mode: 'HTML', reply_markup: createPostGameKeyboard(GAME_IDS.OVER_UNDER_7, gameData.betAmount)
        }).catch(async (err) => {
            await safeSendMessage(String(gameData.chatId), timeoutMessageText, { parse_mode: 'HTML', reply_markup: createPostGameKeyboard(GAME_IDS.OVER_UNDER_7, gameData.betAmount) });
        });
    } else {
        await safeSendMessage(String(gameData.chatId), timeoutMessageText, { parse_mode: 'HTML', reply_markup: createPostGameKeyboard(GAME_IDS.OVER_UNDER_7, gameData.betAmount) });
    }
}

// CORRECTED handleOverUnder7Choice (with Referral Fixes)
async function handleOverUnder7Choice(gameId, choice, userObj, originalMessageIdFromCallback, callbackQueryId, msgContext) {
    const userId = String(userObj.telegram_id);
    const chatId = String(msgContext.chatId || originalChatIdFromCallback);
    const LOG_PREFIX_OU7_CHOICE = `[OU7_Choice_V5_FullFix UID:${userId} GID:${gameId}]`;
    let allNotificationsToSend = [];

    let solPrice;
    try {
        solPrice = await getSolUsdPrice();
    } catch (priceError) {
        console.error(`${LOG_PREFIX_OU7_CHOICE} CRITICAL: Could not get SOL price. Level-up/milestone checks will be skipped. Error: ${priceError.message}`);
        solPrice = 0;
    }

    const gameData = activeGames.get(gameId);

    if (!gameData || gameData.userId !== userId || gameData.status !== 'waiting_player_choice' || (gameData.gameMessageId && Number(gameData.gameMessageId) !== Number(originalMessageIdFromCallback))) {
        await bot.answerCallbackQuery(callbackQueryId, { text: "⏳ This Over/Under 7 game action is outdated or not yours.", show_alert: true });
        return;
    }

    if (gameData.timeoutId) {
        clearTimeout(gameData.timeoutId);
        gameData.timeoutId = null;
    }

    const choiceTextDisplay = choice.charAt(0).toUpperCase() + choice.slice(1);
    await bot.answerCallbackQuery(callbackQueryId, { text: `🎯 Locked In: ${choiceTextDisplay} 7! Requesting dice...` }).catch(() => {});

    gameData.playerChoice = choice;
    gameData.status = 'rolling_dice_waiting_helper';
    activeGames.set(gameId, gameData);

    const { playerRef, betAmount, totalWageredForLevelCheck } = gameData;
    const playerRefHTML = escapeHTML(playerRef);
    const betDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(betAmount, 'USD'));

    const titleRollingHTML = `🎲 <b>Over/Under 7 - Dice Rolling via Helper!</b> 🎲`;
    let rollingMessageTextHTML = `${titleRollingHTML}\n\n${playerRefHTML} bets <b>${betDisplayUSD_HTML}</b> on the sum being <b>${escapeHTML(choiceTextDisplay)} 7</b>.\nThe Helper Bot is now rolling the dice... This may take a moment! 🤞`;

    let currentMessageId = gameData.gameMessageId;
    if (currentMessageId && bot) {
        try {
            await bot.editMessageText(rollingMessageTextHTML, { chat_id: String(chatId), message_id: Number(currentMessageId), parse_mode: 'HTML', reply_markup: {} });
        } catch (e) {
            const newMsg = await safeSendMessage(String(chatId), rollingMessageTextHTML, { parse_mode: "HTML" });
            currentMessageId = newMsg?.message_id;
        }
    } else {
        const newMsg = await safeSendMessage(String(chatId), rollingMessageTextHTML, { parse_mode: "HTML" });
        currentMessageId = newMsg?.message_id;
    }
    if(activeGames.has(gameId)) activeGames.get(gameId).gameMessageId = currentMessageId;

    let diceRolls = [];
    let diceSum = 0;
    let helperBotError = null;

    for (let i = 0; i < OU7_DICE_COUNT; i++) {
        if (isShuttingDown) { helperBotError = "Shutdown during OU7 dice requests."; break; }
        const rollResult = await getSingleDiceRollViaHelperDuel(gameId, chatId, userId, `OU7 Roll ${i + 1}`);
        if (rollResult.error) { helperBotError = rollResult.message || `Failed to get OU7 Roll ${i + 1}`; break; }
        if (typeof rollResult.roll !== 'number' || rollResult.roll < 1 || rollResult.roll > 6) { helperBotError = `Invalid roll value from helper for OU7 roll ${i + 1}: ${rollResult.roll}`; break; }
        diceRolls.push(rollResult.roll);
        diceSum += rollResult.roll;
    }

    const messageIdToDeleteBeforeFinalResult = currentMessageId;
    let gameDataAfterRolls = activeGames.get(gameId);
    if (!gameDataAfterRolls) {
        console.error(`${LOG_PREFIX_OU7_CHOICE} Game data for ${gameId} vanished after dice rolls. This should not happen. Bet was already taken.`);
        return; 
    }

    if (helperBotError || diceRolls.length !== OU7_DICE_COUNT) {
        const errorMsgToUserHTML = `⚠️ ${playerRefHTML}, an error occurred while rolling the dice: <code>${escapeHTML(String(helperBotError || "Incomplete rolls").substring(0,150))}</code><br>Your bet of <b>${betDisplayUSD_HTML}</b> has been refunded.`;
        if (messageIdToDeleteBeforeFinalResult && bot) {
            await bot.deleteMessage(String(chatId), Number(messageIdToDeleteBeforeFinalResult)).catch(e => {});
        }
        await safeSendMessage(String(chatId), errorMsgToUserHTML, { parse_mode: 'HTML', reply_markup: createPostGameKeyboard(GAME_IDS.OVER_UNDER_7, betAmount) });
        
        let refundClient = null;
        try {
            refundClient = await pool.connect(); await refundClient.query('BEGIN');
            await updateUserBalanceAndLedger(refundClient, userId, betAmount, 'refund_ou7_helper_fail', {game_id_custom_field: gameId}, `Refund OU7 game ${gameId} due to helper error`, solPrice);
            await refundClient.query('COMMIT');
        } catch(e) { if(refundClient) await refundClient.query('ROLLBACK'); }
        finally { if(refundClient) refundClient.release(); }

        activeGames.delete(gameId);
        await updateGroupGameDetails(String(chatId), { removeThisId: gameId }, GAME_IDS.OVER_UNDER_7, null);
        return;
    }

    gameDataAfterRolls.diceRolls = diceRolls;
    gameDataAfterRolls.diceSum = BigInt(diceSum);
    gameDataAfterRolls.status = 'game_over';

    let win = false;
    let payoutMultiplier = 0;
    let outcomeReasonLog = `loss_ou7_${choice}_sum${diceSum}`;
    let resultTextPartHTML = "";
    let payoutAmountLamportsFinal = 0n;
    let isConclusiveOutcome = true;

    if (choice === 'seven' && diceSum === 7) {
        win = true; payoutMultiplier = OU7_PAYOUT_SEVEN;
    } else if (choice === 'under' && diceSum < 7) {
        win = true; payoutMultiplier = OU7_PAYOUT_NORMAL;
    } else if (choice === 'over' && diceSum > 7) {
        win = true; payoutMultiplier = OU7_PAYOUT_NORMAL;
    }

    if (win) {
        outcomeReasonLog = `win_ou7_${choice}_sum${diceSum}_mult${payoutMultiplier}`;
        const winEmoji = choice === 'seven' ? "🎯 JACKPOT!" : "🎉 WINNER!";
        const currentProfitLamports = betAmount * BigInt(Math.floor(payoutMultiplier));
        payoutAmountLamportsFinal = betAmount + currentProfitLamports;
        resultTextPartHTML = `${winEmoji} Your prediction of <b>${escapeHTML(choiceTextDisplay)} 7</b> was spot on! You've won <b>${escapeHTML(await formatBalanceForDisplay(currentProfitLamports, 'USD'))}</b> in profit!`;
    } else {
        payoutAmountLamportsFinal = 0n;
        resultTextPartHTML = `💔 So Close! The dice sum was <b>${diceSum}</b>, not matching your prediction of <b>${escapeHTML(choiceTextDisplay)} 7</b>. Better luck next time!`;
    }

    const titleResultHTML = `🏁 <b>Over/Under 7 - Result!</b> 🏁`;
    let finalMessageTextHTML = `${titleResultHTML}\n\nPlayer: ${playerRefHTML}\nBet: <b>${betDisplayUSD_HTML}</b> on <b>${escapeHTML(choiceTextDisplay)} 7</b>.\n\n`;
    finalMessageTextHTML += `The Helper Bot rolled: ${formatDiceRolls(diceRolls)} for a total of <b>${escapeHTML(String(diceSum))}</b>!\n\n${resultTextPartHTML}`;
    
    let clientOutcome = null;
    let dbErrorText = "";
    let gameOutcomeTextForTable = `Choice: ${choice}, Sum: ${diceSum}, Outcome: ${outcomeReasonLog}`;

    try {
        clientOutcome = await pool.connect();
        await clientOutcome.query('BEGIN');

        const actualGameLogId = await logGameResultToGamesTable(
            clientOutcome, GAME_IDS.OVER_UNDER_7, chatId, userId, [userId], betAmount, gameOutcomeTextForTable, 0n
        );

        const ledgerReasonForTransactionType = outcomeReasonLog.length > 50 ? outcomeReasonLog.substring(0, 47) + "..." : outcomeReasonLog;
        const fullNotesForLedger = `${outcomeReasonLog} (Game ID: ${gameId})`;

        const balanceUpdate = await updateUserBalanceAndLedger(
            clientOutcome, userId, payoutAmountLamportsFinal,
            ledgerReasonForTransactionType,
            { game_log_id: actualGameLogId, dice_rolls_s7_luckysum: diceRolls.join(','), sum_s7_luckysum: diceSum.toString(), original_bet_amount: betAmount.toString() },
            fullNotesForLedger,
            solPrice
        );
        if (!balanceUpdate.success) { 
            await clientOutcome.query('ROLLBACK');
            throw new Error(balanceUpdate.error || "DB error settling Over/Under 7 bet."); 
        }
        if (balanceUpdate.notifications) allNotificationsToSend.push(...balanceUpdate.notifications);

        if (isConclusiveOutcome && totalWageredForLevelCheck !== undefined) {
            // --- START OF MODIFICATION ---

            // 1. ADDED: Check for the initial bet bonus.
            if (typeof processQualifyingBetAndInitialBonus === 'function') {
                const initialBonusResult = await processQualifyingBetAndInitialBonus(clientOutcome, userId, betAmount, gameId);
                if (initialBonusResult.jobQueued) {
                    console.log(`[ReferralCheck] Queued initial bet bonus job for user ${userId} from game ${gameId}.`);
                }
            }

            // 2. MODIFIED: Correctly call level and milestone checks.
            const levelNotifications = await checkAndUpdateUserLevel(clientOutcome, userId, totalWageredForLevelCheck, solPrice, chatId);
            allNotificationsToSend.push(...levelNotifications);
            const milestoneResult = await processWagerMilestoneBonus(clientOutcome, userId, totalWageredForLevelCheck, solPrice);
            if (!milestoneResult.success) {
                console.warn(`${LOG_PREFIX_OU7_CHOICE} Failed to process milestone bonus: ${milestoneResult.error}`);
            }
            // --- END OF MODIFICATION ---
        }

        await clientOutcome.query('COMMIT');
    } catch (dbError) {
        if (clientOutcome) { 
            try { await clientOutcome.query('ROLLBACK'); } catch (rbErr) { console.error(`${LOG_PREFIX_OU7_CHOICE} Rollback error: ${rbErr.message}`);}
        }
        dbErrorText = `\n\n⚠️ Error settling wager: <code>${escapeHTML(dbError.message)}</code>. Admin notified.`;
        console.error(`${LOG_PREFIX_OU7_CHOICE} DB error: ${dbError.message}`);
        if (typeof notifyAdmin === 'function') {
            notifyAdmin(`🚨 CRITICAL Over/Under 7 Payout/Ledger Failure 🚨\nGame ID: \`${escapeHTML(gameId)}\` User: ${escapeHTML(String(userId))}\nError: \`${escapeHTML(dbError.message)}\`. Manual check needed.`, {parse_mode: 'MarkdownV2'});
        }
    } finally {
        if (clientOutcome) clientOutcome.release();
    }

    // Send notifications after the DB transaction is fully complete
    for (const notification of allNotificationsToSend) {
        if (notification.to === ADMIN_USER_ID && typeof notifyAdmin === 'function') {
            await notifyAdmin(notification.text, notification.options).catch(err => console.error(`Failed to send admin notification: ${err.message}`));
        } else {
            await safeSendMessage(notification.to, notification.text, notification.options).catch(err => console.error(`Failed to send game-related notification to ${notification.to}: ${err.message}`));
        }
    }
    
    let finalMessageWithDbStatusHTML = finalMessageTextHTML + dbErrorText;
    const postGameKeyboardOU7 = createPostGameKeyboard(GAME_IDS.OVER_UNDER_7, betAmount);
    
    if (messageIdToDeleteBeforeFinalResult && bot) {
        await bot.deleteMessage(String(chatId), Number(messageIdToDeleteBeforeFinalResult)).catch(e => {});
    }
    await safeSendMessage(String(chatId), finalMessageWithDbStatusHTML, { parse_mode: 'HTML', reply_markup: postGameKeyboardOU7 });

    activeGames.delete(gameId);
    await updateGroupGameDetails(String(chatId), { removeThisId: gameId }, GAME_IDS.OVER_UNDER_7, null);
}

// --- End of Part 5c, Section 1 (NEW + DEBUG LOGS) ---
// --- Start of Part 5c, Section 2 (COMPLETE REWRITE FOR NEW DUEL GAME LOGIC - CONSOLIDATED UPDATES - GRANULAR ACTIVE GAME LIMITS) ---
// index.js - Part 5c, Section 2: Duel Game Logic & Handlers (PvP/PvB Unified Offer Style)
//-------------------------------------------------------------------------------------
// Assumed dependencies as previously noted.

// --- Helper function for a single dice roll via Helper Bot for Duel ---
// (This function's internal logic is unchanged by the current refactoring task for granular limits)
async function getSingleDiceRollViaHelperDuel(gameId, chatIdForLog, userIdForRoll, rollPurposeNote) {
    const logPrefix = `[Duel_GetSingleRoll GID:${gameId} Purpose:"${rollPurposeNote}" UID:${userIdForRoll || 'BOT_INTERNAL'}]`;
    let client = null;
    let requestId = null;
    let specificErrorMessage = `Failed to obtain dice roll for "${rollPurposeNote}" via Helper Bot.`;
    let isTimeoutErrorFlag = false;

    try {
        client = await pool.connect();
        const requestResult = await insertDiceRollRequest(client, gameId, String(chatIdForLog), userIdForRoll, '🎲', rollPurposeNote);
        if (!requestResult.success || !requestResult.requestId) {
            specificErrorMessage = requestResult.error || `Database error when creating roll request for "${rollPurposeNote}".`;
            console.error(`${logPrefix} ${specificErrorMessage}`);
            throw new Error(specificErrorMessage);
        }
        requestId = requestResult.requestId;
        client.release(); client = null;

        let attempts = 0;
        while (attempts < DICE_ROLL_POLLING_MAX_ATTEMPTS) {
            await sleep(DICE_ROLL_POLLING_INTERVAL_MS);
            if (isShuttingDown) {
                specificErrorMessage = "System shutdown initiated while waiting for Helper Bot dice roll response.";
                console.warn(`${logPrefix} ${specificErrorMessage}`);
                throw new Error(specificErrorMessage);
            }

            client = await pool.connect();
            const statusResult = await getDiceRollRequestResult(client, requestId);
            client.release(); client = null;

            if (statusResult.success && statusResult.status === 'completed') {
                if (typeof statusResult.roll_value === 'number' && statusResult.roll_value >= 1 && statusResult.roll_value <= 6) {
                    return { roll: statusResult.roll_value, error: false };
                } else {
                    specificErrorMessage = `Helper Bot returned a completed roll for "${rollPurposeNote}" (Request ID: ${requestId}), but the dice value was invalid: '${statusResult.roll_value}'.`;
                    console.error(`${logPrefix} ${specificErrorMessage}`);
                    throw new Error(specificErrorMessage);
                }
            } else if (statusResult.success && statusResult.status === 'error') {
                specificErrorMessage = statusResult.notes || `Helper Bot explicitly reported an error for "${rollPurposeNote}" (Request ID: ${requestId}).`;
                console.error(`${logPrefix} ${specificErrorMessage}`);
                throw new Error(specificErrorMessage);
            }
            attempts++;
        }

        isTimeoutErrorFlag = true;
        specificErrorMessage = `Timeout after ${attempts} attempts waiting for Helper Bot response for dice roll: "${rollPurposeNote}" (Request ID: ${requestId}).`;
        throw new Error(specificErrorMessage);

    } catch (error) {
        if (client) client.release();
        const finalErrorMessageForReturn = error.message || specificErrorMessage;
        console.error(`${logPrefix} Final error state in getSingleDiceRollViaHelperDuel: ${finalErrorMessageForReturn}`);
        if (requestId) {
            let markErrorClient = null;
            try {
                markErrorClient = await pool.connect();
                const statusToUpdate = isTimeoutErrorFlag ? 'timeout' : 'error';
                await markErrorClient.query("UPDATE dice_roll_requests SET status=$1, notes=$2 WHERE request_id=$3 AND status = 'pending'",
                    [statusToUpdate, String(finalErrorMessageForReturn).substring(0,250), requestId]);
            } catch (dbMarkError) {
                console.error(`${logPrefix} CRITICAL: Failed to mark roll request ${requestId} as failed in DB: ${dbMarkError.message}`);
            } finally {
                if (markErrorClient) markErrorClient.release();
            }
        }
        return { error: true, message: finalErrorMessageForReturn, isTimeout: isTimeoutErrorFlag };
    }
}

// NEW Helper to get DUEL_DICE_COUNT rolls for bot in PvB Duel
async function getDuelDiceRollsForBot_Internal(gameId, chatId, purposePrefix = "Duel PvB Bot") {
    const rolls = [];
    let anyError = false;
    for (let i = 0; i < DUEL_DICE_COUNT; i++) {
        const rollResult = await getSingleDiceRollViaHelperDuel(gameId, chatId, null, `${purposePrefix} Roll ${i + 1}`);
        if (rollResult.error) {
            console.error(`[getDuelDiceRollsForBot_Internal GID:${gameId}] Error on roll ${i+1}: ${rollResult.message}. Using fallback.`);
            rolls.push(Math.floor(Math.random() * 6) + 1); // Fallback
            anyError = true;
        } else {
            rolls.push(rollResult.roll);
        }
    }
    return { rolls, error: anyError };
}


// --- Duel Main Command Handler (Creates Unified Offer or Direct Challenge in Group Chat) ---
// --- START OF REPLACEMENT for handleStartDuelUnifiedOfferCommand function ---
async function handleStartDuelUnifiedOfferCommand(msg, betAmountLamports, targetUsernameRaw = null) {
    const userId = String(msg.from.id || msg.from.telegram_id);
    const chatId = String(msg.chat.id);
    const chatType = msg.chat.type;
    const logPrefix = `[Duel_OfferOrDirect_V6_GranLimit UID:${userId} CH:${chatId} Type:${chatType}]`;

    // MODIFIED CALL to checkUserActiveGameLimit and NEW ERROR MESSAGE
    const isDirectChallengeOfferAttempt = (targetUsernameRaw != null);
    const activeUserGameCheck = await checkUserActiveGameLimit(userId, isDirectChallengeOfferAttempt, null); 
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = escapeHTML(getPlayerDisplayReference(msg.from));
        const blockingGameType = activeUserGameCheck.details.type;
        const cleanGameName = getCleanGameName(blockingGameType); // Using the new helper
        const alertMessage = `✨ ${userDisplayName}, you already have a pending offer or active game for <b>${escapeHTML(cleanGameName)}</b>. ✨`;
        await safeSendMessage(chatId, alertMessage, { parse_mode: 'HTML' });
        return;
    }
    // END OF MODIFICATION

    if (chatType === 'private') {
        await safeSendMessage(chatId, `⚔️ The High Roller Duel can only be initiated in a <b>group chat</b>. Use <code>/duel &lt;bet&gt; [@username]</code> there!`, { parse_mode: 'HTML' });
        return;
    }

    let initiatorUserObj = await getOrCreateUser(userId, msg.from.username, msg.from.first_name, msg.from.last_name);
    if (!initiatorUserObj) {
        await safeSendMessage(chatId, `Sorry ${escapeHTML(msg.from.first_name || 'player')}, I couldn't fetch your profile. Try <code>/start</code> first.`, { parse_mode: 'HTML' });
        return;
    }
    const initiatorPlayerRefHTML = escapeHTML(getPlayerDisplayReference(initiatorUserObj));
    const betDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(betAmountLamports, 'USD'));

    if (BigInt(initiatorUserObj.balance) < betAmountLamports) {
        const needed = betAmountLamports - BigInt(initiatorUserObj.balance);
        await safeSendMessage(chatId, `${initiatorPlayerRefHTML}, your treasury is too light for a <b>${betDisplayUSD_HTML}</b> Duel! You need about <b>${escapeHTML(await formatBalanceForDisplay(needed, 'USD'))}</b> more.`, {
            parse_mode: 'HTML',
            reply_markup: { inline_keyboard: [[{ text: "💰 Add Funds (DM)", callback_data: QUICK_DEPOSIT_CALLBACK_ACTION_CONST }]] }
        });
        return;
    }

    let targetUserObject = null;
    let isDirectChallenge = (targetUsernameRaw != null);

    if (isDirectChallenge) {
        targetUserObject = await findRecipientUser(targetUsernameRaw);
        if (!targetUserObject || !targetUserObject.telegram_id) {
            await safeSendMessage(chatId, `😕 Player ${escapeHTML(targetUsernameRaw)} not found. For a general Duel offer, use <code>/duel ${escapeHTML(String(betAmountLamports/LAMPORTS_PER_SOL))} sol</code>.`, { parse_mode: 'HTML' });
            return;
        }
        if (String(targetUserObject.telegram_id) === userId) {
            await safeSendMessage(chatId, `😅 You can't challenge yourself to a Duel, ${initiatorPlayerRefHTML}! For a general offer, use <code>/duel ${escapeHTML(String(betAmountLamports/LAMPORTS_PER_SOL))} sol</code>.`, { parse_mode: 'HTML' });
            return;
        }
    }

    const gameSession = await getGroupSession(chatId, msg.chat.title || `Group Chat ${chatId}`);
    let offerActivityKeyForLock;
    let limit;

    if (isDirectChallenge) {
        offerActivityKeyForLock = GAME_IDS.DUEL_DIRECT_CHALLENGE_OFFER; 
        const currentDirectChallenges = gameSession.activeGamesByTypeInGroup.get(offerActivityKeyForLock) || [];
        limit = GAME_ACTIVITY_LIMITS.DIRECT_CHALLENGES[offerActivityKeyForLock] || 1; 
        if (currentDirectChallenges.length >= limit) {
            await safeSendMessage(chatId, `⏳ ${initiatorPlayerRefHTML}, the limit of ${limit} concurrent direct Duel challenge(s) in this group is active. Please wait.`, { parse_mode: 'HTML' });
            return;
        }
    } else { // Unified Offer
        offerActivityKeyForLock = GAME_IDS.DUEL_UNIFIED_OFFER; 
        const currentUnifiedOffers = gameSession.activeGamesByTypeInGroup.get(offerActivityKeyForLock) || [];
        limit = GAME_ACTIVITY_LIMITS.UNIFIED_OFFERS[offerActivityKeyForLock] || GAME_ACTIVITY_LIMITS.UNIFIED_OFFERS[GAME_IDS.DUEL] || 1; 
        if (currentUnifiedOffers.length >= limit) {
            await safeSendMessage(chatId, `⏳ ${initiatorPlayerRefHTML}, the limit of ${limit} concurrent Duel offer(s) in this group is active. Please wait.`, { parse_mode: 'HTML' });
            return;
        }
    }

    let offerId;
    let offerData;
    let clientBetPlacement = null;
    let timeoutDuration;

    try {
        clientBetPlacement = await pool.connect();
        await clientBetPlacement.query('BEGIN');

        if (isDirectChallenge) {
            offerId = generateGameId(`dduel_${userId.slice(-3)}_${String(targetUserObject.telegram_id).slice(-3)}`);
            timeoutDuration = DIRECT_CHALLENGE_ACCEPT_TIMEOUT_MS;

            const betResultDirect = await updateUserBalanceAndLedger(clientBetPlacement, userId, BigInt(-betAmountLamports), 'bet_placed_duel_direct_challenge_offer', { custom_offer_id: offerId, opponent_id_custom_field: targetUserObject.telegram_id }, `Direct Duel Challenge Offer to ${targetUserObject.username || targetUserObject.telegram_id}`);
            if (!betResultDirect.success) throw new Error(betResultDirect.error || "Failed to place your bet for the direct challenge.");
            initiatorUserObj.balance = betResultDirect.newBalanceLamports;

            const targetPlayerRefHTML = escapeHTML(getPlayerDisplayReference(targetUserObject));
            const groupChallengeTextHTML = `Hey ${targetPlayerRefHTML}❗\n\n${initiatorPlayerRefHTML} has thrown down the gauntlet, challenging you to a <b>Duel</b> for <b>${betDisplayUSD_HTML}</b>! You have ${timeoutDuration / 1000} seconds to respond.`;
            const groupChallengeKeyboard = {
                inline_keyboard: [
                    [{ text: "✅ Accept Duel", callback_data: `duel_direct_accept:${offerId}` }],
                    [{ text: "❌ Decline Duel", callback_data: `duel_direct_decline:${offerId}` }],
                    [{ text: "🚫 Withdraw My Challenge", callback_data: `duel_direct_cancel:${offerId}` }]
                ]
            };
            const sentGroupMessage = await safeSendMessage(chatId, groupChallengeTextHTML, { parse_mode: 'HTML', reply_markup: groupChallengeKeyboard });
            if (!sentGroupMessage || !sentGroupMessage.message_id) throw new Error("Could not send the direct Duel challenge message.");

            offerData = {
                type: GAME_IDS.DIRECT_PVP_CHALLENGE, offerId: offerId, gameId: offerId, initiatorId: userId,
                initiatorUserObj: initiatorUserObj, initiatorMentionHTML: initiatorPlayerRefHTML,
                targetUserId: String(targetUserObject.telegram_id), targetUserObj: targetUserObject, targetUserMentionHTML: targetPlayerRefHTML,
                betAmount: betAmountLamports, originalGroupId: chatId, offerMessageIdInGroup: String(sentGroupMessage.message_id),
                chatTitle: msg.chat.title || `Group Chat ${chatId}`, status: 'pending_direct_challenge_response',
                gameToStart: GAME_IDS.DUEL_PVP,
                _offerKeyUsedForGroupLock: GAME_IDS.DUEL_DIRECT_CHALLENGE_OFFER, 
                creationTime: Date.now(), timeoutId: null
            };
        } else { // Unified Offer
            offerId = generateGameId(GAME_IDS.DUEL_UNIFIED_OFFER);
            timeoutDuration = UNIFIED_OFFER_TIMEOUT_MS;

            const betResultUnified = await updateUserBalanceAndLedger(clientBetPlacement, userId, BigInt(-betAmountLamports), 'bet_placed_duel_unified_offer', { custom_offer_id: offerId }, `Duel Unified Offer`);
            if (!betResultUnified.success) throw new Error(betResultUnified.error || "Failed to place your bet for the unified offer.");
            initiatorUserObj.balance = betResultUnified.newBalanceLamports;

            const offerMessageTextHTML = `⚔️ <b>A High Roller Duel Challenge!</b> ⚔️\n\n` +
                `${initiatorPlayerRefHTML} has laid down a wager of <b>${betDisplayUSD_HTML}</b> for a Duel!\n\n` +
                `Face the Bot Dealer or await a PvP opponent! This offer expires in ${timeoutDuration / 1000}s. Bet refunded on timeout.`;
            const offerKeyboard = {
                inline_keyboard: [
                    [{ text: "🤝 Accept PvP Duel!", callback_data: `duel_accept_pvp_challenge:${offerId}` }],
                    [{ text: "🤖 Challenge the Bot Dealer", callback_data: `duel_accept_bot_game:${offerId}` }],
                    [{ text: "🚫 Withdraw My Challenge (Initiator)", callback_data: `duel_cancel_unified_offer:${offerId}` }]
                ]
            };
            const sentOfferMessage = await safeSendMessage(chatId, offerMessageTextHTML, { parse_mode: 'HTML', reply_markup: offerKeyboard });
            if (!sentOfferMessage?.message_id) throw new Error("Could not send the unified Duel offer message.");

            offerData = {
                type: GAME_IDS.DUEL_UNIFIED_OFFER, gameId: offerId, chatId: String(chatId), chatType,
                initiatorId: userId, initiatorMention: initiatorPlayerRefHTML,
                initiatorUserObj, betAmount: betAmountLamports, status: 'waiting_for_choice',
                creationTime: Date.now(), gameSetupMessageId: String(sentOfferMessage.message_id), timeoutId: null
            };
        }

        await clientBetPlacement.query('COMMIT');
        activeGames.set(offerId, offerData);
        await updateGroupGameDetails(chatId, offerId, offerActivityKeyForLock, betAmountLamports);
        console.log(`${logPrefix} Duel Offer ${offerId} (Type: ${offerData.type}, Group Lock Key: ${offerActivityKeyForLock}) created. Bet placed. Lock updated.`);

        offerData.timeoutId = setTimeout(async () => {
            const timedOutOffer = activeGames.get(offerId);
            if (timedOutOffer && (timedOutOffer.status === 'waiting_for_choice' || timedOutOffer.status === 'pending_direct_challenge_response')) {
                console.log(`${logPrefix} Offer ${offerId} (Type: ${timedOutOffer.type}) for Duel has timed out.`);
                activeGames.delete(offerId);
                const keyForTimeoutRemoval = timedOutOffer._offerKeyUsedForGroupLock || offerActivityKeyForLock;
                await updateGroupGameDetails(chatId, { removeThisId: offerId }, keyForTimeoutRemoval, null);
                console.log(`${logPrefix} Cleared group lock for timed-out Duel offer ${offerId} using key ${keyForTimeoutRemoval}.`);

                let refundClientTimeout = null;
                try {
                    refundClientTimeout = await pool.connect(); await refundClientTimeout.query('BEGIN');
                    const refundReason = timedOutOffer.type === GAME_IDS.DIRECT_PVP_CHALLENGE ? 'direct_challenge_expired_unanswered' : 'unified_offer_expired_unanswered';
                    const refundNotes = `Refund for expired ${timedOutOffer.type === GAME_IDS.DIRECT_PVP_CHALLENGE ? 'direct Duel challenge' : 'unified Duel offer'} ${offerId}.`;
                    await updateUserBalanceAndLedger(refundClientTimeout, timedOutOffer.initiatorId, timedOutOffer.betAmount, `refund_duel_${refundReason}`, { custom_offer_id: offerId }, refundNotes);
                    await refundClientTimeout.query('COMMIT');
                    console.log(`${logPrefix} Bet refunded to initiator ${timedOutOffer.initiatorId} for timed out Duel offer ${offerId}.`);
                } catch (e) {
                    if (refundClientTimeout) await refundClientTimeout.query('ROLLBACK').catch(() => {});
                    console.error(`${logPrefix} CRITICAL: Failed to refund initiator ${timedOutOffer.initiatorId} for timed out Duel offer ${offerId}: ${e.message}`);
                    if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL REFUND FAILURE for timed out Duel offer ${offerId}, Initiator: ${timedOutOffer.initiatorId}. Error: ${e.message}`);
                } finally { if (refundClientTimeout) refundClientTimeout.release(); }

                const messageIdToEdit = timedOutOffer.offerMessageIdInGroup || timedOutOffer.gameSetupMessageId;
                const currentBetDisplayHTML_Timeout = escapeHTML(await formatBalanceForDisplay(timedOutOffer.betAmount, 'USD'));
                const timeoutMessageHTML = timedOutOffer.type === GAME_IDS.DIRECT_PVP_CHALLENGE ?
                    `⏳ The Duel challenge from ${timedOutOffer.initiatorMentionHTML} to ${timedOutOffer.targetUserMentionHTML} for <b>${currentBetDisplayHTML_Timeout}</b> has expired unanswered. Initiator's bet refunded.` :
                    `⏳ The Duel offer by ${timedOutOffer.initiatorMention || timedOutOffer.initiatorMentionHTML} for <b>${currentBetDisplayHTML_Timeout}</b> has expired. Initiator's bet refunded.`;

                if (messageIdToEdit && bot) {
                    await bot.editMessageText(timeoutMessageHTML, {
                        chat_id: String(chatId), message_id: Number(messageIdToEdit),
                        parse_mode: 'HTML', reply_markup: {}
                    }).catch(e => {});
                }
            }
        }, timeoutDuration);
        activeGames.set(offerId, offerData); 

    } catch (error) {
        if (clientBetPlacement) await clientBetPlacement.query('ROLLBACK').catch(() => {});
        console.error(`${logPrefix} Error creating Duel offer or placing bet: ${error.message}`);
        await safeSendMessage(chatId, `⚠️ Error creating your Duel offer: ${escapeHTML(error.message)}. Please try again.`, { parse_mode: 'HTML' });
        if (offerId && activeGames.has(offerId)) {
            activeGames.delete(offerId);
            const keyForErrorCleanup = offerData?._offerKeyUsedForGroupLock || offerActivityKeyForLock;
            if(keyForErrorCleanup) await updateGroupGameDetails(chatId, { removeThisId: offerId }, keyForErrorCleanup, null);
        }
    } finally {
        if (clientBetPlacement) clientBetPlacement.release();
    }
}
// --- END OF REPLACEMENT for handleStartDuelUnifiedOfferCommand function ---

// --- Callback Handlers for Duel Unified Offer ---
// --- START OF FULL REPLACEMENT for handleDuelAcceptBotGameCallback function ---
async function handleDuelAcceptBotGameCallback(offerId, initiatorUserObjFromCb, originalOfferMessageId, originalChatId, originalChatType, callbackQueryIdPassed = null) {
    const initiatorId = String(initiatorUserObjFromCb.id || initiatorUserObjFromCb.telegram_id);
    const logPrefix = `[Duel_AcceptBotCB_V4_GranLimit GID:${offerId} UID:${initiatorId}]`;
    const offerData = activeGames.get(offerId);
    const callbackQueryId = callbackQueryIdPassed;

    // --- NEW USER ACTIVE GAME LIMIT CHECK ---
    // Pass offerId as gameIdBeingActioned, as the user is actioning this specific offer.
    const activeUserGameCheck = await checkUserActiveGameLimit(initiatorId, false, offerId); 
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = escapeHTML(getPlayerDisplayReference(initiatorUserObjFromCb));
        const blockingGameType = activeUserGameCheck.details.type;
        const cleanGameName = getCleanGameName(blockingGameType);
        let alertMessage = `✨ ${userDisplayName}, you're already in a game of ${escapeHTML(cleanGameName)}. ✨ Finish it first!`;
        alertMessage = alertMessage.substring(0, 200); // Telegram alert length limit

        if (callbackQueryId) {
            await bot.answerCallbackQuery(callbackQueryId, { text: alertMessage, show_alert: true }).catch(() => {});
        } else {
            // Fallback if no callbackQueryId
            const fullAlertMessageForChat = `✨ ${userDisplayName}, you already have a pending offer or active game for <b>${escapeHTML(cleanGameName)}</b>. Please finish it before starting a new one. ✨`;
            await safeSendMessage(originalChatId, fullAlertMessageForChat, { parse_mode: 'HTML' });
        }
        return;
    }
    // --- END OF NEW USER ACTIVE GAME LIMIT CHECK ---

    if (!offerData || offerData.type !== GAME_IDS.DUEL_UNIFIED_OFFER || offerData.status !== 'waiting_for_choice') {
        if(callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "Duel offer expired or invalid.", show_alert: true }).catch(()=>{});
        // Attempt to clean up buttons on the original message if it's still accessible
        const msgIdToClearButtons = offerData?.gameSetupMessageId || originalOfferMessageId;
        if (msgIdToClearButtons && bot) {
            bot.editMessageReplyMarkup({}, { chat_id: originalChatId, message_id: Number(msgIdToClearButtons) }).catch(() => {});
        }
        return;
    }
    if (offerData.initiatorId !== initiatorId) {
        if(callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "Only initiator can play vs Bot.", show_alert: true }).catch(()=>{});
        return;
    }

    const gameSession = await getGroupSession(originalChatId);
    const activeGameKeyToCheck = GAME_IDS.DUEL_PVB;
    const currentActiveDuelGames = gameSession.activeGamesByTypeInGroup.get(activeGameKeyToCheck) || [];
    const limitActive = GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[activeGameKeyToCheck] || 1;

    if (currentActiveDuelGames.length >= limitActive) {
        if(callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: `Max ${limitActive} active Duel PvB game(s) allowed. Wait.`, show_alert: true }).catch(()=>{});
        return;
    }

    if (offerData.timeoutId) clearTimeout(offerData.timeoutId);
    offerData.timeoutId = null;
    if(callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "Starting Duel vs Bot Dealer..."}).catch(()=>{});

    offerData.status = 'bot_game_accepted';
    
    await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.DUEL_UNIFIED_OFFER, null);
    activeGames.delete(offerId); 

    await startDuelPvBGame(originalChatId, offerData.initiatorUserObj, offerData.betAmount, offerData.gameSetupMessageId, null); // Pass null as offerIdToDeleteIfAny since we deleted it
}
// --- END OF FULL REPLACEMENT for handleDuelAcceptBotGameCallback function ---

// --- START OF FULL REPLACEMENT for handleDuelAcceptPvPChallengeCallback function ---
async function handleDuelAcceptPvPChallengeCallback(offerId, joinerUserObjFull, originalOfferMessageId, originalChatId, originalChatType, callbackQueryIdPassed = null) {
    const joinerId = String(joinerUserObjFull.id || joinerUserObjFull.telegram_id);
    const logPrefix = `[Duel_AcceptPvPCB_V4_GranLimit GID:${offerId} JoinerID:${joinerId}]`;
    let offerData = activeGames.get(offerId);
    const callbackQueryId = callbackQueryIdPassed;

    // --- NEW USER ACTIVE GAME LIMIT CHECK ---
    // Pass offerId as gameIdBeingActioned, as the user is actioning this specific offer.
    const activeUserGameCheck = await checkUserActiveGameLimit(joinerId, false, offerId); 
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = escapeHTML(getPlayerDisplayReference(joinerUserObjFull));
        const blockingGameType = activeUserGameCheck.details.type;
        const cleanGameName = getCleanGameName(blockingGameType);
        let alertMessage = `✨ ${userDisplayName}, you're already in a game of ${escapeHTML(cleanGameName)}. ✨ Finish it first!`;
        alertMessage = alertMessage.substring(0, 200); // Telegram alert length limit

        if (callbackQueryId) {
            await bot.answerCallbackQuery(callbackQueryId, { text: alertMessage, show_alert: true }).catch(() => {});
        } else {
            // Fallback if no callbackQueryId
            const fullAlertMessageForChat = `✨ ${userDisplayName}, you already have a pending offer or active game for <b>${escapeHTML(cleanGameName)}</b>. Please finish it before starting a new one. ✨`;
            await safeSendMessage(originalChatId, fullAlertMessageForChat, { parse_mode: 'HTML' });
        }
        return;
    }
    // --- END OF NEW USER ACTIVE GAME LIMIT CHECK ---

    if (!offerData || offerData.type !== GAME_IDS.DUEL_UNIFIED_OFFER || offerData.status !== 'waiting_for_choice') {
        if(callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "Duel offer expired/invalid.", show_alert: true }).catch(()=>{});
        // Attempt to clean up buttons on the original message
        const msgIdToClearButtons = offerData?.gameSetupMessageId || originalOfferMessageId;
        if (msgIdToClearButtons && bot) {
            bot.editMessageReplyMarkup({}, { chat_id: originalChatId, message_id: Number(msgIdToClearButtons) }).catch(() => {});
        }
        return;
    }
    if (offerData.initiatorId === joinerId) {
        if(callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "Can't duel yourself!", show_alert: true }).catch(()=>{});
        return;
    }

    const gameSession = await getGroupSession(originalChatId);
    const activeGameKeyToCheck = GAME_IDS.DUEL_PVP_FROM_UNIFIED;
    const currentActiveDuelGames = gameSession.activeGamesByTypeInGroup.get(activeGameKeyToCheck) || [];
    const limitActive = GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[activeGameKeyToCheck] || 1;

    if (currentActiveDuelGames.length >= limitActive) {
        if(callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: `Max ${limitActive} active Duel PvP (from unified) game(s) allowed. Wait.`, show_alert: true }).catch(()=>{});
        return;
    }

    const betDisplayHTML = escapeHTML(await formatBalanceForDisplay(offerData.betAmount, 'USD'));
    let currentJoinerUserObj = await getOrCreateUser(joinerId, joinerUserObjFull.username, joinerUserObjFull.first_name, joinerUserObjFull.last_name);
    if (!currentJoinerUserObj || BigInt(currentJoinerUserObj.balance) < offerData.betAmount) {
        if(callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: `Your funds too low for ${betDisplayHTML} duel.`, show_alert: true }).catch(()=>{});
        // No need to send a chat message here if the callback alert suffices.
        return;
    }
    let currentInitiatorUserObj = await getOrCreateUser(offerData.initiatorId);
    if (!currentInitiatorUserObj || BigInt(currentInitiatorUserObj.balance) < offerData.betAmount) {
        if(callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "Initiator can't cover bet. Offer cancelled.", show_alert: true }).catch(()=>{});
        if (offerData.timeoutId) clearTimeout(offerData.timeoutId);
        activeGames.delete(offerId);
        await updateGroupGameDetails(originalChatId, {removeThisId: offerId}, GAME_IDS.DUEL_UNIFIED_OFFER, null);
        const msgIdToEdit = offerData.gameSetupMessageId || originalOfferMessageId;
        const initiatorDisplayReference = offerData.initiatorMention || escapeHTML(getPlayerDisplayReference(offerData.initiatorUserObj));
        if(msgIdToEdit && bot) await bot.editMessageText(`⚠️ Duel offer by ${initiatorDisplayReference} cancelled (initiator funds insufficient).`, {chat_id: originalChatId, message_id: Number(msgIdToEdit), parse_mode:'HTML', reply_markup:{}}).catch(()=>{});
        return;
    }

    if (offerData.timeoutId) clearTimeout(offerData.timeoutId);
    offerData.timeoutId = null;
    if(callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, {text: "Duel Accepted! Setting up PvP..."}).catch(()=>{});

    offerData.status = 'pvp_accepted';
    
    await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.DUEL_UNIFIED_OFFER, null);

    let clientBet = null;
    const pvpGameId = generateGameId(GAME_IDS.DUEL_PVP);
    try {
        clientBet = await pool.connect(); await clientBet.query('BEGIN');
        const initiatorDisplayReferenceForLedger = offerData.initiatorMention || escapeHTML(getPlayerDisplayReference(offerData.initiatorUserObj));
        const joinBetRes = await updateUserBalanceAndLedger(clientBet, joinerId, BigInt(-offerData.betAmount), 'bet_placed_duel_pvp_join', { game_id_custom_field: pvpGameId, opponent_id_custom_field: offerData.initiatorId }, `PvP Duel Join vs ${initiatorDisplayReferenceForLedger}`);
        if (!joinBetRes.success) throw new Error(joinBetRes.error || "Failed to deduct joiner's bet.");
        currentJoinerUserObj.balance = joinBetRes.newBalanceLamports;
        await clientBet.query('COMMIT');

        activeGames.delete(offerId); 

        await startDuelPvPGameSequence(
            pvpGameId,
            currentInitiatorUserObj,
            currentJoinerUserObj,
            offerData.betAmount,
            originalChatId,
            originalChatType,
            offerData.gameSetupMessageId, 
            'unified_offer' 
        );

    } catch (e) {
        if (clientBet) await clientBet.query('ROLLBACK').catch(()=>{});
        console.error(`${logPrefix} CRITICAL error creating Duel PvP game ${pvpGameId} or taking joiner's bet: ${e.message}`);
        await safeSendMessage(originalChatId, `⚙️ Error starting Duel PvP: ${escapeHTML(e.message)}. Game cancelled.`, { parse_mode: 'HTML'});
        if(activeGames.has(offerId)) activeGames.delete(offerId);
        const currentGroupOffers = await getGroupSession(originalChatId); 
        if(currentGroupOffers.activeGamesByTypeInGroup.get(GAME_IDS.DUEL_UNIFIED_OFFER)?.includes(offerId)) {
            await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.DUEL_UNIFIED_OFFER, null);
        }

        let refundInitiatorClient = null;
        try {
            refundInitiatorClient = await pool.connect(); await refundInitiatorClient.query('BEGIN');
            await updateUserBalanceAndLedger(refundInitiatorClient, offerData.initiatorId, offerData.betAmount, 'refund_duel_pvp_opponent_bet_fail', {custom_offer_id: offerId}, `Duel offer ${offerId} refund due to joiner bet fail.`);
            await refundInitiatorClient.query('COMMIT');
        } catch (refErr) {
            if(refundInitiatorClient) await refundInitiatorClient.query('ROLLBACK');
            console.error(`${logPrefix} CRITICAL REFUND FAILURE for initiator on Duel PvP joiner bet fail: ${refErr.message}`);
        } finally {
            if(refundInitiatorClient) refundInitiatorClient.release();
        }
        return;
    } finally {
        if (clientBet) clientBet.release();
    }
}
// --- END OF FULL REPLACEMENT for handleDuelAcceptPvPChallengeCallback function ---

// --- START OF FULL REPLACEMENT for handleDuelCancelUnifiedOfferCallback function ---
async function handleDuelCancelUnifiedOfferCallback(offerId, initiatorUserObjFromCb, originalOfferMessageId, originalChatId, callbackQueryIdPassed = null) {
    const initiatorId = String(initiatorUserObjFromCb.id || initiatorUserObjFromCb.telegram_id);
    const logPrefix = `[Duel_CancelOffer_V3_Refund UID:${initiatorId} OfferID:${offerId}]`;
    const offerData = activeGames.get(offerId);
    const callbackQueryId = callbackQueryIdPassed;

    if (!offerData || offerData.type !== GAME_IDS.DUEL_UNIFIED_OFFER || offerData.status !== 'waiting_for_choice') {
        if(callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "Offer invalid/actioned.", show_alert: false }).catch(()=>{});
        return;
    }
    if (offerData.initiatorId !== initiatorId) {
        if(callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, { text: "Only initiator can cancel.", show_alert: true }).catch(()=>{});
        return;
    }

    if (offerData.timeoutId) clearTimeout(offerData.timeoutId);
    offerData.timeoutId = null;
    if(callbackQueryId) await bot.answerCallbackQuery(callbackQueryId, {text: "Duel offer cancelled. Refunding bet..."}).catch(()=>{});

    activeGames.delete(offerId);
    // MODIFIED: Use the correct key for unified Duel offer removal
    await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.DUEL_UNIFIED_OFFER, null);

    let refundClient = null;
    try {
        refundClient = await pool.connect(); await refundClient.query('BEGIN');
        await updateUserBalanceAndLedger(refundClient, offerData.initiatorId, offerData.betAmount, 'refund_duel_offer_cancelled', { custom_offer_id: offerId }, `Refund for cancelled Duel unified offer ${offerId}`);
        await refundClient.query('COMMIT');
        console.log(`${logPrefix} Bet refunded to initiator ${offerData.initiatorId} for cancelled Duel offer ${offerId}.`);
    } catch (e) {
        if(refundClient) await refundClient.query('ROLLBACK');
        console.error(`${logPrefix} CRITICAL: Failed to refund initiator ${offerData.initiatorId} for cancelled Duel offer ${offerId}: ${e.message}`);
        if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL DUEL OFFER REFUND FAIL: Offer ${offerId}, User ${offerData.initiatorId}. Err: ${e.message}`);
    } finally {
        if(refundClient) refundClient.release();
    }

    const betDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(offerData.betAmount, 'USD'));
    // Ensure offerData.initiatorMention is used, as initiatorMentionHTML might not be on unified offerData object.
    const initiatorDisplayReference = offerData.initiatorMention || escapeHTML(getPlayerDisplayReference(offerData.initiatorUserObj));
    const confirmationMessageHTML = `🚫 Offer Cancelled!\nThe Duel challenge by ${initiatorDisplayReference} for <b>${betDisplayUSD_HTML}</b> has been withdrawn. Bet refunded.`;
    const messageIdToEdit = Number(originalOfferMessageId || offerData.gameSetupMessageId);
    if (messageIdToEdit && bot) {
        await bot.editMessageText(confirmationMessageHTML, { chat_id: originalChatId, message_id: messageIdToEdit, parse_mode: 'HTML', reply_markup: {} }).catch(async () => {
            await safeSendMessage(originalChatId, confirmationMessageHTML, { parse_mode: 'HTML' });
        });
    } else {
        await safeSendMessage(originalChatId, confirmationMessageHTML, { parse_mode: 'HTML' });
    }
}
// --- END OF FULL REPLACEMENT for handleDuelCancelUnifiedOfferCallback function ---

// --- Player vs. Bot (PvB) Duel Game Logic ---
async function startDuelPvBGame(chatId, initiatorUserObj, betAmountLamports, originalOfferMessageIdToDelete, offerIdToDeleteIfAny) {
    const userId = String(initiatorUserObj.telegram_id);
    const logPrefix = `[Duel_PvB_Start_V5_GranLimit UID:${userId} CH:${chatId}]`; // V5
    const playerRefHTML = escapeHTML(getPlayerDisplayReference(initiatorUserObj));
    
    // Specific key for active PvB Duel games
    const activeGameKey = GAME_IDS.DUEL_PVB; 

    if (originalOfferMessageIdToDelete && bot) {
        await bot.deleteMessage(chatId, Number(originalOfferMessageIdToDelete)).catch(e => {});
    }
    if (offerIdToDeleteIfAny && activeGames.has(offerIdToDeleteIfAny)) { 
        const offerData = activeGames.get(offerIdToDeleteIfAny);
        if(offerData.timeoutId) clearTimeout(offerData.timeoutId);
        activeGames.delete(offerIdToDeleteIfAny);
    }

    console.log(`${logPrefix} Starting Duel PvB for ${userId}. Bet of ${betAmountLamports} confirmed.`);

    const gameId = generateGameId(GAME_IDS.DUEL_PVB);
    const gameDataPvB = {
        type: GAME_IDS.DUEL_PVB, gameId, chatId: String(chatId), chatType: 'group', // Assuming PvB is group only from offer
        playerId: userId, playerRefHTML: playerRefHTML, userObj: initiatorUserObj, betAmount: betAmountLamports,
        playerRolls: [], playerScore: 0, botRolls: [], botScore: 0,
        playerDiceRolledThisTurn: 0, 
        status: 'player_awaiting_roll_emoji', 
        gameMessageId: null, lastInteractionTime: Date.now(), turnTimeoutId: null
    };
    activeGames.set(gameId, gameDataPvB);
    await updateGroupGameDetails(chatId, gameId, activeGameKey, betAmountLamports); // Use specific PvB key
    console.log(`${logPrefix} Duel PvB game ${gameId} instance created. Lock for ${activeGameKey} updated.`);

    await updateDuelPvBMessage(gameId); 
}

async function updateDuelPvBMessage(gameId, interimRollMessage = null) {
    const gameData = activeGames.get(gameId);
    if (!gameData || gameData.type !== GAME_IDS.DUEL_PVB) return;
    const logPrefix = `[UpdateDuelPvBMsg_V3 GID:${gameData.gameId}]`;

    if (gameData.turnTimeoutId) { clearTimeout(gameData.turnTimeoutId); gameData.turnTimeoutId = null; }
    if (gameData.gameMessageId && bot && !interimRollMessage) { // Only delete if not an interim update following a roll message
        await bot.deleteMessage(gameData.chatId, Number(gameData.gameMessageId)).catch(()=>{});
        gameData.gameMessageId = null;
    }

    const titleHTML = `⚔️ <b>Duel vs. Bot Dealer!</b> ⚔️`;
    const betDisplayUSD_HTML_Update = escapeHTML(await formatBalanceForDisplay(gameData.betAmount, 'USD'));
    let messageTextHTML = `${titleHTML}\n\nPlayer: ${gameData.playerRefHTML}\nWager: <b>${betDisplayUSD_HTML_Update}</b>\n\n`;

    if (interimRollMessage) messageTextHTML += `${interimRollMessage}\n`;
    messageTextHTML += `Your Rolls: ${formatDiceRolls(gameData.playerRolls)} Current Score: <b>${escapeHTML(String(gameData.playerScore))}</b>\n`;

    let promptText = "";
    if (gameData.status === 'player_awaiting_roll_emoji') {
        const rollNumber = gameData.playerDiceRolledThisTurn + 1;
        const rollNumberText = rollNumber === 1 ? "first" : (rollNumber === 2 ? "second" : `next`); // Adjusted for DUEL_DICE_COUNT
        promptText = `Please send your <b>${rollNumberText}</b> of ${DUEL_DICE_COUNT} 🎲 dice. (Turn timeout: ${ACTIVE_GAME_TURN_TIMEOUT_MS / 1000}s)`;
    } else if (gameData.status === 'bot_rolling_internal') {
        promptText = `Your rolls complete! Bot Dealer is now rolling... 🤖`;
    } else if (gameData.status.startsWith('game_over_')) {
        promptText = `<i>Game over. Calculating result...</i>`;
    }
    messageTextHTML += `\n${promptText}`;

    const sentMessage = await safeSendMessage(gameData.chatId, messageTextHTML, { parse_mode: 'HTML' });
    if (sentMessage?.message_id) {
        gameData.gameMessageId = sentMessage.message_id; // Always update to the latest message ID
        if (gameData.status === 'player_awaiting_roll_emoji') {
            gameData.turnTimeoutId = setTimeout(() => {
                handleDuelPvBTurnTimeout(gameData.gameId);
            }, ACTIVE_GAME_TURN_TIMEOUT_MS);
            console.log(`${logPrefix} Player turn timeout set for roll ${gameData.playerDiceRolledThisTurn + 1}. ID: ${gameData.turnTimeoutId}`);
        }
        activeGames.set(gameData.gameId, gameData);
    }
}

async function processDuelPvBRollByEmoji(gameData, diceValue) {
    const logPrefix = `[Duel_PvBRollByEmoji_V3 GID:${gameData.gameId}]`;
    if (gameData.status !== 'player_awaiting_roll_emoji') {
        console.warn(`${logPrefix} Roll received in unexpected status: ${gameData.status}`);
        return;
    }

    if (gameData.turnTimeoutId) clearTimeout(gameData.turnTimeoutId);
    gameData.turnTimeoutId = null;

    gameData.playerRolls.push(diceValue);
    gameData.playerScore += diceValue;
    gameData.playerDiceRolledThisTurn++;
    gameData.lastInteractionTime = Date.now();

    const rollNumberText = gameData.playerDiceRolledThisTurn === 1 ? "first" : "second"; // Assuming DUEL_DICE_COUNT is 2
    const interimMsg = `${gameData.playerRefHTML} rolled a <b>${diceValue}</b> (their ${rollNumberText} die).`;

    if (gameData.playerDiceRolledThisTurn < DUEL_DICE_COUNT) {
        gameData.status = 'player_awaiting_roll_emoji'; 
        activeGames.set(gameData.gameId, gameData);
        await updateDuelPvBMessage(gameData.gameId, interimMsg); 
    } else { 
        gameData.status = 'bot_rolling_internal';
        activeGames.set(gameData.gameId, gameData);
        await updateDuelPvBMessage(gameData.gameId, interimMsg); 
        await sleep(1500); 
        await processDuelBotTurnPvB(gameData);
    }
}

async function handleDuelPvBTurnTimeout(gameId) {
    const logPrefix = `[Duel_PvB_Timeout_V3 GID:${gameId}]`;
    const gameData = activeGames.get(gameId);

    if (!gameData || gameData.type !== GAME_IDS.DUEL_PVB || gameData.status !== 'player_awaiting_roll_emoji') {
        if (gameData && gameData.turnTimeoutId) clearTimeout(gameData.turnTimeoutId);
        return;
    }
    console.log(`${logPrefix} Player ${gameData.playerId} timed out. Forfeiting Duel PvB.`);

    if (gameData.turnTimeoutId) clearTimeout(gameData.turnTimeoutId);
    gameData.turnTimeoutId = null;

    gameData.status = 'game_over_player_forfeit';
    activeGames.set(gameId, gameData);

    let client = null;
    try {
        client = await pool.connect(); await client.query('BEGIN');
        await updateUserBalanceAndLedger(client, gameData.playerId, 0n, 'loss_duel_pvb_timeout_forfeit', { game_id_custom_field: gameId }, `Duel PvB game ${gameId} forfeited by timeout.`);
        await client.query('COMMIT');
    } catch (e) {
        if(client) await client.query('ROLLBACK');
        console.error(`${logPrefix} DB error logging Duel PvB timeout forfeit: ${e.message}`);
    } finally {
        if(client) client.release();
    }
    await finalizeDuelPvBGame(gameData); 
}

async function processDuelBotTurnPvB(gameData) {
    const logPrefix = `[Duel_PvB_BotTurn_V4_Helper GID:${gameData.gameId}]`; // V4
    if (!gameData || gameData.status !== 'bot_rolling_internal') {
        console.warn(`${logPrefix} Incorrect status for bot turn: ${gameData?.status}`);
        return;
    }

    // Use the new helper for bot rolls
    const botRollsResult = await getDuelDiceRollsForBot_Internal(gameData.gameId, gameData.chatId, "Duel PvB Bot");

    if (botRollsResult.error) { // Checks if any error occurred during the helper's attempt to get rolls
        console.error(`${logPrefix} Bot failed to get sufficient rolls: ${botRollsResult.error || 'Incomplete rolls due to helper issues'}. Refunding player.`);
        if (gameData.gameMessageId && bot) await bot.deleteMessage(gameData.chatId, Number(gameData.gameMessageId)).catch(()=>{});
        const errorMsg = `${gameData.playerRefHTML}, Bot error during Duel. Your bet has been refunded.`;
        await safeSendMessage(gameData.chatId, errorMsg, {parse_mode: 'HTML', reply_markup: createPostGameKeyboard(GAME_IDS.DUEL_PVB, gameData.betAmount)});
        
        // Refund the player since bot couldn't roll
        let refundClient = null;
        try {
            refundClient = await pool.connect(); await refundClient.query('BEGIN');
            await updateUserBalanceAndLedger(refundClient, gameData.playerId, gameData.betAmount, 'refund_duel_pvb_bot_roll_fail', {game_id_custom_field: gameData.gameId}, `Refund Duel PvB game ${gameData.gameId} due to bot roll failure`);
            await refundClient.query('COMMIT');
        } catch(e){
            if(refundClient) await refundClient.query('ROLLBACK');
            console.error(`${logPrefix} CRITICAL REFUND FAILURE for game ${gameData.gameId}: ${e.message}`);
        } finally {
            if(refundClient) refundClient.release();
        }
        activeGames.delete(gameData.gameId);
        await updateGroupGameDetails(gameData.chatId, { removeThisId: gameData.gameId }, GAME_IDS.DUEL_PVB, null);
        return;
    }

    gameData.botRolls = botRollsResult.rolls;
    gameData.botScore = botRollsResult.rolls.reduce((sum, val) => sum + val, 0);
    gameData.status = 'game_over_pvb_resolved';
    activeGames.set(gameData.gameId, gameData);
    await finalizeDuelPvBGame(gameData);
}

// CORRECTED finalizeDuelPvBGame (with Referral Fixes)
async function finalizeDuelPvBGame(gameData) {
    const { gameId, chatId, playerId, playerRefHTML, playerScore, botScore, betAmount, userObj, playerRolls, botRolls, status: finalStatus, chatType } = gameData;
    const logPrefix = `[Duel_PvB_Finalize_V7_FullFix GID:${gameId}]`;
    const activeGameKey = GAME_IDS.DUEL_PVB;
    let allNotificationsToSend = [];

    let solPrice;
    try {
        solPrice = await getSolUsdPrice();
    } catch (priceError) {
        console.error(`${logPrefix} CRITICAL: Could not get SOL price. Level-up/milestone checks will be skipped. Error: ${priceError.message}`);
        solPrice = 0;
    }

    activeGames.delete(gameId);
    if (chatType && chatType !== 'private') { 
        await updateGroupGameDetails(chatId, { removeThisId: gameId }, activeGameKey, null);
    }

    let outcomeHeader = "", outcomeDetails = "", winningsText = "", titleEmoji = "⚔️";
    let payoutAmountLamports = 0n;
    let ledgerOutcomeCode = "";
    let gameOutcomeTextForLog = "";
    const betDisplayUSD_HTML_Final = escapeHTML(await formatBalanceForDisplay(betAmount, 'USD'));
    let isConclusiveOutcome = false;

    if (finalStatus === 'game_over_player_forfeit') {
        isConclusiveOutcome = true;
        titleEmoji = "⏳"; outcomeHeader = `🤦‍♂️ <b>Game Forfeited by ${playerRefHTML}!</b>`;
        outcomeDetails = `Your turn timed out. The Bot Dealer wins.`;
        ledgerOutcomeCode = 'loss_duel_pvb_timeout_forfeit'; 
        winningsText = `Your wager of <b>${betDisplayUSD_HTML_Final}</b> is lost.`;
        gameOutcomeTextForLog = `Player forfeit (Player: ${playerScore}, Bot: ${botScore})`;
    } else if (playerScore > botScore) {
        isConclusiveOutcome = true;
        titleEmoji = "🏆"; outcomeHeader = `🎉 <b>VICTORY, ${playerRefHTML}!</b>`;
        outcomeDetails = `Your score of <b>${playerScore}</b> triumphs over Bot's <i>${botScore}</i>.`;
        payoutAmountLamports = betAmount * 2n; ledgerOutcomeCode = 'win_duel_pvb';
        winningsText = `You win <b>${escapeHTML(await formatBalanceForDisplay(betAmount, 'USD'))}</b> profit! (Total Payout: <b>${escapeHTML(await formatBalanceForDisplay(payoutAmountLamports, 'USD'))}</b>)`;
        gameOutcomeTextForLog = `Player wins (${playerScore} vs ${botScore})`;
    } else if (botScore > playerScore) {
        isConclusiveOutcome = true;
        titleEmoji = "🤖"; outcomeHeader = `💔 <b>Bot Prevails, ${playerRefHTML}.</b>`;
        outcomeDetails = `Bot's score of <b>${botScore}</b> edges out your <i>${playerScore}</i>.`;
        ledgerOutcomeCode = 'loss_duel_pvb';
        winningsText = `The Bot Dealer claims your wager of <b>${betDisplayUSD_HTML_Final}</b>.`;
        gameOutcomeTextForLog = `Bot wins (${botScore} vs ${playerScore})`;
    } else { // Push
        isConclusiveOutcome = false;
        titleEmoji = "⚖️"; outcomeHeader = `⚖️ <b>A DRAW!</b>`;
        outcomeDetails = `Both scored <b>${playerScore}</b>!`;
        payoutAmountLamports = betAmount; ledgerOutcomeCode = 'push_duel_pvb';
        winningsText = `💰 Your wager of <b>${betDisplayUSD_HTML_Final}</b> is returned.`;
        gameOutcomeTextForLog = `Push (Draw at ${playerScore})`;
    }

    let finalMessageTextHTML = `${titleEmoji} <b>Duel Result: You vs Bot Dealer</b> ${titleEmoji}\n\nPlayer: ${playerRefHTML}\nWager: <b>${betDisplayUSD_HTML_Final}</b>\n------------------------------------\n<b>Rolls:</b>\n👤 You: ${formatDiceRolls(playerRolls)} ➠ Score: <b>${playerScore}</b>\n🤖 Bot: ${formatDiceRolls(botRolls || [])} ➠ Score: <b>${botScore || 0}</b>\n------------------------------------\n${outcomeHeader}\n${outcomeDetails}\n\n${winningsText}`;
    let client = null;
    try {
        client = await pool.connect(); await client.query('BEGIN');
        const actualGameLogId = await logGameResultToGamesTable(
            client, GAME_IDS.DUEL_PVB, chatId, playerId, [playerId], betAmount, gameOutcomeTextForLog, 0n
        );
        const balanceUpdate = await updateUserBalanceAndLedger(
            client, playerId, payoutAmountLamports, ledgerOutcomeCode, { game_log_id: actualGameLogId, original_bet_amount: betAmount.toString() }, `PvB Duel game ${gameId} result`, solPrice
        );
        if (!balanceUpdate.success) throw new Error(balanceUpdate.error || "DB Error Duel PvB payout.");
        if(balanceUpdate.notifications) allNotificationsToSend.push(...balanceUpdate.notifications);

        if (isConclusiveOutcome) {
            // --- START OF MODIFICATION ---

            // 1. ADDED: Check for the initial bet bonus.
            if (typeof processQualifyingBetAndInitialBonus === 'function') {
                const initialBonusResult = await processQualifyingBetAndInitialBonus(client, playerId, betAmount, gameId);
                if (initialBonusResult.jobQueued) {
                    console.log(`[ReferralCheck] Queued initial bet bonus job for user ${playerId} from game ${gameId}.`);
                }
            }

            // 2. MODIFIED: Correctly call level and milestone checks.
            if (balanceUpdate.newTotalWageredLamports !== undefined) {
                if (typeof checkAndUpdateUserLevel === 'function') {
                    const levelNotifications = await checkAndUpdateUserLevel(client, playerId, balanceUpdate.newTotalWageredLamports, solPrice, chatId);
                    allNotificationsToSend.push(...levelNotifications);
                }
                if (typeof processWagerMilestoneBonus === 'function') {
                    const milestoneResult = await processWagerMilestoneBonus(client, playerId, balanceUpdate.newTotalWageredLamports, solPrice);
                    if (!milestoneResult.success) {
                        console.warn(`${logPrefix} Failed to process milestone bonus: ${milestoneResult.error}`);
                    }
                }
            }
            // --- END OF MODIFICATION ---
        }
        
        await client.query('COMMIT');
    } catch (e) { 
        if (client) await client.query('ROLLBACK'); 
        finalMessageTextHTML += `\n\n⚠️ <i>Error settling wager. Admin notified.</i>`; 
        console.error(`${logPrefix} CRITICAL DB Error: ${e.message}`);
        if(typeof notifyAdmin === 'function') notifyAdmin(`🚨 CRITICAL Duel PvB Payout/Ledger Failure 🚨\nGame ID: \`${escapeMarkdownV2(gameId)}\` User: ${escapeMarkdownV2(String(playerId))}\nError: \`${escapeMarkdownV2(e.message)}\`. Manual check needed.`, {parse_mode: 'MarkdownV2'});
    } finally { if (client) client.release(); }

    // Send all collected notifications AFTER the transaction is closed
    for (const notification of allNotificationsToSend) {
        if (notification.to === ADMIN_USER_ID && typeof notifyAdmin === 'function') {
            await notifyAdmin(notification.text, notification.options).catch(err => console.error(`Failed to send admin notification: ${err.message}`));
        } else {
            await safeSendMessage(notification.to, notification.text, notification.options).catch(err => console.error(`Failed to send game-related notification to ${notification.to}: ${err.message}`));
        }
    }

    const postGameKeyboard = createPostGameKeyboard(GAME_IDS.DUEL_PVB, betAmount);
    if (gameData.gameMessageId && bot) await bot.deleteMessage(chatId, Number(gameData.gameMessageId)).catch(()=>{});
    await safeSendMessage(chatId, finalMessageTextHTML, { parse_mode: 'HTML', reply_markup: postGameKeyboard });
}

// --- Player vs. Player (PvP) Duel Game Logic ---
async function startDuelPvPGameSequence(
    pvpGameId, // Game ID is now passed in
    initiatorUserObj, 
    opponentUserObj,  
    betAmountLamports,
    groupChatId,      
    groupChatType,    
    originalOfferMsgIdToDelete = null,
    origin // 'unified_offer' or 'direct_challenge'
) {
    const logPrefix = `[Duel_PvP_StartSeq_V4_Origin GID:${pvpGameId} Origin:${origin}]`; // V4
    
    let activeGameKeyForStorage;
    if (origin === 'unified_offer') {
        activeGameKeyForStorage = GAME_IDS.DUEL_PVP_FROM_UNIFIED;
    } else { // 'direct_challenge'
        activeGameKeyForStorage = GAME_IDS.DUEL_PVP; 
    }

    if (originalOfferMsgIdToDelete && bot) {
        await bot.deleteMessage(groupChatId, Number(originalOfferMsgIdToDelete)).catch(e => {});
    }

    const initiatorPlayerDisplayName = escapeHTML(getPlayerDisplayReference(initiatorUserObj));
    const opponentPlayerDisplayName = escapeHTML(getPlayerDisplayReference(opponentUserObj));

    const initiatorPlayerData = {
        userId: String(initiatorUserObj.telegram_id),
        displayName: initiatorPlayerDisplayName,
        userObj: initiatorUserObj,
        rolls: [], score: 0, diceRolledThisTurn: 0, 
        isTurn: true, 
        status: 'awaiting_roll_emoji' 
    };
    const opponentPlayerData = {
        userId: String(opponentUserObj.telegram_id),
        displayName: opponentPlayerDisplayName,
        userObj: opponentUserObj,
        rolls: [], score: 0, diceRolledThisTurn: 0, 
        isTurn: false, 
        status: 'waiting_turn'
    };

    const gameData = {
        gameId: pvpGameId, type: GAME_IDS.DUEL_PVP, 
        chatId: String(groupChatId), chatType: groupChatType,
        betAmount: betAmountLamports,
        initiator: initiatorPlayerData,
        opponent: opponentPlayerData,
        status: 'p1_awaiting_roll_emoji', 
        currentMessageId: null, createdAt: Date.now(), 
        lastInteractionTime: Date.now(), currentTurnTimeoutId: null,
        _origin_key_for_limits: activeGameKeyForStorage // Store for cleanup
    };
    activeGames.set(pvpGameId, gameData);
    // Use specific key for active PvP Duel game (based on origin)
    await updateGroupGameDetails(groupChatId, pvpGameId, activeGameKeyForStorage, betAmountLamports); 
    console.log(`${logPrefix} Duel PvP game ${pvpGameId} created. Group lock using key ${activeGameKeyForStorage} updated. P1's turn.`);
    
    await updateDuelPvPMessage(pvpGameId); 
}

async function updateDuelPvPMessage(gameId) {
    const gameData = activeGames.get(gameId);
    if (!gameData || gameData.type !== GAME_IDS.DUEL_PVP) return;
    const logPrefix = `[UpdateDuelPvPMsg_V3 GID:${gameId}]`;

    if (gameData.currentTurnTimeoutId) { clearTimeout(gameData.currentTurnTimeoutId); gameData.currentTurnTimeoutId = null; }
    if (gameData.currentMessageId && bot) { await bot.deleteMessage(gameData.chatId, Number(gameData.currentMessageId)).catch(()=>{}); gameData.currentMessageId = null; }

    const p1 = gameData.initiator; const p2 = gameData.opponent;
    const betDisplayHTML_PvPUpdate = escapeHTML(await formatBalanceForDisplay(gameData.betAmount, 'USD'));
    let titleHTML = `⚔️ <b>High Stakes Duel: ${p1.displayName} vs ${p2.displayName}!</b> ⚔️`;
    let messageTextHTML = `${titleHTML}\nWager: <b>${betDisplayHTML_PvPUpdate}</b> each\n\n`;
    // Simplified status display for PvP
    messageTextHTML += `P1 ${p1.displayName}: ${formatDiceRolls(p1.rolls)} Sum: <b>${p1.score}</b> ${p1.status === 'rolls_complete' ? '✅ Done' : (p1.status === 'timeout_forfeit' ? '⏳ Forfeit' : (p1.status === 'awaiting_roll_emoji' && p1.isTurn ? '🎲 Rolling...' : ''))}\n`;
    messageTextHTML += `P2 ${p2.displayName}: ${formatDiceRolls(p2.rolls)} Sum: <b>${p2.score}</b> ${p2.status === 'rolls_complete' ? '✅ Done' : (p2.status === 'timeout_forfeit' ? '⏳ Forfeit' : (p2.status === 'awaiting_roll_emoji' && p2.isTurn ? '🎲 Rolling...' : (p2.status === 'waiting_turn' ? '⏳ Waiting...' : '')))}\n\n`;


    let actionPromptHTML = "";
    const activePlayer = p1.isTurn ? p1 : (p2.isTurn ? p2 : null);

    if (activePlayer && activePlayer.status === 'awaiting_roll_emoji' && !gameData.status.startsWith('game_over')) {
        const rollNumber = activePlayer.diceRolledThisTurn + 1;
        const rollNumberText = rollNumber === 1 ? "first" : "second"; // Assuming DUEL_DICE_COUNT is 2
        actionPromptHTML = `👉 <b>${escapeHTML(activePlayer.displayName)}</b>, send your <b>${rollNumberText}</b> of ${DUEL_DICE_COUNT} 🎲 dice. (Timeout: ${ACTIVE_GAME_TURN_TIMEOUT_MS / 1000}s)`;
    } else if (gameData.status.startsWith('game_over_')) {
        actionPromptHTML = `<i>🏁 Game concluding...</i>`;
    } else if (!activePlayer && p1.status === 'rolls_complete' && p2.status === 'rolls_complete') {
        actionPromptHTML = `<i>Both players have rolled! Revealing results...</i>`;
    }
     else {
        actionPromptHTML = `<i>Waiting...</i>`;
    }
    messageTextHTML += actionPromptHTML;

    const sentMessage = await safeSendMessage(gameData.chatId, messageTextHTML, { parse_mode: 'HTML' });
    if (sentMessage?.message_id) {
        gameData.currentMessageId = String(sentMessage.message_id);
        if (activePlayer && activePlayer.status === 'awaiting_roll_emoji' && !gameData.status.startsWith('game_over_')) {
            const timedOutPlayerId = activePlayer.userId;
            gameData.currentTurnTimeoutId = setTimeout(() => { handleDuelPvPTurnTimeout(gameData.gameId, timedOutPlayerId); }, ACTIVE_GAME_TURN_TIMEOUT_MS);
        }
        activeGames.set(gameId, gameData);
    }
}

async function processDuelPvPRollByEmoji(gameData, diceValue, rollerId) {
    const logPrefix = `[Duel_PvPRollByEmoji_V3 GID:${gameData.gameId} Roller:${rollerId}]`;
    let currentPlayer, otherPlayer, playerKeyPrefix;

    if (gameData.initiator.userId === rollerId && gameData.initiator.isTurn) { currentPlayer = gameData.initiator; otherPlayer = gameData.opponent; playerKeyPrefix = 'p1'; }
    else if (gameData.opponent.userId === rollerId && gameData.opponent.isTurn) { currentPlayer = gameData.opponent; otherPlayer = gameData.initiator; playerKeyPrefix = 'p2'; }
    else { console.warn(`${logPrefix} Roll from non-active player or out of turn.`); return; }

    if (currentPlayer.status !== 'awaiting_roll_emoji') { console.warn(`${logPrefix} Player ${currentPlayer.displayName} status is '${currentPlayer.status}'. Not expecting roll.`); return; }
    if (gameData.currentTurnTimeoutId) clearTimeout(gameData.currentTurnTimeoutId); gameData.currentTurnTimeoutId = null;

    currentPlayer.rolls.push(diceValue);
    currentPlayer.diceRolledThisTurn++;
    gameData.lastInteractionTime = Date.now();
    const rollNumberDisplay = currentPlayer.diceRolledThisTurn === 1 ? "first" : "second";
    await safeSendMessage(gameData.chatId, `🎲 ${escapeHTML(currentPlayer.displayName)} rolled a <b>${diceValue}</b> (their ${rollNumberDisplay} die).`, {parse_mode:'HTML'});
    await sleep(1000);

    if (currentPlayer.diceRolledThisTurn < DUEL_DICE_COUNT) {
        gameData.status = `${playerKeyPrefix}_awaiting_roll_emoji`; 
        activeGames.set(gameData.gameId, gameData);
        await updateDuelPvPMessage(gameData.gameId);
    } else { 
        currentPlayer.score = currentPlayer.rolls.reduce((a, b) => a + b, 0);
        currentPlayer.status = 'rolls_complete'; currentPlayer.isTurn = false;
        if (otherPlayer.status === 'waiting_turn') {
            otherPlayer.isTurn = true; otherPlayer.status = 'awaiting_roll_emoji'; otherPlayer.diceRolledThisTurn = 0; // Reset for their turn
            gameData.status = (otherPlayer === gameData.initiator) ? 'p1_awaiting_roll_emoji' : 'p2_awaiting_roll_emoji';
            activeGames.set(gameData.gameId, gameData);
            await updateDuelPvPMessage(gameData.gameId);
        } else if (otherPlayer.status === 'rolls_complete' || otherPlayer.status === 'timeout_forfeit') { // If other player also done or forfeited
            gameData.status = 'game_over_pvp_resolved'; activeGames.set(gameData.gameId, gameData);
            await updateDuelPvPMessage(gameData.gameId); await sleep(1500);
            await resolveDuelPvPGame(gameData);
        } else { 
            console.warn(`${logPrefix} Unexpected state after ${playerKeyPrefix} completed rolls. Other player status: ${otherPlayer.status}`);
            gameData.status = 'game_over_pvp_resolved'; activeGames.set(gameData.gameId, gameData); // Force resolution
            await resolveDuelPvPGame(gameData);
        }
    }
}

async function handleDuelPvPTurnTimeout(gameId, timedOutPlayerId) {
    const logPrefix = `[Duel_PvP_Timeout_V3 GID:${gameId} Player:${timedOutPlayerId}]`;
    const gameData = activeGames.get(gameId);
    if (!gameData || gameData.type !== GAME_IDS.DUEL_PVP || gameData.status.startsWith('game_over_')) {
        if (gameData && gameData.currentTurnTimeoutId) clearTimeout(gameData.currentTurnTimeoutId); return;
    }
    const activePlayer = gameData.initiator.isTurn ? gameData.initiator : (gameData.opponent.isTurn ? gameData.opponent : null);
    if (!activePlayer || activePlayer.userId !== timedOutPlayerId || activePlayer.status !== 'awaiting_roll_emoji') return;

    if (gameData.currentTurnTimeoutId) clearTimeout(gameData.currentTurnTimeoutId); gameData.currentTurnTimeoutId = null;
    let winner, loser;
    if (gameData.initiator.userId === timedOutPlayerId) {
        gameData.status = 'game_over_p1_timeout_forfeit'; gameData.initiator.status = 'timeout_forfeit'; winner = gameData.opponent; loser = gameData.initiator;
    } else {
        gameData.status = 'game_over_p2_timeout_forfeit'; gameData.opponent.status = 'timeout_forfeit'; winner = gameData.initiator; loser = gameData.opponent;
    }
    gameData.initiator.isTurn = false; gameData.opponent.isTurn = false;
    activeGames.set(gameId, gameData);
    await safeSendMessage(gameData.chatId, `⏳ ${escapeHTML(loser.displayName)} took too long! ${escapeHTML(winner.displayName)} wins by default!`, {parse_mode:'HTML'});
    await sleep(1000);
    await resolveDuelPvPGame(gameData);
}

// CORRECTED resolveDuelPvPGame (with ALL Fixes)
async function resolveDuelPvPGame(gameData, playerWhoForfeitedId = null) {
    // --- FIX APPLIED HERE: gameId is destructured immediately to be available in the catch block ---
    const { gameId } = gameData; 
    const logPrefix = `[Duel_PvP_Resolve_V8_FullFix GID:${gameId || 'UNKNOWN_GAME_ID'}]`;
    let allNotificationsToSend = [];

    let solPrice;
    try {
        solPrice = await getSolUsdPrice();
    } catch (priceError) {
        console.error(`${logPrefix} CRITICAL: Could not get SOL price. Level-up/milestone checks will be skipped. Error: ${priceError.message}`);
        solPrice = 0;
    }
    
    const { chatId, betAmount, initiator, opponent, chatType, status: finalStatus, _origin_key_for_limits } = gameData;
    if (gameData.currentTurnTimeoutId) { clearTimeout(gameData.currentTurnTimeoutId); gameData.currentTurnTimeoutId = null; }
    activeGames.delete(gameId);
    if (chatType && chatType !== 'private') {
        await updateGroupGameDetails(chatId, { removeThisId: gameId }, _origin_key_for_limits || GAME_IDS.DUEL_PVP, null);
    }
    
    const p1 = initiator; 
    const p2 = opponent;
    const p1MentionHTML = escapeHTML(p1.displayName); 
    const p2MentionHTML = escapeHTML(p2.displayName);
    let winner = null, loser = null, isPush = false, titleEmoji = "⚔️", resultHeaderHTML = "", outcomeDetails = "", winningsFooterHTML = "";
    const totalPotLamports = betAmount * 2n;
    let p1Payout = 0n; 
    let p2Payout = 0n;
    let p1LedgerCode = 'loss_duel_pvp'; 
    let p2LedgerCode = 'loss_duel_pvp';
    let gameOutcomeTextForLog = "";
    const betDisplayUSD_HTML_Resolve = escapeHTML(await formatBalanceForDisplay(betAmount, 'USD'));
    let isConclusiveOutcome = false;

    if (finalStatus === 'game_over_p1_timeout_forfeit' || (playerWhoForfeitedId && playerWhoForfeitedId === p1.userId)) {
        isConclusiveOutcome = true;
        titleEmoji = "⏳"; winner = p2; loser = p1; p2Payout = totalPotLamports;
        p2LedgerCode = 'win_duel_pvp_opponent_forfeit'; p1LedgerCode = 'loss_duel_pvp_self_forfeit';
        resultHeaderHTML = `⏳ <b>${p1MentionHTML} Forfeited!</b>`; 
        outcomeDetails = `${p2MentionHTML} wins!`;
        gameOutcomeTextForLog = `P2 wins by P1 forfeit (timeout)`;
    } else if (finalStatus === 'game_over_p2_timeout_forfeit' || (playerWhoForfeitedId && playerWhoForfeitedId === p2.userId)) {
        isConclusiveOutcome = true;
        titleEmoji = "⏳"; winner = p1; loser = p2; p1Payout = totalPotLamports;
        p1LedgerCode = 'win_duel_pvp_opponent_forfeit'; p2LedgerCode = 'loss_duel_pvp_self_forfeit';
        resultHeaderHTML = `⏳ <b>${p2MentionHTML} Forfeited!</b>`; 
        outcomeDetails = `${p1MentionHTML} wins!`;
        gameOutcomeTextForLog = `P1 wins by P2 forfeit (timeout)`;
    } else if (p1.status === 'rolls_complete' && p2.status === 'rolls_complete') { 
        if (p1.score > p2.score) {
            isConclusiveOutcome = true;
            titleEmoji = "🏆"; winner = p1; loser = p2; p1Payout = totalPotLamports;
            p1LedgerCode = 'win_duel_pvp_score';
            resultHeaderHTML = `🏆 <b>${p1MentionHTML} WINS!</b>`; 
            outcomeDetails = `<b>${p1.score}</b> vs <i>${p2.score}</i>.`;
            gameOutcomeTextForLog = `P1 wins by score (${p1.score} vs ${p2.score})`;
        } else if (p2.score > p1.score) {
            isConclusiveOutcome = true;
            titleEmoji = "🏆"; winner = p2; loser = p1; p2Payout = totalPotLamports;
            p2LedgerCode = 'win_duel_pvp_score';
            resultHeaderHTML = `🏆 <b>${p2MentionHTML} WINS!</b>`; 
            outcomeDetails = `<b>${p2.score}</b> vs <i>${p1.score}</i>.`;
            gameOutcomeTextForLog = `P2 wins by score (${p2.score} vs ${p1.score})`;
        } else { // Scores are equal
            isConclusiveOutcome = false;
            titleEmoji = "⚖️"; isPush = true; 
            resultHeaderHTML = `⚖️ <b>DRAW!</b>`; 
            outcomeDetails = `Both scored <b>${p1.score}</b>!`;
            p1Payout = gameData.betAmount; p2Payout = gameData.betAmount; 
            p1LedgerCode = 'push_duel_pvp'; p2LedgerCode = 'push_duel_pvp';
            gameOutcomeTextForLog = `Push (Draw at ${p1.score})`;
        }
    } else { 
        isConclusiveOutcome = false;
        titleEmoji = "⚙️"; isPush = true; 
        resultHeaderHTML = `⚙️ <b>Duel Inconclusive</b>`; 
        outcomeDetails = `Game ended unexpectedly. Bets refunded. P1 Status: ${p1.status}, P2 Status: ${p2.status}, Game: ${gameData.status}`;
        p1Payout = gameData.betAmount; p2Payout = gameData.betAmount;
        p1LedgerCode = 'refund_duel_pvp_error'; p2LedgerCode = 'refund_duel_pvp_error';
        gameOutcomeTextForLog = `Error - bets refunded (P1: ${p1.status}, P2: ${p2.status}, Game: ${gameData.status})`;
        console.warn(`${logPrefix} Duel PvP game ${gameId} resolved inconclusively. Statuses: P1=${p1.status}, P2=${p2.status}, Game=${gameData.status}`);
    }

    if (winner) {
        winningsFooterHTML = `🎉 <b>${escapeHTML(winner.displayName)}</b> wins the pot of <b>${escapeHTML(await formatBalanceForDisplay(totalPotLamports, 'USD'))}</b>!`;
    } else if (isPush) {
        winningsFooterHTML = `💰 Wagers of <b>${betDisplayUSD_HTML_Resolve}</b> each are returned.`;
    }

    const finalMessageHTML = `${titleEmoji}<b>Duel PvP Result</b>${titleEmoji}\n\n${p1MentionHTML} vs ${p2MentionHTML}\nWager: <b>${betDisplayUSD_HTML_Resolve}</b> each\n------------------------------------\n<b>Scores:</b>\n👤 ${p1MentionHTML}: ${formatDiceRolls(p1.rolls)} ➠ <b>${p1.score}</b>\n👤 ${p2MentionHTML}: ${formatDiceRolls(p2.rolls)} ➠ <b>${p2.score}</b>\n------------------------------------\n${resultHeaderHTML}\n${outcomeDetails}\n\n${winningsFooterHTML}`;
    let client = null;
    try {
        client = await pool.connect(); await client.query('BEGIN');
        const actualGameLogId = await logGameResultToGamesTable(
            client, gameData._origin_key_for_limits || GAME_IDS.DUEL_PVP, chatId, p1.userId, [p1.userId, p2.userId], betAmount, gameOutcomeTextForLog, 0n
        );
        
        const [playerA, playerB] = [p1, p2].sort((a, b) => String(a.userId).localeCompare(String(b.userId)));
        const payoutA = (playerA.userId === p1.userId) ? p1Payout : p2Payout;
        const payoutB = (playerB.userId === p1.userId) ? p1Payout : p2Payout;
        const ledgerCodeA = (playerA.userId === p1.userId) ? p1LedgerCode : p2LedgerCode;
        const ledgerCodeB = (playerB.userId === p1.userId) ? p1LedgerCode : p2LedgerCode;

        const p1Upd = await updateUserBalanceAndLedger(client, playerA.userId, payoutA, ledgerCodeA, {game_log_id: actualGameLogId, opponent_id_custom_field: playerB.userId, player_score: playerA.score, opponent_score: playerB.score, original_bet_amount: betAmount.toString() }, `Duel PvP vs ${playerB.displayName || playerB.userId}`, solPrice);
        if(!p1Upd.success) throw new Error(`Player A (${playerA.userId}) update failed: ${p1Upd.error}`);
        if(p1Upd.notifications) allNotificationsToSend.push(...p1Upd.notifications);
        
        const p2Upd = await updateUserBalanceAndLedger(client, playerB.userId, payoutB, ledgerCodeB, {game_log_id: actualGameLogId, opponent_id_custom_field: playerA.userId, player_score: playerB.score, opponent_score: playerA.score, original_bet_amount: betAmount.toString() }, `Duel PvP vs ${playerA.displayName || playerA.userId}`, solPrice);
        if(!p2Upd.success) throw new Error(`Player B (${playerB.userId}) update failed: ${p2Upd.error}`);
        if(p2Upd.notifications) allNotificationsToSend.push(...p2Upd.notifications);

        if (isConclusiveOutcome) {
            if (typeof processQualifyingBetAndInitialBonus === 'function') {
                await processQualifyingBetAndInitialBonus(client, p1.userId, betAmount, gameId);
                await processQualifyingBetAndInitialBonus(client, p2.userId, betAmount, gameId);
            }
            if (p1Upd.success && p1Upd.newTotalWageredLamports !== undefined) {
                const p1LevelNotifications = await checkAndUpdateUserLevel(client, p1.userId, p1Upd.newTotalWageredLamports, solPrice, chatId);
                allNotificationsToSend.push(...p1LevelNotifications);
                const p1MilestoneResult = await processWagerMilestoneBonus(client, p1.userId, p1Upd.newTotalWageredLamports, solPrice);
                if (!p1MilestoneResult.success) console.warn(`${logPrefix} Failed to process milestone bonus for P1: ${p1MilestoneResult.error}`);
            }
            if (p2Upd.success && p2Upd.newTotalWageredLamports !== undefined) {
                const p2LevelNotifications = await checkAndUpdateUserLevel(client, p2.userId, p2Upd.newTotalWageredLamports, solPrice, chatId);
                allNotificationsToSend.push(...p2LevelNotifications);
                const p2MilestoneResult = await processWagerMilestoneBonus(client, p2.userId, p2Upd.newTotalWageredLamports, solPrice);
                if (!p2MilestoneResult.success) console.warn(`${logPrefix} Failed to process milestone bonus for P2: ${p2MilestoneResult.error}`);
            }
        }
        
        await client.query('COMMIT');
    } catch (e) { 
        if (client) await client.query('ROLLBACK'); 
        const currentMsg = finalMessageHTML;
        const dbErrorText = `\n\n⚠️ <i>Error settling wagers. Admin notified.</i>`;
        const finalMessageTextHTMLWithError = currentMsg + dbErrorText;
        console.error(`${logPrefix} CRITICAL DB Error: ${e.message}`);
        if (typeof notifyAdmin === 'function') notifyAdmin(`🚨 CRITICAL Duel PvP Payout Failure 🚨\nGame ID: <code>${escapeHTML(gameId)}</code>\nWinner: ${winner?.displayName || 'N/A'}\nLoser: ${loser?.displayName || 'N/A'}\nError: ${escapeHTML(e.message)}. MANUAL CHECK REQUIRED.`, { parse_mode: 'HTML' });
        if (gameData.currentMessageId && bot) await bot.deleteMessage(String(chatId), Number(gameData.currentMessageId)).catch(()=>{});
        const finalKeyboardError = createPostGameKeyboard(GAME_IDS.DUEL_PVP, betAmount);
        await safeSendMessage(chatId, finalMessageTextHTMLWithError, { parse_mode: 'HTML', reply_markup: finalKeyboardError });
        return; 
    } finally { if (client) client.release(); }
    
    for (const notification of allNotificationsToSend) {
        if (notification.to === ADMIN_USER_ID && typeof notifyAdmin === 'function') {
            await notifyAdmin(notification.text, notification.options).catch(err => console.error(`Failed to send admin notification: ${err.message}`));
        } else {
            await safeSendMessage(notification.to, notification.text, notification.options).catch(err => console.error(`Failed to send game-related notification to ${notification.to}: ${err.message}`));
        }
    }

    if (gameData.currentMessageId && bot) await bot.deleteMessage(String(chatId), Number(gameData.currentMessageId)).catch(()=>{});
    const finalKeyboardSuccess = createPostGameKeyboard(GAME_IDS.DUEL_PVP, betAmount);
    await safeSendMessage(chatId, finalMessageHTML, { parse_mode: 'HTML', reply_markup: finalKeyboardSuccess });
}
// --- End of Part 5c, Section 2 (COMPLETE REWRITE FOR NEW DUEL GAME LOGIC - CONSOLIDATED UPDATES - GRANULAR ACTIVE GAME LIMITS) ---
// --- Start of Part 5c, Section 3 (NEW) - Segment 1 & 2 (FULLY UPDATED FOR HELPER BOT DICE ROLLS for Ladder, Animated for SevenOut - SEVENOUT REPLACED WITH LUCKY SUM - FIXES APPLIED - GRANULAR ACTIVE GAME LIMITS) ---
// Assumed dependencies from previous Parts

// --- Greed's Ladder Game Logic ---

// CORRECTED handleStartLadderCommand (with Referral Fixes)
async function handleStartLadderCommand(msg, betAmountLamports) {
    const userId = String(msg.from.id || msg.from.telegram_id);
    const chatId = String(msg.chat.id);
    const LOG_PREFIX_LADDER_START = `[Ladder_Start_V9_FullFix UID:${userId} CH:${chatId}]`;
    let allNotificationsToSend = [];

    let solPrice;
    try {
        solPrice = await getSolUsdPrice();
    } catch (priceError) {
        console.error(`${LOG_PREFIX_LADDER_START} CRITICAL: Could not get SOL price. Bonus checks will be skipped. Error: ${priceError.message}`);
        solPrice = 0;
    }

    const activeUserGameCheck = await checkUserActiveGameLimit(userId, false, null); 
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = escapeHTML(getPlayerDisplayReference(msg.from));
        const blockingGameType = activeUserGameCheck.details.type;
        const cleanGameName = getCleanGameName(blockingGameType); 
        const alertMessage = `✨ ${userDisplayName}, you already have a pending offer or active game for <b>${escapeHTML(cleanGameName)}</b>. ✨`;
        await safeSendMessage(chatId, alertMessage, { parse_mode: 'HTML' });
        return;
    }

    if (typeof betAmountLamports !== 'bigint' || betAmountLamports <= 0n) {
        await safeSendMessage(chatId, "🪜 Oops! The wager for Greed's Ladder is incorrect. Please try again.", { parse_mode: 'HTML' });
        return;
    }

    let userObj = await getOrCreateUser(userId, msg.from.username, msg.from.first_name, msg.from.last_name);
    if (!userObj) {
        await safeSendMessage(chatId, "😕 Greetings, climber! We couldn't find your profile for Greed's Ladder. Try <code>/start</code>.", { parse_mode: 'HTML' });
        return;
    }

    const playerRefHTML = escapeHTML(getPlayerDisplayReference(userObj));
    let betDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(betAmountLamports, 'USD'));

    if (BigInt(userObj.balance) < betAmountLamports) {
        const needed = betAmountLamports - BigInt(userObj.balance);
        const neededDisplayHTML = escapeHTML(await formatBalanceForDisplay(needed, 'USD'));
        await safeSendMessage(chatId, `${playerRefHTML}, your treasure chest is light for a <b>${betDisplayUSD_HTML}</b> Greed's Ladder climb! You need ~<b>${neededDisplayHTML}</b> more. Care to top up?`, {
            parse_mode: 'HTML',
            reply_markup: { inline_keyboard: [[{ text: "💰 Add Funds (DM)", callback_data: QUICK_DEPOSIT_CALLBACK_ACTION_CONST }]] }
        });
        return;
    }

    const gameSession = await getGroupSession(chatId, msg.chat.title);
    const activeGameKey = GAME_IDS.LADDER; 
    const currentActiveLadderGames = gameSession.activeGamesByTypeInGroup.get(activeGameKey) || [];
    const limitActive = GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[activeGameKey] || 1;

    if (currentActiveLadderGames.length >= limitActive) {
        await safeSendMessage(chatId, `⏳ ${playerRefHTML}, the limit of ${limitActive} concurrent Greed's Ladder game(s) in this group has been reached. Please wait.`, { parse_mode: 'HTML' });
        return;
    }

    const gameId = generateGameId(GAME_IDS.LADDER);
    let client = null;
    let totalWageredAfterBetPlacement; 

    try {
        client = await pool.connect();
        await client.query('BEGIN');
        const initialBalanceUpdateResult = await updateUserBalanceAndLedger(
            client, userId, BigInt(-betAmountLamports),
            'bet_placed_ladder', { game_id_custom_field: gameId }, 
            `Bet for Greed's Ladder game ${gameId}`,
            solPrice
        );

        if (!initialBalanceUpdateResult || !initialBalanceUpdateResult.success) {
            await client.query('ROLLBACK');
            console.error(`${LOG_PREFIX_LADDER_START} Wager placement failed: ${initialBalanceUpdateResult?.error || 'Unknown error'}.`);
            await safeSendMessage(chatId, `${playerRefHTML}, your Ladder wager (<b>${betDisplayUSD_HTML}</b>) failed: <code>${escapeHTML(initialBalanceUpdateResult?.error || "Wallet error")}</code>.`, { parse_mode: 'HTML' });
            return;
        }
        totalWageredAfterBetPlacement = initialBalanceUpdateResult.newTotalWageredLamports;
        if (initialBalanceUpdateResult.notifications) allNotificationsToSend.push(...initialBalanceUpdateResult.notifications);
        userObj.balance = initialBalanceUpdateResult.newBalanceLamports;

        const gameDataForInstance = { 
            type: GAME_IDS.LADDER, gameId, chatId, userId, playerRef: playerRefHTML,
            userObj, betAmount: betAmountLamports, rolls: [], sum: 0n, gameMessageId: null
        };
        activeGames.set(gameId, gameDataForInstance);
        await updateGroupGameDetails(chatId, gameId, activeGameKey, betAmountLamports);
        console.log(`${LOG_PREFIX_LADDER_START} Ladder game ${gameId} bet placed, lock updated.`);

        const titleSpinningHTML = `🪜 <b>Greed's Ladder - The Climb Begins!</b> 🪜`;
        let messageTextHTML_Spinning = `${titleSpinningHTML}\n\n${playerRefHTML} wagers <b>${betDisplayUSD_HTML}</b> and steps onto Greed's Ladder!\nRequesting <b>${escapeHTML(String(LADDER_ROLL_COUNT))} dice</b> from the Helper Bot... 🎲⏳`;

        const sentRollingMsg = await safeSendMessage(chatId, messageTextHTML_Spinning, {parse_mode: 'HTML'});
        if (sentRollingMsg?.message_id) {
            if(activeGames.has(gameId)) activeGames.get(gameId).gameMessageId = sentRollingMsg.message_id;
        } else {
            await client.query('ROLLBACK'); 
            console.error(`${LOG_PREFIX_LADDER_START} CRITICAL: Failed to send initial Ladder message for ${gameId}. Bet rolled back.`);
            activeGames.delete(gameId);
            await updateGroupGameDetails(chatId, { removeThisId: gameId }, activeGameKey, null); 
            return;
        }

        let diceRolls = [];
        let helperBotError = null;
        let isBust = false;

        for (let i = 0; i < LADDER_ROLL_COUNT; i++) {
            if (isShuttingDown) { helperBotError = "Shutdown during Ladder dice requests."; break; }
            const rollResult = await getSingleDiceRollViaHelper(gameId, chatId, userId, `Ladder Roll ${i+1}`);
            if (rollResult.error) { helperBotError = rollResult.message || `Failed to get Ladder Roll ${i+1}`; break; }
            if (typeof rollResult.roll !== 'number') { helperBotError = `Invalid roll type for Ladder Roll ${i+1}`; break; }
            diceRolls.push(rollResult.roll);
            if (rollResult.roll === LADDER_BUST_ON) { isBust = true; break; }
        }
        
        const currentDataAfterRolls = activeGames.get(gameId);
        if(!currentDataAfterRolls){
            console.error(`${LOG_PREFIX_LADDER_START} GameData for ${gameId} gone after rolls. Bet was taken. Refunding in new TX.`); 
            await client.query('ROLLBACK'); // Rollback initial transaction attempt
            let refundClientLostState = null;
            try {
                refundClientLostState = await pool.connect(); await refundClientLostState.query('BEGIN');
                await updateUserBalanceAndLedger(refundClientLostState, userId, betAmountLamports, 'refund_ladder_state_lost', {original_game_id_text: gameId}, `Refund Ladder game ${gameId} state lost after rolls`);
                await refundClientLostState.query('COMMIT');
            } catch (e) { if(refundClientLostState) await refundClientLostState.query('ROLLBACK'); console.error(`${LOG_PREFIX_LADDER_START} CRITICAL REFUND FAILURE for lost state game ${gameId}: ${e.message}`);}
            finally { if(refundClientLostState) refundClientLostState.release(); }
            await updateGroupGameDetails(chatId, { removeThisId: gameId }, activeGameKey, null); 
            return;
        }
        currentDataAfterRolls.rolls = diceRolls;
        currentDataAfterRolls.sum = BigInt(diceRolls.reduce((sum, val) => sum + val, 0));

        if (helperBotError || (!isBust && currentDataAfterRolls.rolls.length !== LADDER_ROLL_COUNT)) {
            const errorMsgToUserHTML = `⚠️ ${playerRefHTML}, error rolling for Greed's Ladder: <code>${escapeHTML(String(helperBotError || "Incomplete rolls").substring(0,150))}</code><br>Bet <b>${betDisplayUSD_HTML}</b> refunded.`;
            if (currentDataAfterRolls.gameMessageId && bot) {
                await bot.deleteMessage(String(chatId), Number(currentDataAfterRolls.gameMessageId)).catch(e => {});
            }
            await safeSendMessage(String(chatId), errorMsgToUserHTML, { parse_mode: 'HTML', reply_markup: createPostGameKeyboard(GAME_IDS.LADDER, betAmountLamports) });
            
            await updateUserBalanceAndLedger(client, userId, betAmountLamports, 'refund_ladder_helper_fail', {game_id_custom_field: gameId}, `Refund Ladder game ${gameId} helper error`, solPrice);
            await client.query('COMMIT'); // Commit refund
            activeGames.delete(gameId);
            await updateGroupGameDetails(chatId, { removeThisId: gameId }, activeGameKey, null); 
            return;
        }

        let payoutAmountLamportsFinal = 0n;
        let outcomeReasonLog = "";
        let resultTextPartHTML = "";
        let gameOutcomeTextForTable = "";
        let isConclusiveOutcome = false;

        if (isBust) {
            outcomeReasonLog = `loss_ladder_bust_r${LADDER_BUST_ON}`;
            resultTextPartHTML = `💥 <b>CRASH! A ${escapeHTML(String(LADDER_BUST_ON))} appeared!</b> 💥\nYou tumbled off Greed's Ladder! Wager lost.`;
            currentDataAfterRolls.status = 'game_over_player_bust';
            gameOutcomeTextForTable = `Player Bust (Rolled ${LADDER_BUST_ON})`;
            isConclusiveOutcome = true;
        } else {
            let foundPayout = false;
            for (const payoutTier of LADDER_PAYOUTS) {
                if (currentDataAfterRolls.sum >= payoutTier.min && currentDataAfterRolls.sum <= payoutTier.max) {
                    const profitLamports = betAmountLamports * BigInt(payoutTier.multiplier);
                    payoutAmountLamportsFinal = betAmountLamports + profitLamports; 
                    outcomeReasonLog = `win_ladder_s${currentDataAfterRolls.sum}_m${payoutTier.multiplier}`;
                    resultTextPartHTML = `${escapeHTML(payoutTier.label)} You won <b>${escapeHTML(await formatBalanceForDisplay(profitLamports, 'USD'))}</b> in profit!`;
                    gameOutcomeTextForTable = `Win - Sum ${currentDataAfterRolls.sum} (Tier: ${payoutTier.label})`;
                    foundPayout = true;
                    break;
                }
            }
            if (!foundPayout) {
                outcomeReasonLog = 'loss_ladder_no_tier';
                resultTextPartHTML = "😐 A cautious climb, but not high enough for a prize. Wager lost.";
                gameOutcomeTextForTable = `Loss - No Payout Tier (Sum: ${currentDataAfterRolls.sum})`;
            }
            currentDataAfterRolls.status = 'game_over_resolved';
            isConclusiveOutcome = true;
        }
        
        const actualGameLogId = await logGameResultToGamesTable(
            client, GAME_IDS.LADDER, chatId, userId, [userId], betAmountLamports, gameOutcomeTextForTable, 0n
        );
        
        const finalBalanceUpdateResult = await updateUserBalanceAndLedger(
            client, userId, payoutAmountLamportsFinal,
            outcomeReasonLog, { game_log_id: actualGameLogId, original_bet_amount: betAmountLamports.toString() }, 
            `Greed's Ladder: Sum ${currentDataAfterRolls.sum}, Rolls ${currentDataAfterRolls.rolls.join(',')}.`,
            solPrice
        );

        if (!finalBalanceUpdateResult.success) { 
            await client.query('ROLLBACK');
            throw new Error(finalBalanceUpdateResult.error || "DB Error on Ladder payout/loss ledgering."); 
        }
        if (finalBalanceUpdateResult.notifications) allNotificationsToSend.push(...finalBalanceUpdateResult.notifications);

        if (isConclusiveOutcome && totalWageredAfterBetPlacement !== undefined) {
            // --- START OF MODIFICATION ---

            // 1. ADDED: Check for the initial bet bonus.
            if (typeof processQualifyingBetAndInitialBonus === 'function') {
                const initialBonusResult = await processQualifyingBetAndInitialBonus(client, userId, betAmountLamports, gameId);
                if (initialBonusResult.jobQueued) {
                    console.log(`[ReferralCheck] Queued initial bet bonus job for user ${userId} from game ${gameId}.`);
                }
            }

            // 2. MODIFIED: Correctly call level and milestone checks.
            const levelNotifications = await checkAndUpdateUserLevel(client, userId, totalWageredAfterBetPlacement, solPrice, chatId);
            allNotificationsToSend.push(...levelNotifications);
            const milestoneResult = await processWagerMilestoneBonus(client, userId, totalWageredAfterBetPlacement, solPrice);
            if (!milestoneResult.success) {
                console.warn(`${LOG_PREFIX_LADDER_START} Failed to process milestone bonus: ${milestoneResult.error}`);
            }
            
            // --- END OF MODIFICATION ---
        }
        
        await client.query('COMMIT');
        
        const titleResultHTML = `🏁 <b>Greed's Ladder - The Outcome!</b> 🏁`;
        let finalMessageTextHTML = `${titleResultHTML}\n\n${playerRefHTML}'s wager: <b>${betDisplayUSD_HTML}</b>\nDice: ${formatDiceRolls(currentDataAfterRolls.rolls)}\nSum: <b>${escapeHTML(String(currentDataAfterRolls.sum))}</b>\n\n`;
        finalMessageTextHTML += resultTextPartHTML;

        const postGameKeyboardLadder = createPostGameKeyboard(GAME_IDS.LADDER, betAmountLamports);
        if (currentDataAfterRolls.gameMessageId && bot) {
            await bot.deleteMessage(String(chatId), Number(currentDataAfterRolls.gameMessageId)).catch(e => {});
        }
        await safeSendMessage(String(chatId), finalMessageTextHTML, { parse_mode: 'HTML', reply_markup: postGameKeyboardLadder });

    } catch (error) { 
        if (client) await client.query('ROLLBACK').catch(rbErr => console.error(`${LOG_PREFIX_LADDER_START} DB Rollback Error on main catch: ${rbErr.message}`));
        console.error(`${LOG_PREFIX_LADDER_START} Error during Ladder game processing: ${error.message}`, error.stack?.substring(0,500));
        await safeSendMessage(chatId, `⚙️ An error occurred with Greed's Ladder: ${escapeHTML(error.message)}. Please try again.`, { parse_mode: 'HTML' });
    } finally {
        if (client) client.release();
    }

    // Send all collected notifications AFTER the transaction is closed
    for (const notification of allNotificationsToSend) {
        if (notification.to === ADMIN_USER_ID && typeof notifyAdmin === 'function') {
            await notifyAdmin(notification.text, notification.options).catch(err => console.error(`Failed to send admin notification: ${err.message}`));
        } else {
            await safeSendMessage(notification.to, notification.text, notification.options).catch(err => console.error(`Failed to send game-related notification to ${notification.to}: ${err.message}`));
        }
    }

    activeGames.delete(gameId); 
    await updateGroupGameDetails(chatId, { removeThisId: gameId }, activeGameKey, null); 
}


// --- Sevens Out (Lucky Sum Variant) Game Logic ---

const LUCKY_SUM_PAYOUTS = {
    2: { multiplier: 2, label: "Snake Eyes! 🐍" },
    12: { multiplier: 2, label: "Boxcars! 🚂" },
    3: { multiplier: 1, label: "Easy Three!" },
    4: { multiplier: 1, label: "Fever Four!" },
    9: { multiplier: 1, label: "Nina Nine!" },
    10: { multiplier: 1, label: "Big Ten!" },
    11: { multiplier: 1, label: "Yo Eleven!" },
};
const LUCKY_SUM_LOSING_NUMBERS = [5, 6, 7, 8]; // Sums that result in a loss

async function handleStartSevenOutCommand(msg, betAmountLamports) {
    const userId = String(msg.from.id || msg.from.telegram_id);
    const chatId = String(msg.chat.id);
    const LOG_PREFIX_S7_LUCKY_SUM_START = `[S7_LuckySum_Start_V3_GranLimit UID:${userId} CH:${chatId}]`; 

    const activeUserGameCheck = await checkUserActiveGameLimit(userId, false, null); 
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = escapeHTML(getPlayerDisplayReference(msg.from));
        const blockingGameType = activeUserGameCheck.details.type;
        const cleanGameName = getCleanGameName(blockingGameType); 
        const alertMessage = `✨ ${userDisplayName}, you already have a pending offer or active game for <b>${escapeHTML(cleanGameName)}</b>. ✨`;
        await safeSendMessage(chatId, alertMessage, { parse_mode: 'HTML' });
        return;
    }

    if (typeof betAmountLamports !== 'bigint' || betAmountLamports <= 0n) {
        await safeSendMessage(chatId, "🎲 Invalid bet for Lucky Sum! Use a valid amount.", { parse_mode: 'HTML' });
        return;
    }

    let userObj = await getOrCreateUser(userId, msg.from.username, msg.from.first_name, msg.from.last_name);
    if (!userObj) {
        await safeSendMessage(chatId, "😕 Couldn't find your player profile for Lucky Sum. Try <code>/start</code>.", { parse_mode: 'HTML' });
        return;
    }

    const playerRefHTML = escapeHTML(getPlayerDisplayReference(userObj));
    const betDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(betAmountLamports, 'USD'));

    if (BigInt(userObj.balance) < betAmountLamports) {
        const needed = betAmountLamports - BigInt(userObj.balance);
        await safeSendMessage(chatId, `${playerRefHTML}, your balance is too low for a <b>${betDisplayUSD_HTML}</b> Lucky Sum game. You need ~<b>${escapeHTML(await formatBalanceForDisplay(needed, 'USD'))}</b> more.`, {
            parse_mode: 'HTML',
            reply_markup: { inline_keyboard: [[{ text: "💰 Add Funds (DM)", callback_data: QUICK_DEPOSIT_CALLBACK_ACTION_CONST }]] }
        });
        return;
    }

    const gameSession = await getGroupSession(chatId, msg.chat.title);
    const activeGameKey = GAME_IDS.SEVEN_OUT; 
    const currentActiveS7Games = gameSession.activeGamesByTypeInGroup.get(activeGameKey) || [];
    const limitActive = GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[activeGameKey] || 1;

    if (currentActiveS7Games.length >= limitActive) {
        await safeSendMessage(chatId, `⏳ ${playerRefHTML}, the limit of ${limitActive} concurrent Lucky Sum game(s) in this group has been reached. Please wait.`, { parse_mode: 'HTML' });
        return;
    }

    const gameId = generateGameId(GAME_IDS.SEVEN_OUT);
    let client = null;
    let totalWageredForLevelCheck; // Variable to store wagered amount for level check

    try {
        client = await pool.connect();
        await client.query('BEGIN');
        const balanceUpdateResult = await updateUserBalanceAndLedger(
            client, userId, BigInt(-betAmountLamports),
            'bet_placed_s7_luckysum', { game_id_custom_field: gameId },
            `Bet for Lucky Sum (S7) game ${gameId}`
        );
        if (!balanceUpdateResult.success) {
            await client.query('ROLLBACK');
            await safeSendMessage(chatId, `${playerRefHTML}, your Lucky Sum wager (<b>${betDisplayUSD_HTML}</b>) failed: <code>${escapeHTML(balanceUpdateResult.error || "DB Error")}</code>.`, { parse_mode: 'HTML' });
            return;
        }
        // *** MODIFIED PART: Store newTotalWageredLamports ***
        totalWageredForLevelCheck = balanceUpdateResult.newTotalWageredLamports;
        // *** END OF MODIFIED PART ***
        await client.query('COMMIT'); // Commit the bet placement
        userObj.balance = balanceUpdateResult.newBalanceLamports;
    } catch (dbError) {
        if (client) await client.query('ROLLBACK').catch(rbErr => console.error(`${LOG_PREFIX_S7_LUCKY_SUM_START} DB Rollback Error: ${rbErr.message}`));
        console.error(`${LOG_PREFIX_S7_LUCKY_SUM_START} DB error: ${dbError.message}`);
        await safeSendMessage(chatId, "⚙️ Database error starting Lucky Sum. Please try again.", { parse_mode: 'HTML' });
        return;
    } finally {
        if (client) client.release();
    }

    const gameData = {
        type: GAME_IDS.SEVEN_OUT, gameId, chatId, userId, playerRef: playerRefHTML, userObj,
        betAmount: betAmountLamports, rolls: [], currentSum: 0n,
        status: 'awaiting_single_roll', 
        gameMessageIdToDelete: null,
        lastInteractionTime: Date.now(),
        totalWageredForLevelCheck: totalWageredForLevelCheck // Store it in gameData
    };
    activeGames.set(gameId, gameData);
    await updateGroupGameDetails(chatId, gameId, activeGameKey, betAmountLamports);
    console.log(`${LOG_PREFIX_S7_LUCKY_SUM_START} Lucky Sum game ${gameId} started, active games lock updated for key ${activeGameKey}.`);

    const titleHTML = `🎲 <b>Lucky Sum Roll!</b> 🎲`;
    const initialMessageTextHTML = `${titleHTML}\n\n${playerRefHTML}, your bet of <b>${betDisplayUSD_HTML}</b> is on the line!\nI'll roll two dice for you... Good luck! 🍀`;

    const sentInitialMsg = await safeSendMessage(chatId, initialMessageTextHTML, {parse_mode: 'HTML'});
    if (sentInitialMsg?.message_id) {
        const currentData = activeGames.get(gameId);
        if(currentData) { // Ensure gameData still exists
            currentData.gameMessageIdToDelete = sentInitialMsg.message_id; 
            // No need to activeGames.set here if currentData is a direct reference
        }
        if (typeof processSevenOutRoll === 'function') {
            await processSevenOutRoll(gameData); // Pass the gameData containing totalWageredForLevelCheck 
        } else {
            console.error(`${LOG_PREFIX_S7_LUCKY_SUM_START} CRITICAL: processSevenOutRoll function not found!`);
            activeGames.delete(gameId);
            await updateGroupGameDetails(chatId, { removeThisId: gameId }, activeGameKey, null);
            // Bet was already committed, need to refund if processSevenOutRoll is missing
            let refundClientFail;
            try{
                refundClientFail = await pool.connect(); await refundClientFail.query('BEGIN');
                await updateUserBalanceAndLedger(refundClientFail, userId, betAmountLamports, 'refund_s7_luckysum_logic_fail', {game_id_custom_field: gameId}, `Refund S7 game ${gameId} logic fail`);
                await refundClientFail.query('COMMIT');
            } catch(e){if(refundClientFail) await refundClientFail.query('ROLLBACK');}
            finally {if(refundClientFail) refundClientFail.release();}
        }
    } else {
        console.error(`${LOG_PREFIX_S7_LUCKY_SUM_START} Failed to send initial Lucky Sum message. Bet was taken but game cannot proceed. Refunding.`);
        // Bet was committed. Need to refund.
        let refundClientMsgFail;
        try {
            refundClientMsgFail = await pool.connect(); await refundClientMsgFail.query('BEGIN');
            await updateUserBalanceAndLedger(refundClientMsgFail, userId, betAmountLamports, 'refund_s7_luckysum_setup_fail', {game_id_custom_field: gameId}, `Refund S7 game ${gameId} setup fail (msg send)`);
            await refundClientMsgFail.query('COMMIT');
        } catch (err) { if (refundClientMsgFail) await refundClientMsgFail.query('ROLLBACK'); console.error(`${LOG_PREFIX_S7_LUCKY_SUM_START} Refund FAILED for game ${gameId}: ${err.message}`); }
        finally { if (refundClientMsgFail) refundClientMsgFail.release(); }
        activeGames.delete(gameId);
        await updateGroupGameDetails(chatId, { removeThisId: gameId }, activeGameKey, null);
    }
}

async function processSevenOutRoll(gameDataInput) { // gameDataInput is the reference from activeGames
    const { gameId, userId, chatId, playerRef, betAmount } = gameDataInput; // Destructure from input
    const LOG_PREFIX_S7_LUCKY_ROLL = `[S7_LuckySum_Roll_V6_GranLimit GID:${gameId} UID:${userId}]`; // V6

    // Ensure gameData is still valid and in correct state from activeGames
    let gameData = activeGames.get(gameId);
    if (!gameData || gameData.status !== 'awaiting_single_roll') {
        console.warn(`${LOG_PREFIX_S7_LUCKY_ROLL} Invalid game state: ${gameData?.status} or game not found for ID ${gameId}. Aborting roll.`);
        return;
    }
    gameData.status = 'processing_roll';
    activeGames.set(gameId, gameData); // Update status immediately

    if (gameData.gameMessageIdToDelete && bot) {
        await bot.deleteMessage(chatId, Number(gameData.gameMessageIdToDelete)).catch(e => {});
        gameData.gameMessageIdToDelete = null; // Clear after attempting delete
        activeGames.set(gameId, gameData); // Save cleared message ID
    }

    const rollingMessageHTML = `🎲 ${escapeHTML(playerRef)} rolling for Lucky Sum... The dice are tumbling! 🌪️`;
    const tempRollingMsg = await safeSendMessage(chatId, rollingMessageHTML, { parse_mode: 'HTML' });
    if (tempRollingMsg?.message_id && activeGames.has(gameId)) { // Store this temp message to delete it soon
         activeGames.get(gameId).gameMessageIdToDelete = tempRollingMsg.message_id;
    }
    await sleep(1000); // Pause for effect

    let currentRolls = [];
    let currentSum = 0;
    let animatedDiceMessageIds = []; // To store IDs of animated dice messages

    for (let i = 0; i < 2; i++) { // Assumes 2 dice for Lucky Sum
        try {
            const diceMsg = await bot.sendDice(String(chatId), { emoji: '🎲' });
            currentRolls.push(diceMsg.dice.value);
            currentSum += diceMsg.dice.value;
            if (diceMsg.message_id) animatedDiceMessageIds.push(diceMsg.message_id);
            await sleep(2200); // Let animation play
        } catch (e) {
            console.warn(`${LOG_PREFIX_S7_LUCKY_ROLL} Failed to send animated dice, using internal roll. Error: ${e.message}`);
            const internalRollVal = rollDie(); // rollDie() is from Part 3
            currentRolls.push(internalRollVal); 
            currentSum += internalRollVal;
            const fallbackMsg = await safeSendMessage(String(chatId), `⚙️ ${escapeHTML(playerRef)} (Internal Roll ${i + 1}): <b>${internalRollVal}</b> 🎲`, { parse_mode: 'HTML' });
            if (fallbackMsg?.message_id) animatedDiceMessageIds.push(fallbackMsg.message_id); // Store to delete
            await sleep(500); // Shorter sleep for internal roll message
        }
    }

    // Clean up messages: the "rolling..." message and the animated dice messages
    if (tempRollingMsg?.message_id && bot) await bot.deleteMessage(chatId, tempRollingMsg.message_id).catch(() => {});
    if (activeGames.has(gameId)) activeGames.get(gameId).gameMessageIdToDelete = null; // Clear stored ID

    for (const id of animatedDiceMessageIds) {
        if (bot) await bot.deleteMessage(String(chatId), id).catch(() => {});
    }
    
    // Re-fetch gameData as it might have been updated by other async operations (though unlikely here)
    gameData = activeGames.get(gameId);
    if (!gameData) { // Game might have been cancelled or timed out during sleep/rolls
        console.warn(`${LOG_PREFIX_S7_LUCKY_ROLL} Game ${gameId} no longer active after dice rolls. Aborting finalization.`);
        return;
    }

    gameData.rolls = currentRolls;
    gameData.currentSum = BigInt(currentSum); // Ensure it's BigInt

    let win = false;
    let payoutRule = LUCKY_SUM_PAYOUTS[currentSum]; // Check if the sum is a key in payouts
    let profitMultiplier = 0;
    let outcomeReasonLog = `loss_s7_luckysum_sum${currentSum}`;
    let resultTitleHTML = "";
    let resultDetailsHTML = "";
    let financialOutcomeHTML = "";
    let payoutAmountLamportsFinal = 0n;

    const betDisplayUSD_HTML_Result = escapeHTML(await formatBalanceForDisplay(betAmount, 'USD'));

    if (payoutRule) { // Win condition based on LUCKY_SUM_PAYOUTS
        win = true; 
        profitMultiplier = payoutRule.multiplier;
        outcomeReasonLog = `win_s7_luckysum_sum${currentSum}_mult${profitMultiplier}`;
        resultTitleHTML = `🎲✨ <b>Lucky Sum - YOU WIN!</b> ✨🎲`;
        resultDetailsHTML = `Your roll sum of <b>${currentSum}</b> hit: ${escapeHTML(payoutRule.label)}`;
        const currentProfitLamports = betAmount * BigInt(profitMultiplier); 
        payoutAmountLamportsFinal = betAmount + currentProfitLamports; 
        financialOutcomeHTML = `You won <b>${escapeHTML(await formatBalanceForDisplay(currentProfitLamports, 'USD'))}</b> in profit!\n(Total Payout: <b>${escapeHTML(await formatBalanceForDisplay(payoutAmountLamportsFinal, 'USD'))}</b>)`;
    } else { // Loss condition (either specific losing numbers or no payout rule hit)
        win = false;
        payoutAmountLamportsFinal = 0n; 
        resultTitleHTML = `🎲😥 <b>Lucky Sum - Not This Time!</b> 😥🎲`;
        if (LUCKY_SUM_LOSING_NUMBERS.includes(currentSum)) {
            resultDetailsHTML = `A sum of <b>${currentSum}</b> means the house takes this round.`;
        } else {
            resultDetailsHTML = `Your roll of <b>${currentSum}</b> didn't hit a winning number.`;
        }
        financialOutcomeHTML = `Your wager of <b>${betDisplayUSD_HTML_Result}</b> is lost. Better luck next time! 🍀`;
    }

    gameData.status = 'game_over';
    activeGames.set(gameId, gameData); // Update final status

    let messageToPlayerHTML = `${resultTitleHTML}\n<pre>==============================</pre>\n` +
        `Player: <b>${escapeHTML(playerRef)}</b>\nWager: <b>${betDisplayUSD_HTML_Result}</b>\n` +
        `<pre>------------------------------</pre>\n` +
        `Dice Rolled: ${formatDiceRolls(currentRolls)} ➠ Sum: <b>${currentSum}</b>!\n` +
        `<pre>==============================</pre>\n` +
        `${resultDetailsHTML}\n${financialOutcomeHTML}`;

    await finalizeSevenOutGame(gameData, messageToPlayerHTML, payoutAmountLamportsFinal, outcomeReasonLog);
}

// CORRECTED finalizeSevenOutGame (with Referral Fixes)
async function finalizeSevenOutGame(gameData, resultMessageHTML, payoutAmountLamports, outcomeReasonLog) {
    const { gameId, chatId, userId, playerRef, betAmount, userObj, totalWageredForLevelCheck, rolls, currentSum } = gameData;
    const LOG_PREFIX_S7_FINALIZE_LUCKY = `[S7_LuckySum_Finalize_V8_FullFix GID:${gameId} UID:${userId}]`;
    const activeGameKey = GAME_IDS.SEVEN_OUT;
    let allNotificationsToSend = [];

    let solPrice;
    try {
        solPrice = await getSolUsdPrice();
    } catch (priceError) {
        console.error(`${LOG_PREFIX_S7_FINALIZE_LUCKY} CRITICAL: Could not get SOL price. Level-up/milestone checks will be skipped. Error: ${priceError.message}`);
        solPrice = 0;
    }

    let clientOutcome = null;
    let dbErrorText = "";
    let gameOutcomeTextForTable = `Sum: ${currentSum}, Choice (N/A for LuckySum), Outcome: ${outcomeReasonLog}`;
    const payoutRuleForLog = LUCKY_SUM_PAYOUTS[Number(currentSum)];
    if (payoutRuleForLog) {
        gameOutcomeTextForTable = `Win - Sum ${currentSum} (${payoutRuleForLog.label})`;
    } else if (LUCKY_SUM_LOSING_NUMBERS.includes(Number(currentSum))) {
        gameOutcomeTextForTable = `Loss - Sum ${currentSum} (Losing Number)`;
    } else {
        gameOutcomeTextForTable = `Loss - Sum ${currentSum} (No Payout)`;
    }

    try {
        clientOutcome = await pool.connect();
        await clientOutcome.query('BEGIN');

        const actualGameLogId = await logGameResultToGamesTable(
            clientOutcome, GAME_IDS.SEVEN_OUT, chatId, userId, [userId], betAmount, gameOutcomeTextForTable, 0n
        );

        const ledgerReasonForTransactionType = outcomeReasonLog.length > 50 ? outcomeReasonLog.substring(0, 47) + "..." : outcomeReasonLog;
        const fullNotesForLedger = `${outcomeReasonLog} (Game ID: ${gameId})`;

        const balanceUpdate = await updateUserBalanceAndLedger(
            clientOutcome, userId, payoutAmountLamports,
            ledgerReasonForTransactionType,
            { game_log_id: actualGameLogId, dice_rolls_s7_luckysum: rolls.join(','), sum_s7_luckysum: currentSum.toString(), original_bet_amount: betAmount.toString() },
            fullNotesForLedger,
            solPrice
        );
        if (!balanceUpdate.success) { 
            await clientOutcome.query('ROLLBACK');
            throw new Error(balanceUpdate.error || "DB error settling Lucky Sum bet."); 
        }
        if (balanceUpdate.notifications) allNotificationsToSend.push(...balanceUpdate.notifications);

        // --- START OF MODIFICATION ---
        // This game is always a conclusive wager.
        if (totalWageredForLevelCheck !== undefined) {
            // 1. ADDED: Check for the initial bet bonus.
            if (typeof processQualifyingBetAndInitialBonus === 'function') {
                const initialBonusResult = await processQualifyingBetAndInitialBonus(clientOutcome, userId, betAmount, gameId);
                if (initialBonusResult.jobQueued) {
                    console.log(`[ReferralCheck] Queued initial bet bonus job for user ${userId} from game ${gameId}.`);
                }
            }

            // 2. MODIFIED: Correctly call level and milestone checks.
            const levelNotifications = await checkAndUpdateUserLevel(clientOutcome, userId, totalWageredForLevelCheck, solPrice, chatId);
            allNotificationsToSend.push(...levelNotifications);
            const milestoneResult = await processWagerMilestoneBonus(clientOutcome, userId, totalWageredForLevelCheck, solPrice);
            if (!milestoneResult.success) {
                console.warn(`${LOG_PREFIX_S7_FINALIZE_LUCKY} Failed to process milestone bonus: ${milestoneResult.error}`);
            }
        }
        // --- END OF MODIFICATION ---

        await clientOutcome.query('COMMIT');
    } catch (dbError) {
        if (clientOutcome) { 
            try { await clientOutcome.query('ROLLBACK'); } catch (rbErr) { console.error(`${LOG_PREFIX_S7_FINALIZE_LUCKY} Rollback error: ${rbErr.message}`);}
        }
        dbErrorText = `\n\n⚠️ Error settling wager: <code>${escapeHTML(dbError.message)}</code>. Admin notified.`;
        console.error(`${LOG_PREFIX_S7_FINALIZE_LUCKY} DB error: ${dbError.message}`);
        if (typeof notifyAdmin === 'function') {
            notifyAdmin(`🚨 CRITICAL Lucky Sum Payout/Ledger Failure 🚨\nGame ID: \`${escapeHTML(gameId)}\` User: ${escapeHTML(String(userId))}\nError: \`${escapeHTML(dbError.message)}\`. Manual check needed.`, {parse_mode: 'MarkdownV2'});
        }
    } finally {
        if (clientOutcome) clientOutcome.release();
    }

    // Send all collected notifications AFTER the transaction is closed
    for (const notification of allNotificationsToSend) {
        if (notification.to === ADMIN_USER_ID && typeof notifyAdmin === 'function') {
            await notifyAdmin(notification.text, notification.options).catch(err => console.error(`Failed to send admin notification: ${err.message}`));
        } else {
            await safeSendMessage(notification.to, notification.text, notification.options).catch(err => console.error(`Failed to send game-related notification to ${notification.to}: ${err.message}`));
        }
    }
    
    let finalMessageWithDbStatusHTML = resultMessageHTML + dbErrorText;
    const postGameKeyboardS7 = createPostGameKeyboard(GAME_IDS.SEVEN_OUT, betAmount);
    await safeSendMessage(String(chatId), finalMessageWithDbStatusHTML, { parse_mode: 'HTML', reply_markup: postGameKeyboardS7 });

    activeGames.delete(gameId);
    await updateGroupGameDetails(chatId, { removeThisId: gameId }, activeGameKey, null); 
    console.log(`${LOG_PREFIX_S7_FINALIZE_LUCKY} Game ${gameId} finalized and lock cleared for key ${activeGameKey}.`);
}

// --- End of Part 5c, Section 3 (Ladder & Lucky Sum - GRANULAR ACTIVE GAME LIMITS) ---
// --- Start of Part 5c, Section 4 (Slot Frenzy Game Logic - GRANULAR ACTIVE GAME LIMITS) ---
// index.js - Part 5c, Section 4: Slot Frenzy Game Logic
// (Callback Router part from original section title was noted as commented out by user)
//----------------------------------------------------------------------------------------------------
// Assumed dependencies from previous Parts

// --- Slot Frenzy Game Logic ---

// CORRECTED handleStartSlotCommand (v9 - with Failsafe for Lost Game State)
async function handleStartSlotCommand(msg, betAmountLamports) {
    const userId = String(msg.from.id || msg.from.telegram_id);
    const chatId = String(msg.chat.id);
    const LOG_PREFIX_SLOT_START = `[Slot_Start_V9_FailsafeFix UID:${userId} CH:${chatId}]`;
    let allNotificationsToSend = [];

    let solPrice;
    try {
        solPrice = await getSolUsdPrice();
    } catch (priceError) {
        console.error(`${LOG_PREFIX_SLOT_START} CRITICAL: Could not get SOL price. Bonus checks will be skipped. Error: ${priceError.message}`);
        solPrice = 0;
    }

    const activeUserGameCheck = await checkUserActiveGameLimit(userId, false, null);
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = escapeHTML(getPlayerDisplayReference(msg.from));
        const blockingGameType = activeUserGameCheck.details.type;
        const cleanGameName = getCleanGameName(blockingGameType);
        const alertMessage = `✨ ${userDisplayName}, you already have a pending offer or active game for <b>${escapeHTML(cleanGameName)}</b>. ✨`;
        await safeSendMessage(chatId, alertMessage, { parse_mode: 'HTML' });
        return;
    }

    if (typeof betAmountLamports !== 'bigint' || betAmountLamports <= 0n) {
        await safeSendMessage(chatId, "🎰 Oh dear! That bet amount for Slot Frenzy doesn't look quite right.<br>Please try again with a valid wager.", { parse_mode: 'HTML' });
        return;
    }

    let userObj = await getOrCreateUser(userId, msg.from.username, msg.from.first_name, msg.from.last_name);
    if (!userObj) {
        await safeSendMessage(chatId, "😕 Hey spinner! We couldn't find your player profile for Slot Frenzy.<br>Please hit <code>/start</code> first.", { parse_mode: 'HTML' });
        return;
    }

    const playerRefHTML = escapeHTML(getPlayerDisplayReference(userObj));
    const betDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(betAmountLamports, 'USD'));

    if (BigInt(userObj.balance) < betAmountLamports) {
        const needed = betAmountLamports - BigInt(userObj.balance);
        const neededDisplayHTML = escapeHTML(await formatBalanceForDisplay(needed, 'USD'));
        await safeSendMessage(chatId, `${playerRefHTML}, your casino wallet needs a bit more sparkle for a <b>${betDisplayUSD_HTML}</b> spin on Slot Frenzy! You're short by about <b>${neededDisplayHTML}</b>. Time to reload?`, {
            parse_mode: 'HTML',
            reply_markup: { inline_keyboard: [[{ text: "💰 Add Funds (DM)", callback_data: QUICK_DEPOSIT_CALLBACK_ACTION_CONST }]] }
        });
        return;
    }

    const gameSession = await getGroupSession(chatId, msg.chat.title);
    const activeGameKey = GAME_IDS.SLOT_FRENZY;
    const currentActiveSlotGames = gameSession.activeGamesByTypeInGroup.get(activeGameKey) || [];
    const limitActive = GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[activeGameKey] || 1;

    if (currentActiveSlotGames.length >= limitActive) {
        await safeSendMessage(chatId, `⏳ ${playerRefHTML}, the limit of ${limitActive} concurrent Slot Frenzy game(s) in this group has been reached. Please wait.`, { parse_mode: 'HTML' });
        return;
    }

    const gameId = generateGameId(GAME_IDS.SLOT_FRENZY);
    let client = null;
    let requestId;
    let totalWageredAfterBetPlacement;

    try {
        client = await pool.connect();
        await client.query('BEGIN');
        const initialBalanceUpdateResult = await updateUserBalanceAndLedger(client, userId, BigInt(-betAmountLamports), 'bet_placed_slot', { game_id_custom_field: gameId }, `Bet for Slot Frenzy game ${gameId}`, solPrice);
        if (!initialBalanceUpdateResult.success) throw new Error(initialBalanceUpdateResult.error || "Wager placement failed.");
        totalWageredAfterBetPlacement = initialBalanceUpdateResult.newTotalWageredLamports;
        if (initialBalanceUpdateResult.notifications) allNotificationsToSend.push(...initialBalanceUpdateResult.notifications);
        userObj.balance = initialBalanceUpdateResult.newBalanceLamports;
        const requestResult = await insertDiceRollRequest(client, gameId, chatId, userId, '🎰', 'Slot Frenzy Spin');
        if (!requestResult.success || !requestResult.requestId) throw new Error(requestResult.error || "Failed to create slot spin request in DB.");
        requestId = requestResult.requestId;
        await client.query('COMMIT');
    } catch (dbError) {
        if (client) await client.query('ROLLBACK');
        console.error(`${LOG_PREFIX_SLOT_START} Database error during bet/request phase: ${dbError.message}`);
        await safeSendMessage(chatId, "⚙️ A database disturbance prevented your Slot Frenzy game. Please try again.", { parse_mode: 'HTML' });
        return;
    } finally {
        if (client) client.release();
    }

    const gameDataForInstance = {
        type: GAME_IDS.SLOT_FRENZY, gameId, chatId, userId, playerRef: playerRefHTML, userObj,
        betAmount: betAmountLamports, gameMessageId: null,
        totalWageredForLevelCheck: totalWageredAfterBetPlacement
    };
    activeGames.set(gameId, gameDataForInstance);
    await updateGroupGameDetails(chatId, gameId, activeGameKey, betAmountLamports);

    const titleSpinningHTML = `🎰 <b>Slot Frenzy - Reels in Motion!</b> 🎰`;
    let initialMessageTextHTML = `${titleSpinningHTML}\n\n` + `Player: <b>${playerRefHTML}</b>\nBet: <b>${betDisplayUSD_HTML}</b>\n\n` + `Hold tight! The Helper Bot is revving up the Slot Machine! 💨\n`+ `✨ May fortune favor your spin! ✨`;
    const sentSpinningMsg = await safeSendMessage(chatId, initialMessageTextHTML, {parse_mode: 'HTML'});
    
    if (sentSpinningMsg?.message_id) {
        const gameDataRef = activeGames.get(gameId);
        if(gameDataRef) gameDataRef.gameMessageId = sentSpinningMsg.message_id;
    } else {
        console.error(`${LOG_PREFIX_SLOT_START} Failed to send initial Slot game message after bet was taken. Refunding.`);
        let refundClient;
        try {
            refundClient = await pool.connect(); await refundClient.query('BEGIN');
            await updateUserBalanceAndLedger(refundClient, userId, betAmountLamports, 'refund_slot_ui_fail', {game_id_custom_field: gameId}, 'Refund Slot UI fail');
            await refundClient.query('COMMIT');
        } catch(e) { if(refundClient) await refundClient.query('ROLLBACK'); } finally { if(refundClient) refundClient.release(); }
        activeGames.delete(gameId);
        await updateGroupGameDetails(chatId, { removeThisId: gameId }, activeGameKey, null);
        return;
    }

    let diceRollValue = null;
    let helperBotError = null;
    try {
        let attempts = 0;
        while(attempts < DICE_ROLL_POLLING_MAX_ATTEMPTS) {
            await sleep(DICE_ROLL_POLLING_INTERVAL_MS);
            if (isShuttingDown) { helperBotError = "Shutdown during slot poll."; break; }
            const pollClient = await pool.connect();
            try {
                const statusResult = await getDiceRollRequestResult(pollClient, requestId);
                if (statusResult.success && statusResult.status === 'completed') { diceRollValue = statusResult.roll_value; break; } 
                else if (statusResult.success && statusResult.status === 'error') { helperBotError = statusResult.notes || "Helper Bot reported an error."; break; }
            } finally { pollClient.release(); }
            attempts++;
        }
        if (diceRollValue === null && !helperBotError) {
            helperBotError = "Timeout waiting for Helper Bot slot spin result.";
            const timeoutClient = await pool.connect();
            try { await timeoutClient.query("UPDATE dice_roll_requests SET status='timeout', notes=$1 WHERE request_id=$2 AND status='pending'", [helperBotError.substring(0,250), requestId]); } finally { timeoutClient.release(); }
        }
        if (helperBotError) throw new Error(helperBotError);
        if (typeof diceRollValue !== 'number') throw new Error ("Invalid slot roll value type from helper.");
    } catch (e) { helperBotError = e.message; }
    
    // --- Stage 4: Finalize Game ---
    const finalGameData = activeGames.get(gameId);

    // --- FIX IS HERE: This block now handles the silent failure case ---
    if (!finalGameData) {
        console.error(`${LOG_PREFIX_SLOT_START} CRITICAL: GameData for ${gameId} vanished before finalization. Bet was already taken. This could be a race condition or memory issue. Refunding user as a failsafe.`);
        let refundClient;
        try {
            refundClient = await pool.connect();
            await refundClient.query('BEGIN');
            await updateUserBalanceAndLedger(refundClient, userId, betAmountLamports, 'refund_slot_state_lost', {game_id_custom_field: gameId}, 'Refund due to lost game state before finalization');
            await refundClient.query('COMMIT');
            await safeSendMessage(chatId, `⚙️ Apologies, there was an unexpected issue finalizing your spin. Your bet of <b>${betDisplayUSD_HTML}</b> has been refunded.`, { parse_mode: 'HTML' });
        } catch (e) {
            if (refundClient) await refundClient.query('ROLLBACK');
            console.error(`${LOG_PREFIX_SLOT_START} CRITICAL REFUND FAILURE for lost state game ${gameId}: ${e.message}`);
            if(typeof notifyAdmin === 'function') await notifyAdmin(`CRITICAL REFUND FAILURE for lost game state. GID: ${gameId}, UID: ${userId}`);
        } finally {
            if (refundClient) refundClient.release();
        }
        return;
    }
    // --- END OF FIX ---

    if (finalGameData.gameMessageId && bot) {
        await bot.deleteMessage(chatId, Number(finalGameData.gameMessageId)).catch(e => {});
        finalGameData.gameMessageId = null;
    }

    if (helperBotError) {
        const errorMsgToUserHTML = `💣 <b>Slot Spin Malfunction!</b> 💣\n\nOh no, ${playerRefHTML}! Slot Machine hiccup: <pre>${escapeHTML(String(helperBotError).substring(0,150))}</pre>\n\n✅ Bet <b>${betDisplayUSD_HTML}</b> refunded.`;
        const errorKeyboard = createPostGameKeyboard(GAME_IDS.SLOT_FRENZY, betAmountLamports);
        await safeSendMessage(String(chatId), errorMsgToUserHTML, { parse_mode: 'HTML', reply_markup: errorKeyboard });
        let refundClient;
        try {
            refundClient = await pool.connect(); await refundClient.query('BEGIN');
            await updateUserBalanceAndLedger(refundClient, userId, betAmountLamports, 'refund_slot_helper_fail', {game_id_custom_field: gameId}, `Refund Slot game ${gameId} - Helper Bot error`, solPrice);
            await client.query('COMMIT');
        } catch(e){ if(refundClient) await refundClient.query('ROLLBACK'); } finally { if(refundClient) refundClient.release(); }
        activeGames.delete(gameId);
        await updateGroupGameDetails(chatId, { removeThisId: gameId }, activeGameKey, null);
        return;
    }

    finalGameData.diceValue = diceRollValue;
    const payoutInfo = SLOT_PAYOUTS[diceRollValue];
    let payoutAmountLamportsFinal = 0n;
    let profitAmountLamports = 0n;
    let outcomeReasonLog = `loss_slot_val${diceRollValue}`;
    let resultTextPartHTML = "";
    let finalTitleHTML = "";
    let gameOutcomeTextForTable = "";
    let isConclusiveOutcome = true;

    if (payoutInfo) { // Win
        profitAmountLamports = betAmountLamports * BigInt(payoutInfo.multiplier);
        payoutAmountLamportsFinal = betAmountLamports + profitAmountLamports;
        outcomeReasonLog = `win_slot_val${diceRollValue}_mult${payoutInfo.multiplier}`;
        finalTitleHTML = `🎉🎉 <b>${escapeHTML(payoutInfo.label)}</b> 🎉🎉`;
        resultTextPartHTML = `✨ <b>AMAZING HIT!</b> ✨\n<b>${escapeHTML(payoutInfo.symbols)}</b>\n\n` + `Congratulations! You've won a dazzling <b>${escapeHTML(await formatBalanceForDisplay(profitAmountLamports, 'USD'))}</b> in profit!\n` + `(Total Payout: <b>${escapeHTML(await formatBalanceForDisplay(payoutAmountLamportsFinal, 'USD'))}</b>)`;
        gameOutcomeTextForTable = `Win - ${payoutInfo.label} (${payoutInfo.symbols})`;
    } else { // Loss
        payoutAmountLamportsFinal = 0n;
        finalTitleHTML = `😕 <b>Slot Frenzy - No Win This Time</b> 😕`;
        resultTextPartHTML = `Reel Result: <i>Not a winning combination.</i>\n\n` + `The machine keeps your wager of <b>${betDisplayUSD_HTML}</b>.\nBetter luck on the next spin! 🍀`;
        gameOutcomeTextForTable = `Loss (Value: ${diceRollValue})`;
    }
    
    let finalizationClient = null;
    try {
        finalizationClient = await pool.connect();
        await finalizationClient.query('BEGIN');
        const actualGameLogId = await logGameResultToGamesTable(finalizationClient, GAME_IDS.SLOT_FRENZY, chatId, userId, [userId], betAmountLamports, gameOutcomeTextForTable, 0n);
        const finalBalanceUpdateResult = await updateUserBalanceAndLedger(finalizationClient, userId, payoutAmountLamportsFinal, outcomeReasonLog, { game_log_id: actualGameLogId, slot_dice_value: diceRollValue, original_bet_amount: betAmountLamports.toString() }, `Outcome of Slot Frenzy game ${gameId}. Slot value: ${diceRollValue}.`, solPrice);
        if (!finalBalanceUpdateResult.success) throw new Error(finalBalanceUpdateResult.error || "DB Error on Slot Frenzy payout/loss ledgering.");
        if (finalBalanceUpdateResult.notifications) allNotificationsToSend.push(...finalBalanceUpdateResult.notifications);

        if (isConclusiveOutcome && totalWageredAfterBetPlacement !== undefined) {
            const initialBonusResult = await processQualifyingBetAndInitialBonus(finalizationClient, userId, betAmountLamports, gameId);
            if (initialBonusResult.jobQueued) console.log(`[ReferralCheck] Queued initial bet bonus job for user ${userId} from game ${gameId}.`);
            const levelNotifications = await checkAndUpdateUserLevel(finalizationClient, userId, totalWageredAfterBetPlacement, solPrice, chatId);
            allNotificationsToSend.push(...levelNotifications);
            const milestoneResult = await processWagerMilestoneBonus(finalizationClient, userId, totalWageredAfterBetPlacement, solPrice);
            if (!milestoneResult.success) console.warn(`${LOG_PREFIX_SLOT_START} Failed to process milestone bonus: ${milestoneResult.error}`);
        }
        
        await finalizationClient.query('COMMIT');
    } catch (error) {
        if (finalizationClient) await finalizationClient.query('ROLLBACK');
        console.error(`${LOG_PREFIX_SLOT_START} Error during finalization: ${error.message}`);
        resultTextPartHTML += `\n\n⚠️ Error settling wager. Admin notified.`;
    } finally {
        if (finalizationClient) finalizationClient.release();
    }
    
    for (const notification of allNotificationsToSend) {
        safeSendMessage(notification.to, notification.text, notification.options);
    }
    
    let finalMessageTextHTML = `${finalTitleHTML}\n\n` + `Player: <b>${playerRefHTML}</b>\nWager: <b>${betDisplayUSD_HTML}</b>\n\n` + `${resultTextPartHTML}`;
    const postGameKeyboardSlot = createPostGameKeyboard(GAME_IDS.SLOT_FRENZY, betAmountLamports);
    await safeSendMessage(String(chatId), finalMessageTextHTML, { parse_mode: 'HTML', reply_markup: postGameKeyboardSlot });

    activeGames.delete(gameId);
    await updateGroupGameDetails(chatId, { removeThisId: gameId }, activeGameKey, null);
    console.log(`${LOG_PREFIX_SLOT_START} Slot Frenzy game ${gameId} finalized. Lock for ${activeGameKey} cleared.`);
}
// --- End of Part 5c, Section 4 (Slot Frenzy Game Logic) ---
// --- Start of Part 5d (Mines Game - GRANULAR ACTIVE GAME LIMITS - FULL CODE - CORRECTED) ---
// index.js - Part 5d: Mines Game Logic & Callback Handlers
//----------------------------------------------------------------------------------------------------

// ASSUMED GLOBAL DEPENDENCIES (defined in other Parts of your index.js):
// - Constants: GAME_IDS, MINES_DIFFICULTY_CONFIG, MINES_MIN_MINES, TILE_EMOJI_HIDDEN, TILE_EMOJI_GEM, TILE_EMOJI_MINE, TILE_EMOJI_EXPLOSION, RULES_CALLBACK_PREFIX_CONST, QUICK_DEPOSIT_CALLBACK_ACTION_CONST
// - Bot Instance: bot (from node-telegram-bot-api)
// - Database: pool (pg.Pool instance), queryDatabase
// - Utility Functions: safeSendMessage, escapeHTML, formatBalanceForDisplay, formatCurrency,
//                      getPlayerDisplayReference, generateGameId, createPostGameKeyboard, parseBetAmount,
//                      getOrCreateUser, updateUserBalanceAndLedger, updateGroupGameDetails, getGroupSession, checkUserActiveGameLimit
// - Global State: activeGames (Map)
// - Timeout Constants: ACTIVE_GAME_TURN_TIMEOUT_MS, UNIFIED_OFFER_TIMEOUT_MS, GAME_ACTIVITY_LIMITS

// FINAL-FIX handleStartMinesCommand
async function handleStartMinesCommand(msg, args, userObj) {
    const userId = String(userObj.telegram_id);
    const chatId = String(msg.chat.id);
    const chatType = msg.chat.type;
    const LOG_PREFIX_MINES_START = `[Mines_StartOffer_V6_FinalFix UID:${userId} CH:${chatId}]`;
    
    let solPrice;
    try {
        solPrice = await getSolUsdPrice();
    } catch (priceError) {
        console.error(`${LOG_PREFIX_MINES_START} CRITICAL: Could not get SOL price. Bonus checks may be skipped. Error: ${priceError.message}`);
        solPrice = 0;
    }
    
    let notificationsToSend = [];

    const activeUserGameCheck = await checkUserActiveGameLimit(userId, false, null);
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = escapeHTML(getPlayerDisplayReference(msg.from));
        const blockingGameType = activeUserGameCheck.details.type;
        const cleanGameName = getCleanGameName(blockingGameType);
        const alertMessage = `✨ ${userDisplayName}, you already have a pending offer or active game for <b>${escapeHTML(cleanGameName)}</b>. ✨`;
        await safeSendMessage(chatId, alertMessage, { parse_mode: 'HTML' });
        return;
    }

    const playerRefHTML = escapeHTML(getPlayerDisplayReference(userObj));
    let betAmountLamports;

    if (chatType === 'private') {
        await safeSendMessage(chatId, `💣 Hey ${playerRefHTML}, Mines is best in a <b>group chat</b>. Use <code>/mines &lt;bet&gt;</code> there!`, { parse_mode: 'HTML' });
        return;
    }

    try {
        betAmountLamports = await parseBetAmount(args[0], chatId, chatType, userId);
        if (!betAmountLamports || betAmountLamports <= 0n) {
            await safeSendMessage(chatId, `${playerRefHTML}, please specify a valid bet for Mines.<br>Example: <code>/mines 10</code>`, { parse_mode: 'HTML' });
            return;
        }
    } catch (e) {
        await safeSendMessage(chatId, `${playerRefHTML}, issue with your bet amount. Use USD or SOL (e.g., <code>0.1 sol</code>). Error: ${escapeHTML(e.message)}`, { parse_mode: 'HTML' });
        return;
    }

    const currentBalance = BigInt(userObj.balance);
    const betDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(betAmountLamports, 'USD'));

    if (currentBalance < betAmountLamports) {
        const neededDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(betAmountLamports - currentBalance, 'USD'));
        await safeSendMessage(chatId, `${playerRefHTML}, balance too low for a <b>${betDisplayUSD_HTML}</b> Mines game.<br>Need ~<b>${neededDisplayUSD_HTML}</b> more.`, {
            parse_mode: 'HTML', reply_markup: { inline_keyboard: [[{ text: "💰 Add Funds (DM)", callback_data: QUICK_DEPOSIT_CALLBACK_ACTION_CONST }]] }
        });
        return;
    }

    const gameSession = await getGroupSession(chatId, msg.chat.title || `Group Chat ${chatId}`);
    const offerActivityKey = GAME_IDS.MINES_OFFER;
    const currentMinesOffers = gameSession.activeGamesByTypeInGroup.get(offerActivityKey) || [];
    const limitUnified = GAME_ACTIVITY_LIMITS.UNIFIED_OFFERS[offerActivityKey] || 1;

    if (currentMinesOffers.length >= limitUnified) {
        await safeSendMessage(chatId, `⏳ ${playerRefHTML}, max ${limitUnified} Mines offer(s) active here. Please wait.`, { parse_mode: 'HTML' });
        return;
    }

    const offerId = generateGameId(GAME_IDS.MINES_OFFER);
    let clientBetPlacement = null;
    let totalWageredAfterBetPlacement;

    try {
        clientBetPlacement = await pool.connect();
        await clientBetPlacement.query('BEGIN');
        
        const betResult = await updateUserBalanceAndLedger(
            clientBetPlacement, userId, BigInt(-betAmountLamports),
            'bet_placed_mines_offer',
            { custom_offer_id: offerId },
            `Mines Offer creation`,
            solPrice
        );
        
        if (!betResult.success) throw new Error(betResult.error || "Failed to place bet for Mines offer.");
        
        userObj.balance = betResult.newBalanceLamports;
        totalWageredAfterBetPlacement = betResult.newTotalWageredLamports;
        if (betResult.notifications && betResult.notifications.length > 0) {
            notificationsToSend.push(...betResult.notifications);
        }

        const offerData = {
            type: GAME_IDS.MINES_OFFER, gameId: offerId, chatId: chatId,
            initiatorId: userId, initiatorMentionHTML: playerRefHTML,
            initiatorUserObj: userObj,
            betAmount: betAmountLamports, status: 'awaiting_difficulty',
            creationTime: Date.now(), offerMessageId: null, timeoutId: null,
            totalWageredForLevelCheck: totalWageredAfterBetPlacement
        };
        activeGames.set(offerId, offerData);
        await updateGroupGameDetails(chatId, offerId, offerActivityKey, betAmountLamports);
        
        await clientBetPlacement.query('COMMIT');
        
    } catch (error) {
        if (clientBetPlacement) await clientBetPlacement.query('ROLLBACK').catch(() => {});
        console.error(`${LOG_PREFIX_MINES_START} Error creating Mines offer: ${error.message}`);
        await safeSendMessage(chatId, "⚙️ Oops! Couldn't start Mines offer. Please try again.", { parse_mode: 'HTML' });
        if (offerId && activeGames.has(offerId)) {
            activeGames.delete(offerId);
            await updateGroupGameDetails(chatId, {removeThisId: offerId}, offerActivityKey, null);
        }
        return;
    } finally {
        if (clientBetPlacement) clientBetPlacement.release();
    }

    if (notificationsToSend.length > 0) {
        console.log(`${LOG_PREFIX_MINES_START} Sending ${notificationsToSend.length} queued notification(s).`);
        for (const notification of notificationsToSend) {
            safeSendMessage(notification.to, notification.message, notification.options);
        }
    }

    let difficultyButtons = [];
    for (const diffKey in MINES_DIFFICULTY_CONFIG) {
        const diffConfig = MINES_DIFFICULTY_CONFIG[diffKey];
        difficultyButtons.push({ text: `${diffConfig.emoji || '⚙️'} ${escapeHTML(diffConfig.label)}`, callback_data: `mines_difficulty_select:${offerId}:${diffKey}`});
    }
    const difficultyKeyboardRows = [];
    for (let i = 0; i < difficultyButtons.length; i += 2) difficultyKeyboardRows.push(difficultyButtons.slice(i, i + 2));
    difficultyKeyboardRows.push([{ text: "❌ Cancel Offer", callback_data: `mines_cancel_offer:${offerId}` }]);
    
    const offerMessageTextHTML = `💣 <b>Mines Challenge by ${playerRefHTML}!</b> 💣\n\n` +
        `Wager: <b>${betDisplayUSD_HTML}</b>\n\n` +
        `${playerRefHTML}, select difficulty: (Offer expires in ${UNIFIED_OFFER_TIMEOUT_MS / 1000}s, bet refunded on timeout)`;
    const sentMessage = await safeSendMessage(chatId, offerMessageTextHTML, { parse_mode: 'HTML', reply_markup: { inline_keyboard: difficultyKeyboardRows }});
    
    if (sentMessage?.message_id) {
        const currentOffer = activeGames.get(offerId);
        if (currentOffer) {
            currentOffer.offerMessageId = String(sentMessage.message_id);
            currentOffer.timeoutId = setTimeout(async () => {
                const timedOutMinesOffer = activeGames.get(offerId);
                if (timedOutMinesOffer && timedOutMinesOffer.status === 'awaiting_difficulty') {
                    activeGames.delete(offerId);
                    await updateGroupGameDetails(chatId, { removeThisId: offerId }, offerActivityKey, null);
                    let refundClientTimeout = null;
                    try {
                        refundClientTimeout = await pool.connect(); await refundClientTimeout.query('BEGIN');
                        await updateUserBalanceAndLedger(refundClientTimeout, timedOutMinesOffer.initiatorId, timedOutMinesOffer.betAmount, 'refund_mines_offer_timeout', { custom_offer_id: offerId }, `Refund for timed out Mines offer ${offerId}`);
                        await refundClientTimeout.query('COMMIT');
                    } catch (e) {
                        if(refundClientTimeout) await refundClientTimeout.query('ROLLBACK');
                        console.error(`${LOG_PREFIX_MINES_START} CRITICAL REFUND FAIL for Mines offer ${offerId}: ${e.message}`);
                    } finally {
                         if(refundClientTimeout) refundClientTimeout.release();
                    }
                    if (timedOutMinesOffer.offerMessageId && bot) {
                        await bot.editMessageText(`⏳ Mines offer by ${timedOutMinesOffer.initiatorMentionHTML} for <b>${escapeHTML(await formatBalanceForDisplay(timedOutMinesOffer.betAmount, 'USD'))}</b> expired. Bet refunded.`,
                            { chat_id: String(chatId), message_id: Number(timedOutMinesOffer.offerMessageId), parse_mode: 'HTML', reply_markup: {} }
                        ).catch(e => {});
                    }
                }
            }, UNIFIED_OFFER_TIMEOUT_MS);
        }
    } else {
        console.error(`${LOG_PREFIX_MINES_START} Failed to send Mines difficulty message AFTER transaction commit.`);
        if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL UI FAIL: Mines offer ${offerId} created, but UI message failed to send.`);
    }
}

// --- Mines Grid Generation ---
async function generateMinesGridAndData(rows, cols, numMines) {
    const logPrefix = `[GenerateMinesGridAndData ${rows}x${cols}-${numMines}m]`;

    let grid = Array(rows).fill(null).map(() =>
        Array(cols).fill(null).map(() => ({
            isMine: false,
            isRevealed: false,
            display: TILE_EMOJI_HIDDEN
        }))
    );

    let minesPlaced = 0;
    const mineLocations = [];
    if (numMines >= rows * cols) {
        numMines = Math.max(0, rows * cols - 1);
    }
    const effectiveMinMines = (typeof MINES_MIN_MINES !== 'undefined') ? MINES_MIN_MINES : 1;
    if (numMines < effectiveMinMines && rows * cols > 0) {
        numMines = Math.min(effectiveMinMines, Math.max(0, rows * cols - 1));
    }

    while (minesPlaced < numMines) {
        const r_coord = Math.floor(Math.random() * rows);
        const c_coord = Math.floor(Math.random() * cols);
        if (!grid[r_coord][c_coord].isMine) {
            grid[r_coord][c_coord].isMine = true;
            mineLocations.push([r_coord, c_coord]);
            minesPlaced++;
        }
    }
    return { grid, mineLocations };
}

function calculateMinesMultiplier(gameData, revealedGemsCount) {
    const { difficultyKey, gameId } = gameData;
    const difficultyConfig = MINES_DIFFICULTY_CONFIG[difficultyKey];

    if (!difficultyConfig || !difficultyConfig.multipliers) {
        console.error(`[MinesCalcMult GID:${gameId || 'N/A'}] Multipliers not found for difficulty ${difficultyKey}`);
        return 0.0;
    }

    if (revealedGemsCount >= 0 && revealedGemsCount < difficultyConfig.multipliers.length) {
        return difficultyConfig.multipliers[revealedGemsCount] || 0.0;
    } else if (revealedGemsCount >= difficultyConfig.multipliers.length && difficultyConfig.multipliers.length > 0) {
        return difficultyConfig.multipliers[difficultyConfig.multipliers.length - 1] || 0.0;
    }
    console.warn(`[MinesCalcMult GID:${gameId || 'N/A'}] Invalid revealedGemsCount: ${revealedGemsCount} for difficulty ${difficultyKey}. Returning 0.`);
    return 0.0;
}

async function formatAndGenerateMinesMessageComponents(gameData, isForFinalSummary = false) {
    const logPrefix = `[FormatMinesMsgComponents_V2 GID:${gameData.gameId}]`; 

    const {
        betAmount, difficultyKey, difficultyLabel, rows, cols, numMines,
        gemsFound, status, grid, gameId, playerRef,
        initiatorMentionHTML, initiatorUserObj, userId,
        currentMultiplier,
        potentialPayout,
        finalPayout, finalMultiplier
    } = gameData;

    const actualPlayerRef = playerRef || initiatorMentionHTML || escapeHTML(getPlayerDisplayReference(initiatorUserObj || {telegram_id: userId, first_name: "Player"}));

    let titleTextStr = `Mines - ${escapeHTML(difficultyLabel || 'Custom Game')}`;
    let titleEmoji = TILE_EMOJI_MINE;

    if (status === 'game_over_mine_hit') titleEmoji = TILE_EMOJI_EXPLOSION;
    else if (status === 'game_over_cashed_out' || status === 'game_over_all_gems_found') titleEmoji = '🎉';
    else if (status === 'game_over_timeout') titleEmoji = '⏱️';


    const titleText = `${titleEmoji} <b>${escapeHTML(titleTextStr)}</b> ${titleEmoji}`;

    const betDisplayHTML = escapeHTML(await formatBalanceForDisplay(betAmount, 'USD'));
    let messageTextHTML = `${titleText}\n`;
    messageTextHTML += `Player: ${actualPlayerRef}\n`;
    messageTextHTML += `Wager: <b>${betDisplayHTML}</b> | Difficulty: <b>${escapeHTML(difficultyLabel || 'N/A')}</b> (${escapeHTML(String(numMines))} ${TILE_EMOJI_MINE})\n`;

    const totalSafeTiles = (rows * cols) - numMines;
    if (status === 'player_turn' || isForFinalSummary || status === 'game_over_timeout') {
        messageTextHTML += `${TILE_EMOJI_GEM} Gems Found: <b>${escapeHTML(String(gemsFound))} / ${escapeHTML(String(totalSafeTiles))}</b>\n`;
    }

    let outcomeAndPayoutLine = "";
    if (status === 'game_over_mine_hit') {
        outcomeAndPayoutLine = `<b>Outcome:</b> You hit a mine! 😥 Bet of <b>${betDisplayHTML}</b> lost.`;
    } else if (status === 'game_over_cashed_out') {
        const finalPayoutDisplay = escapeHTML(await formatBalanceForDisplay(finalPayout || 0n, 'USD'));
        const displayMultiplierVal = finalMultiplier || currentMultiplier || 0;
        const displayMultiplier = escapeHTML(displayMultiplierVal.toFixed(2));
        outcomeAndPayoutLine = `<b>Outcome:</b> Cashed out with <b>${escapeHTML(String(gemsFound))}</b> ${TILE_EMOJI_GEM}!\nFinal Payout: <b>${finalPayoutDisplay}</b> (x${displayMultiplier})`;
    } else if (status === 'game_over_all_gems_found') {
        const finalPayoutDisplay = escapeHTML(await formatBalanceForDisplay(finalPayout || 0n, 'USD'));
        const displayMultiplierVal = finalMultiplier || currentMultiplier || 0;
        const displayMultiplier = escapeHTML(displayMultiplierVal.toFixed(2));
        outcomeAndPayoutLine = `<b>Outcome:</b> Found all <b>${escapeHTML(String(gemsFound))}</b> ${TILE_EMOJI_GEM}!\nMax Payout: <b>${finalPayoutDisplay}</b> (x${displayMultiplier})`;
    } else if (status === 'game_over_timeout') {
        outcomeAndPayoutLine = `<b>Outcome:</b> Game timed out! ⏱️ Your bet of <b>${betDisplayHTML}</b> has been forfeited.`;
    }


    if (status === 'player_turn' && !isForFinalSummary) {
        if (gemsFound > 0) {
            const currentCalcMultiplier = calculateMinesMultiplier(gameData, gemsFound);
            const currentCalcPotentialPayout = BigInt(Math.floor(Number(betAmount) * currentCalcMultiplier));
            const currentPayoutUSD = escapeHTML(await formatBalanceForDisplay(currentCalcPotentialPayout, 'USD'));
            messageTextHTML += `Current Multiplier: <b>x${escapeHTML(currentCalcMultiplier.toFixed(2))}</b>\n`;
            messageTextHTML += `Cash Out Value: <b>${currentPayoutUSD}</b>\n`;
        } else {
            messageTextHTML += `Current Payout: Find gems to increase! ✨\n`;
        }
        if (gemsFound < totalSafeTiles) {
             const nextGemCalcMultiplier = calculateMinesMultiplier(gameData, gemsFound + 1);
             const nextCalcPayout = BigInt(Math.floor(Number(betAmount) * nextGemCalcMultiplier));
             const nextPayoutUSD = escapeHTML(await formatBalanceForDisplay(nextCalcPayout, 'USD'));
             messageTextHTML += `Next ${TILE_EMOJI_GEM} Prize: <b>x${escapeHTML(nextGemCalcMultiplier.toFixed(2))}</b> (${nextPayoutUSD})\n`;
        }
    } else if ((isForFinalSummary || status === 'game_over_timeout') && outcomeAndPayoutLine) {
        messageTextHTML += `\n${outcomeAndPayoutLine}\n`;
    }

    messageTextHTML += "\n";

    if (status === 'player_turn' && !isForFinalSummary) {
        messageTextHTML += `👇 Click a tile to reveal it. Good luck! (Turn timeout: ${ACTIVE_GAME_TURN_TIMEOUT_MS / 1000}s)`;
    }

    const keyboardRows = [];
    for (let r_idx = 0; r_idx < rows; r_idx++) {
        const rowButtons = [];
        for (let c_idx = 0; c_idx < cols; c_idx++) {
            const cell = grid[r_idx][c_idx];
            let buttonText = TILE_EMOJI_HIDDEN;
            const cellIsRevealed = cell.isRevealed;

            if (status === 'player_turn' && !isForFinalSummary) {
                buttonText = cellIsRevealed ? (cell.isMine ? TILE_EMOJI_EXPLOSION : TILE_EMOJI_GEM) : TILE_EMOJI_HIDDEN;
            } else { 
                if (cellIsRevealed && cell.isMine) { buttonText = TILE_EMOJI_EXPLOSION; }
                else if (cellIsRevealed && !cell.isMine) { buttonText = TILE_EMOJI_GEM; }
                else { buttonText = cell.isMine ? TILE_EMOJI_MINE : TILE_EMOJI_GEM; } 
            }
            rowButtons.push({
                text: buttonText,
                callback_data: (status === 'player_turn' && !isForFinalSummary && !cellIsRevealed) ? `mines_tile:${gameId}:${r_idx}:${c_idx}` : `mines_noop:${gameId}:${r_idx}:${c_idx}`
            });
        }
        keyboardRows.push(rowButtons);
    }

    if (status === 'player_turn' && !isForFinalSummary) {
        if (gemsFound > 0) {
            const currentCalcMultiplier = calculateMinesMultiplier(gameData, gemsFound);
            const currentCalcPotentialPayout = BigInt(Math.floor(Number(betAmount) * currentCalcMultiplier));
            const cashOutButtonAmountDisplay = escapeHTML(await formatBalanceForDisplay(currentCalcPotentialPayout, 'USD'));
            keyboardRows.push([{ text: `💰 Cash Out (${cashOutButtonAmountDisplay})`, callback_data: `mines_cashout:${gameId}` }]);
        }
    }

    if (status === 'player_turn' && !isForFinalSummary && keyboardRows.length === rows) { 
         if (!keyboardRows.find(row => row.find(btn => btn.text === "📖 Rules"))) {
             keyboardRows.push([{ text: "📖 Rules", callback_data: `${RULES_CALLBACK_PREFIX_CONST}${GAME_IDS.MINES}`}]);
         }
    } else if (isForFinalSummary || status === 'game_over_timeout') {
        // For final summary or timeout, rules button might be added by createPostGameKeyboard if desired, not here.
    }
    return { messageTextHTML, keyboard: { inline_keyboard: keyboardRows } };
}

async function updateMinesGameMessage(gameData, deleteOldMessage = true, isFinalSummary = false) {
    const logPrefix = `[UpdateMinesMsg_V3_Timeout GID:${gameData.gameId} Fin:${isFinalSummary}]`;

    if (gameData.activityTimeoutId && !isFinalSummary && gameData.status !== 'player_turn') {
        clearTimeout(gameData.activityTimeoutId);
        gameData.activityTimeoutId = null;
        console.log(`${logPrefix} Cleared timeout as game status is no longer player_turn (Status: ${gameData.status}).`);
    } else if (gameData.activityTimeoutId && isFinalSummary) {
        clearTimeout(gameData.activityTimeoutId);
        gameData.activityTimeoutId = null;
    }

    if (deleteOldMessage && gameData.gameMessageId && bot) {
        await bot.deleteMessage(String(gameData.chatId), Number(gameData.gameMessageId)).catch(e => {});
        gameData.gameMessageId = null;
    }

    const { messageTextHTML, keyboard: gridKeyboard } = await formatAndGenerateMinesMessageComponents(gameData, isFinalSummary);
    let finalReplyMarkup = gridKeyboard;

    if (isFinalSummary) {
        const postGameActionButtons = createPostGameKeyboard(GAME_IDS.MINES, gameData.betAmount);
        finalReplyMarkup = {
            inline_keyboard: [
                ...(gridKeyboard.inline_keyboard || []), 
                ...(postGameActionButtons.inline_keyboard || []) 
            ]
        };
    }

    const messageOptions = { parse_mode: 'HTML', reply_markup: finalReplyMarkup, disable_web_page_preview: true };
    const newMsg = await safeSendMessage(String(gameData.chatId), messageTextHTML, messageOptions);

    if (newMsg?.message_id) {
        if (!isFinalSummary && gameData.status === 'player_turn') {
            gameData.gameMessageId = String(newMsg.message_id);
            if (gameData.activityTimeoutId) clearTimeout(gameData.activityTimeoutId); 
            gameData.activityTimeoutId = setTimeout(() => {
                if (typeof handleMinesGameTimeout === 'function') {
                    handleMinesGameTimeout(gameData.gameId);
                } else {
                    console.error(`[MinesTimeoutInUpdate GID:${gameData.gameId}] CRITICAL: handleMinesGameTimeout function not defined!`);
                }
            }, ACTIVE_GAME_TURN_TIMEOUT_MS); 
            console.log(`${logPrefix} New message sent (ID: ${newMsg.message_id}). Player turn timeout SET: ${gameData.activityTimeoutId}`);
        } else {
            gameData.gameMessageId = isFinalSummary ? null : String(newMsg.message_id); 
            console.log(`${logPrefix} New message sent (ID: ${newMsg.message_id}). Not player's turn or final summary, no new player turn timeout set.`);
        }
    } else {
        console.error(`${logPrefix} Failed to send new Mines game message for game ${gameData.gameId}.`);
        if (!isFinalSummary && gameData.status === 'player_turn') {
            gameData.status = 'game_over_error_ui_update';
            if (gameData.activityTimeoutId) clearTimeout(gameData.activityTimeoutId);
            if (typeof handleMinesGameTimeout === 'function') { 
                await handleMinesGameTimeout(gameData.gameId); 
            } else { 
                activeGames.delete(gameData.gameId);
                await updateGroupGameDetails(String(gameData.chatId), { removeThisId: gameData.gameId }, GAME_IDS.MINES, null);
            }
        }
    }

    if (activeGames.has(gameData.gameId)) { 
        activeGames.set(gameData.gameId, gameData);
    }
}

async function handleMinesDifficultySelectionCallback(offerId, userWhoClicked, difficultyKey, callbackQueryId, originalMessageId, originalChatId, originalChatType) {
    const clickerId = String(userWhoClicked.telegram_id || userWhoClicked.id);
    const logPrefix = `[MinesDiffSelect_V4_GranLimit UID:${clickerId} OfferID:${offerId} Diff:${difficultyKey}]`; 
    const offerData = activeGames.get(offerId);

    const activeUserGameCheck = await checkUserActiveGameLimit(clickerId, false, offerId); 
    if (activeUserGameCheck.limitReached) {
        const userDisplayName = escapeHTML(getPlayerDisplayReference(userWhoClicked));
        const blockingGameType = activeUserGameCheck.details.type;
        const cleanGameName = getCleanGameName(blockingGameType);
        let alertMessage = `✨ ${userDisplayName}, you're already in a game of ${escapeHTML(cleanGameName)}. ✨ Finish it first!`;
        alertMessage = alertMessage.substring(0, 200);

        await bot.answerCallbackQuery(callbackQueryId, { text: alertMessage, show_alert: true }).catch(() => {});
        return;
    }

    if (!offerData || offerData.type !== GAME_IDS.MINES_OFFER || offerData.status !== 'awaiting_difficulty') {
        await bot.answerCallbackQuery(callbackQueryId, { text: "This Mines offer is no longer valid or already actioned.", show_alert: true });
        const msgIdToClearButtons = offerData?.offerMessageId || originalMessageId;
        if (msgIdToClearButtons && bot) {
            bot.editMessageReplyMarkup({}, { chat_id: originalChatId, message_id: Number(msgIdToClearButtons) }).catch(() => {});
        }
        return;
    }
    if (String(offerData.initiatorId) !== clickerId) {
        await bot.answerCallbackQuery(callbackQueryId, { text: "Only the player who started the offer can select the difficulty.", show_alert: true });
        return;
    }

    const difficultyConfig = MINES_DIFFICULTY_CONFIG[difficultyKey];
    if (!difficultyConfig) {
        await bot.answerCallbackQuery(callbackQueryId, { text: "Invalid difficulty selected. Please try again.", show_alert: true });
        console.error(`${logPrefix} Invalid difficulty key: ${difficultyKey}`);
        return;
    }

    const gameSession = await getGroupSession(originalChatId);
    const activeGameKeyForNewGame = GAME_IDS.MINES; 
    const currentActiveMinesGames = gameSession.activeGamesByTypeInGroup.get(activeGameKeyForNewGame) || [];
    const limitActive = GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[activeGameKeyForNewGame] || 1;

    if (currentActiveMinesGames.length >= limitActive) {
        await bot.answerCallbackQuery(callbackQueryId, { text: `Max ${limitActive} active Mines game(s) allowed in this group. Please wait.`, show_alert: true });
        return;
    }

    if (offerData.timeoutId) {
        clearTimeout(offerData.timeoutId);
        offerData.timeoutId = null;
    }

    let client = null;
    let actualGameId; 
    try {
        client = await pool.connect();
        await client.query('BEGIN');
        
        const currentUserForBet = await getOrCreateUser(clickerId, null, null, null, client); 
        if (!currentUserForBet) throw new Error("Could not verify user for starting Mines game.");
        // The bet was already secured in handleStartMinesCommand, and balance updated there.
        // This check is more of a sanity check for extreme balance changes post-offer.
        if (BigInt(currentUserForBet.balance) < 0n && (BigInt(currentUserForBet.balance) + offerData.betAmount < 0n) ) { 
             throw new Error("User balance issue prevents starting game. Bet was already deducted for offer.");
        }
        
        await bot.answerCallbackQuery(callbackQueryId, { text: `Selected ${difficultyConfig.label}. Starting game...`}).catch(()=>{});

        actualGameId = generateGameId(GAME_IDS.MINES);
        const { grid, mineLocations } = await generateMinesGridAndData(difficultyConfig.rows, difficultyConfig.cols, difficultyConfig.mines);
        const initialMultiplier = MINES_DIFFICULTY_CONFIG[difficultyKey].multipliers[0] || 0;
        const initialPotentialPayout = BigInt(Math.floor(Number(offerData.betAmount) * initialMultiplier));

        const gameData = {
            type: GAME_IDS.MINES, gameId: actualGameId, chatId: offerData.chatId,
            userId: clickerId, playerRef: offerData.initiatorMentionHTML,
            initiatorId: clickerId, initiatorMentionHTML: offerData.initiatorMentionHTML,
            initiatorUserObj: currentUserForBet, betAmount: offerData.betAmount,
            rows: difficultyConfig.rows, cols: difficultyConfig.cols, numMines: difficultyConfig.mines,
            difficultyKey: difficultyKey, difficultyLabel: difficultyConfig.label,
            grid: grid, mineLocations: mineLocations,
            gemsFound: 0, currentMultiplier: initialMultiplier, potentialPayout: initialPotentialPayout,
            status: 'player_turn', gameMessageId: offerData.offerMessageId, 
            lastInteractionTime: Date.now(), activityTimeoutId: null,
            totalWageredForLevelCheck: offerData.totalWageredForLevelCheck // *** COPY FROM OFFER DATA ***
        };

        activeGames.set(actualGameId, gameData);
        activeGames.delete(offerId); 

        await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.MINES_OFFER, null);
        await updateGroupGameDetails(originalChatId, actualGameId, activeGameKeyForNewGame, offerData.betAmount);
        console.log(`${logPrefix} Mines game ${actualGameId} started from offer ${offerId}. Group lock for ${activeGameKeyForNewGame} added, offer lock for ${GAME_IDS.MINES_OFFER} removed.`);

        await client.query('COMMIT'); 
        await updateMinesGameMessage(gameData, true, false); 

    } catch (error) {
        if (client) await client.query('ROLLBACK').catch(() => {});
        console.error(`${logPrefix} Error starting Mines game after difficulty selection: ${error.message}`);
        await bot.answerCallbackQuery(callbackQueryId, { text: `Error starting Mines: ${error.message.substring(0,100)}`, show_alert: true }).catch(()=>{});
        
        // Since the bet was taken when the offer was created, if starting the game fails here,
        // the bet needs to be refunded.
        let refundClientError = null;
        try {
            refundClientError = await pool.connect(); await refundClientError.query('BEGIN');
            await updateUserBalanceAndLedger(refundClientError, clickerId, offerData.betAmount, 'refund_mines_offer_game_start_fail', {custom_offer_id: offerId}, `Mines offer ${offerId} game start fail: ${error.message.substring(0,100)}`);
            await refundClientError.query('COMMIT');
        } catch (e) { 
            if(refundClientError) await refundClientError.query('ROLLBACK'); 
            console.error(`${logPrefix} REFUND FAILURE for Mines offer ${offerId} after game start error: ${e.message}`); 
            if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL REFUND FAIL: Mines Offer ${offerId}, User ${clickerId}, Error: ${e.message}`);
        }
        finally { if(refundClientError) refundClientError.release(); }

        activeGames.delete(offerId);
        if (actualGameId) activeGames.delete(actualGameId);
        await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.MINES_OFFER, null); 
        if (actualGameId) await updateGroupGameDetails(originalChatId, { removeThisId: actualGameId }, GAME_IDS.MINES, null); 
    } finally {
        if (client) client.release();
    }
}

// CORRECTED handleMinesTileClickCallback (Full Version)
async function handleMinesTileClickCallback(gameId, userWhoClicked, r_str, c_str, callbackQueryId, originalMessageId, originalChatId) {
    const userId = String(userWhoClicked.telegram_id || userWhoClicked.id);
    const r = parseInt(r_str, 10);
    const c = parseInt(c_str, 10);
    const logPrefix = `[MinesTileClick_V5_Fix GID:${gameId} UID:${userId} Tile:${r},${c}]`;
    let allNotificationsToSend = [];

    let solPrice;
    try {
        solPrice = await getSolUsdPrice();
    } catch (priceError) {
        console.error(`${logPrefix} CRITICAL: Could not get SOL price. Level-up/milestone checks will be skipped. Error: ${priceError.message}`);
        solPrice = 0;
    }

    let gameData = activeGames.get(gameId);

    if (!gameData || gameData.type !== GAME_IDS.MINES || gameData.userId !== userId || gameData.status !== 'player_turn' ||
        isNaN(r) || isNaN(c) || r < 0 || r >= gameData.rows || c < 0 || c >= gameData.cols || gameData.grid[r][c].isRevealed) {
        await bot.answerCallbackQuery(callbackQueryId, { text: "Invalid action or tile.", show_alert: true }).catch(()=>{});
        return;
    }

    if (gameData.activityTimeoutId) { 
        clearTimeout(gameData.activityTimeoutId);
        gameData.activityTimeoutId = null;
    }

    const cell = gameData.grid[r][c];
    cell.isRevealed = true;
    gameData.lastInteractionTime = Date.now();
    let statusMessageForAnswerCallback = '';
    let gameOver = false;
    let client = null; 
    let balanceUpdateSucceeded = false;

    if (cell.isMine) {
        gameData.status = 'game_over_mine_hit';
        statusMessageForAnswerCallback = `${TILE_EMOJI_EXPLOSION} BOOM! Mine!`;
        gameOver = true; gameData.finalPayout = 0n; gameData.finalMultiplier = 0;
        gameData.mineLocations.forEach(([mr_loc, mc_loc]) => { if (gameData.grid[mr_loc]?.[mc_loc]) gameData.grid[mr_loc][mc_loc].isRevealed = true; });
        try {
            client = await pool.connect(); await client.query('BEGIN');
            const lossUpdateResult = await updateUserBalanceAndLedger(client, userId, 0n, 'loss_mines_hit', { game_id_custom_field: gameId, difficulty: gameData.difficultyKey, gems_found: gameData.gemsFound, original_bet_amount: gameData.betAmount.toString() }, `Mines: Hit mine. Bet lost.`, solPrice);
            if (lossUpdateResult.success) {
                balanceUpdateSucceeded = true;
                if(lossUpdateResult.notifications) allNotificationsToSend.push(...lossUpdateResult.notifications);
                
                if (gameData.totalWageredForLevelCheck !== undefined) {
                    const levelNotifications = await checkAndUpdateUserLevel(client, userId, gameData.totalWageredForLevelCheck, solPrice, originalChatId);
                    allNotificationsToSend.push(...levelNotifications);
                    const milestoneResult = await processWagerMilestoneBonus(client, userId, gameData.totalWageredForLevelCheck, solPrice);
                    if (!milestoneResult.success) {
                        console.warn(`${logPrefix} Failed to process milestone bonus on mine hit: ${milestoneResult.error}`);
                    }
                }
                await client.query('COMMIT');
            } else {
                await client.query('ROLLBACK');
                throw new Error(lossUpdateResult.error || "DB Error logging mine hit loss.");
            }
        } catch (e) { 
            if (client && !balanceUpdateSucceeded) await client.query('ROLLBACK').catch(()=>{});
            statusMessageForAnswerCallback += " (DB Log Error)"; 
            console.error(`${logPrefix} DB Error logging mine hit: ${e.message}`);
        }
        finally { if (client) client.release(); }
    } else {
        gameData.gemsFound++;
        gameData.currentMultiplier = calculateMinesMultiplier(gameData, gameData.gemsFound);
        gameData.potentialPayout = BigInt(Math.floor(Number(gameData.betAmount) * gameData.currentMultiplier));
        statusMessageForAnswerCallback = `${TILE_EMOJI_GEM} Gem! x${gameData.currentMultiplier.toFixed(2)}`;
        const totalNonMineCells = (gameData.rows * gameData.cols) - gameData.numMines;
        if (gameData.gemsFound >= totalNonMineCells) {
            gameData.status = 'game_over_all_gems_found';
            gameData.finalPayout = gameData.potentialPayout; gameData.finalMultiplier = gameData.currentMultiplier;
            gameOver = true;
            try {
                client = await pool.connect(); await client.query('BEGIN');
                const winUpdateResult = await updateUserBalanceAndLedger(client, userId, gameData.finalPayout, 'win_mines_all_gems', { game_id_custom_field: gameId, difficulty: gameData.difficultyKey, payout_multiplier_custom: gameData.finalMultiplier.toFixed(4), original_bet_amount: gameData.betAmount.toString() }, `Mines max win.`, solPrice);
                if (winUpdateResult.success) {
                    balanceUpdateSucceeded = true;
                    if(winUpdateResult.notifications) allNotificationsToSend.push(...winUpdateResult.notifications);

                    if (gameData.totalWageredForLevelCheck !== undefined) {
                        const levelNotifications = await checkAndUpdateUserLevel(client, userId, gameData.totalWageredForLevelCheck, solPrice, originalChatId);
                        allNotificationsToSend.push(...levelNotifications);
                        const milestoneResult = await processWagerMilestoneBonus(client, userId, gameData.totalWageredForLevelCheck, solPrice);
                        if (!milestoneResult.success) {
                            console.warn(`${logPrefix} Failed to process milestone bonus on all-gems-found win: ${milestoneResult.error}`);
                        }
                    }
                    await client.query('COMMIT');
                } else {
                    await client.query('ROLLBACK');
                    throw new Error(winUpdateResult.error || "DB Error logging all gems found win.");
                }
            } catch (dbError) { 
                if (client && !balanceUpdateSucceeded) await client.query('ROLLBACK').catch(()=>{}); 
                statusMessageForAnswerCallback = "Error processing max win payout."; 
                console.error(`${logPrefix} DB Error logging all gems found: ${dbError.message}`);
            }
            finally { if (client) client.release(); }
        }
    }

    if(activeGames.has(gameId)) activeGames.set(gameId, gameData); 
    const cbAnswerText = statusMessageForAnswerCallback.substring(0,190);
    await bot.answerCallbackQuery(callbackQueryId, {text: cbAnswerText }).catch(() => {});
    
    if (gameOver) {
        for (const notification of allNotificationsToSend) {
            if (notification.to === ADMIN_USER_ID && typeof notifyAdmin === 'function') {
                await notifyAdmin(notification.text, notification.options).catch(err => console.error(`Failed to send admin notification: ${err.message}`));
            } else {
                await safeSendMessage(notification.to, notification.text, notification.options).catch(err => console.error(`Failed to send game-related notification to ${notification.to}: ${err.message}`));
            }
        }
    }

    await updateMinesGameMessage(gameData, true, gameOver); 

    if (gameOver) {
        activeGames.delete(gameId);
        await updateGroupGameDetails(originalChatId, { removeThisId: gameId }, GAME_IDS.MINES, null); 
        console.log(`${logPrefix} Game ${gameId} ended (mine hit or all gems). Lock for ${GAME_IDS.MINES} cleared.`);
    }
}

// CORRECTED handleMinesCashOutCallback (Full Version with Referral Fixes)
async function handleMinesCashOutCallback(gameId, userObject, callbackQueryId, originalMessageId, originalChatId) {
    const userId = String(userObject.telegram_id || userObject.id);
    const logPrefix = `[MinesCashOut_V3_FullFix GID:${gameId} UID:${userId}]`;

    const gameData = activeGames.get(gameId);

    if (!gameData || gameData.type !== GAME_IDS.MINES || gameData.userId !== userId || gameData.status !== 'player_turn') {
        await bot.answerCallbackQuery(callbackQueryId, { text: "Invalid action or game state.", show_alert: true }).catch(() => {});
        return;
    }
    if (gameData.gemsFound === 0) {
        await bot.answerCallbackQuery(callbackQueryId, { text: "Find at least one gem before cashing out!", show_alert: true }).catch(() => {});
        return;
    }

    if (gameData.activityTimeoutId) {
        clearTimeout(gameData.activityTimeoutId);
        gameData.activityTimeoutId = null;
    }

    await bot.answerCallbackQuery(callbackQueryId, { text: "Cashing out..." }).catch(() => {});

    gameData.status = 'game_over_cashed_out';
    gameData.currentMultiplier = calculateMinesMultiplier(gameData, gameData.gemsFound);
    gameData.finalPayout = BigInt(Math.floor(Number(gameData.betAmount) * gameData.currentMultiplier));
    gameData.finalMultiplier = gameData.currentMultiplier;
    gameData.lastInteractionTime = Date.now();
    for (let r = 0; r < gameData.rows; r++) {
        for (let c = 0; c < gameData.cols; c++) {
            gameData.grid[r][c].isRevealed = true;
        }
    }

    let client = null;
    let balanceUpdateSucceeded = false;
    let allNotificationsToSend = [];
    
    let solPrice;
    try {
        solPrice = await getSolUsdPrice();
    } catch (priceError) {
        console.error(`${logPrefix} CRITICAL: Could not get SOL price. Bonus checks will be skipped. Error: ${priceError.message}`);
        solPrice = 0;
    }

    try {
        client = await pool.connect();
        await client.query('BEGIN');
        const cashoutResult = await updateUserBalanceAndLedger(client, userId, gameData.finalPayout, 'win_mines_cashout', { game_id_custom_field: gameId, difficulty_custom: gameData.difficultyKey, gems_custom: gameData.gemsFound, payout_multiplier_custom: gameData.finalMultiplier.toFixed(4), original_bet_amount: gameData.betAmount.toString() }, `Mines cash out.`, solPrice);
        if (!cashoutResult.success) {
            throw new Error(cashoutResult.error || "Failed to update balance on cash out.");
        }
        balanceUpdateSucceeded = true;
        if (cashoutResult.notifications) allNotificationsToSend.push(...cashoutResult.notifications);

        if (gameData.totalWageredForLevelCheck !== undefined) {
            // --- START OF MODIFICATION ---

            // 1. ADDED: Check for the initial bet bonus.
            if (typeof processQualifyingBetAndInitialBonus === 'function') {
                const initialBonusResult = await processQualifyingBetAndInitialBonus(client, userId, gameData.betAmount, gameId);
                if (initialBonusResult.jobQueued) {
                    console.log(`[ReferralCheck] Queued initial bet bonus job for user ${userId} from game ${gameId}.`);
                }
            }

            // 2. MODIFIED: Correctly call level and milestone checks.
            const levelNotifications = await checkAndUpdateUserLevel(client, userId, gameData.totalWageredForLevelCheck, solPrice, originalChatId);
            allNotificationsToSend.push(...levelNotifications);
            const milestoneResult = await processWagerMilestoneBonus(client, userId, gameData.totalWageredForLevelCheck, solPrice);
            if (!milestoneResult.success) {
                console.warn(`${logPrefix} Failed to process milestone bonus on cashout: ${milestoneResult.error}`);
            }

            // --- END OF MODIFICATION ---
        }

        await client.query('COMMIT');
    } catch (dbError) {
        // **FIX APPLIED HERE**: The client.release() call has been removed from the catch block.
        if (client && !balanceUpdateSucceeded) await client.query('ROLLBACK').catch(() => {});
        console.error(`${logPrefix} DB Error processing Mines cash out: ${dbError.message}`);
        await safeSendMessage(userId, "⚙️ Error processing cash out (DB). Contact support.", { parse_mode: 'HTML' });
        if (typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL MINES CASHOUT DB Error GID: ${gameId}. Manual check needed.`);

        gameData.status = 'game_over_error_payout';
        if (activeGames.has(gameId)) activeGames.set(gameId, gameData);
        await updateMinesGameMessage(gameData, true, true);
        activeGames.delete(gameId);
        await updateGroupGameDetails(originalChatId, { removeThisId: gameId }, GAME_IDS.MINES, null);
        return;
    } finally {
        // **FIX APPLIED HERE**: This is now the ONLY place client.release() is called.
        if (client) client.release();
    }

    for (const notification of allNotificationsToSend) {
        if (notification.to === ADMIN_USER_ID && typeof notifyAdmin === 'function') {
            await notifyAdmin(notification.text, notification.options).catch(err => console.error(`Failed to send admin notification: ${err.message}`));
        } else {
            await safeSendMessage(notification.to, notification.text, notification.options).catch(err => console.error(`Failed to send game-related notification to ${notification.to}: ${err.message}`));
        }
    }

    if (activeGames.has(gameId)) activeGames.set(gameId, gameData);
    await updateMinesGameMessage(gameData, true, true);
    activeGames.delete(gameId);
    await updateGroupGameDetails(originalChatId, { removeThisId: gameId }, GAME_IDS.MINES, null);
    console.log(`${logPrefix} Game ${gameId} cashed out. Lock for ${GAME_IDS.MINES} cleared.`);
}

async function handleMinesCancelOfferCallback(offerId, userWhoClicked, originalMessageId, originalChatId, callbackQueryId) {
    const clickerId = String(userWhoClicked.telegram_id || userWhoClicked.id);
    const logPrefix = `[MinesCancelOffer_V2_Refund UID:${clickerId} OfferID:${offerId}]`;
    const offerData = activeGames.get(offerId);

    if (!offerData || offerData.type !== GAME_IDS.MINES_OFFER || offerData.status !== 'awaiting_difficulty') {
        await bot.answerCallbackQuery(callbackQueryId, { text: "Offer no longer valid.", show_alert: true });
        return;
    }
    if (offerData.initiatorId !== clickerId) {
        await bot.answerCallbackQuery(callbackQueryId, { text: "Only initiator can cancel.", show_alert: true });
        return;
    }

    if (offerData.timeoutId) {
        clearTimeout(offerData.timeoutId);
        offerData.timeoutId = null; 
    }

    await bot.answerCallbackQuery(callbackQueryId, { text: "Mines offer cancelled. Refunding bet..." });
    activeGames.delete(offerId);
    // Use MINES_OFFER key for pending offer list
    await updateGroupGameDetails(originalChatId, { removeThisId: offerId }, GAME_IDS.MINES_OFFER, null); 

    let refundClient = null;
    try {
        refundClient = await pool.connect(); await refundClient.query('BEGIN');
        await updateUserBalanceAndLedger(refundClient, offerData.initiatorId, offerData.betAmount, 'refund_mines_offer_cancelled', {custom_offer_id: offerId}, `Refund for cancelled Mines offer ${offerId}`);
        await refundClient.query('COMMIT');
    } catch (e) {
        if(refundClient) await refundClient.query('ROLLBACK');
        console.error(`${logPrefix} CRITICAL REFUND FAILURE for Mines offer ${offerId}: ${e.message}`);
        if(typeof notifyAdmin === 'function') notifyAdmin(`CRITICAL MINES OFFER REFUND FAIL: Offer ${offerId}, User ${offerData.initiatorId}. Err: ${e.message}`);
    } finally { if(refundClient) refundClient.release(); }

    const betDisplayHTML = escapeHTML(await formatBalanceForDisplay(offerData.betAmount, 'USD'));
    const messageTextHTML = `💣 Offer by ${offerData.initiatorMentionHTML} for <b>${betDisplayHTML}</b> (Mines) has been cancelled. Bet refunded.`;

    if (originalMessageId && bot) {
        await bot.deleteMessage(String(originalChatId), Number(originalMessageId)).catch(e => {});
    }
    await safeSendMessage(String(originalChatId), messageTextHTML, { parse_mode: 'HTML' });
}

// CORRECTED handleMinesGameTimeout (Full Version)
async function handleMinesGameTimeout(gameId) {
    const logPrefix = `[MinesGameTimeout_V3_DeadlockFix GID:${gameId}]`;
    let allNotificationsToSend = [];

    let solPrice;
    try {
        solPrice = await getSolUsdPrice();
    } catch (priceError) {
        console.error(`${logPrefix} CRITICAL: Could not get SOL price. Level-up/milestone checks will be skipped. Error: ${priceError.message}`);
        solPrice = 0;
    }

    const gameData = activeGames.get(gameId);

    if (!gameData || gameData.type !== GAME_IDS.MINES || gameData.status !== 'player_turn') {
        if (gameData && gameData.activityTimeoutId) clearTimeout(gameData.activityTimeoutId);
        return;
    }
    console.log(`${logPrefix} Player ${gameData.userId} timed out in Mines. Bet forfeited.`);

    if (gameData.activityTimeoutId) clearTimeout(gameData.activityTimeoutId);
    gameData.activityTimeoutId = null;

    gameData.status = 'game_over_timeout';
    gameData.finalPayout = 0n; gameData.finalMultiplier = 0; 
    gameData.lastInteractionTime = Date.now();
    for (let r=0; r<gameData.rows; r++) {
        for (let c=0; c<gameData.cols; c++) {
            gameData.grid[r][c].isRevealed = true; 
        }
    }
    activeGames.set(gameId, gameData); 

    let client = null;
    let balanceUpdateSucceeded = false;
    try {
        client = await pool.connect(); await client.query('BEGIN');
        const forfeitUpdateResult = await updateUserBalanceAndLedger(client, gameData.userId, 0n, 'loss_mines_timeout_forfeit', { game_id_custom_field: gameId, difficulty: gameData.difficultyKey, gems_found: gameData.gemsFound, original_bet_amount: gameData.betAmount.toString() }, `Mines game forfeited (timeout). Bet lost.`, solPrice);
        if (forfeitUpdateResult.success) {
            balanceUpdateSucceeded = true;
            if (forfeitUpdateResult.notifications) allNotificationsToSend.push(...forfeitUpdateResult.notifications);

            if (gameData.totalWageredForLevelCheck !== undefined) {
                const levelNotifications = await checkAndUpdateUserLevel(client, gameData.userId, gameData.totalWageredForLevelCheck, solPrice, gameData.chatId);
                allNotificationsToSend.push(...levelNotifications);
                const milestoneNotifications = await processWagerMilestoneBonus(client, gameData.userId, gameData.totalWageredForLevelCheck, solPrice);
                allNotificationsToSend.push(...milestoneNotifications);
            }
            
            await client.query('COMMIT');
        } else {
            await client.query('ROLLBACK');
            throw new Error(forfeitUpdateResult.error || "DB Error logging Mines timeout forfeit.");
        }
    } catch (dbError) {
        if (client && !balanceUpdateSucceeded) await client.query('ROLLBACK').catch(()=>{});
        console.error(`${logPrefix} DB Error logging Mines timeout forfeit: ${dbError.message}`);
        if(typeof notifyAdmin === 'function') notifyAdmin(`🚨 Mines Game Timeout DB Error 🚨\nGID: ${gameId}, User: ${gameData.userId}\nError: ${escapeMarkdownV2(dbError.message)}`, {parse_mode: 'MarkdownV2'});
    } finally { if (client) client.release(); }

    // Send all collected notifications AFTER the transaction is closed
    for (const notification of allNotificationsToSend) {
        if (notification.to === ADMIN_USER_ID && typeof notifyAdmin === 'function') {
            await notifyAdmin(notification.text, notification.options).catch(err => console.error(`Failed to send admin notification: ${err.message}`));
        } else {
            await safeSendMessage(notification.to, notification.text, notification.options).catch(err => console.error(`Failed to send game-related notification to ${notification.to}: ${err.message}`));
        }
    }

    await updateMinesGameMessage(gameData, true, true); 

    activeGames.delete(gameId);
    await updateGroupGameDetails(String(gameData.chatId), { removeThisId: gameId }, GAME_IDS.MINES, null);
    console.log(`${logPrefix} Game ${gameId} processed for timeout, removed from active games, lock for ${GAME_IDS.MINES} cleared.`);
}

// --- End of Part 5d (Mines Game - GRANULAR ACTIVE GAME LIMITS) ---
// --- Start of Part 5e (Background task Initializers) ---

function startJackpotSessionPolling() {
    // Using JACKPOT_SESSION_POLL_INTERVAL_MS defined in Part 1
    let intervalMs = JACKPOT_SESSION_POLL_INTERVAL_MS;
    // The validation for JACKPOT_SESSION_POLL_INTERVAL_MS being a sensible number
    // should have already happened in Part 1 when it was defined.
    // If it was fatal there, the script would have exited.
    // If it was a warning + fallback, intervalMs will have that fallback.

    if (jackpotSessionPollIntervalId) {
        clearInterval(jackpotSessionPollIntervalId);
        console.log("🔄 [JackpotSessionPoll_Start] Cleared existing jackpot session poller interval (if any).");
    }
    console.log(`⚙️ [JackpotSessionPoll_Start] Initializing Jackpot Session Poller (Interval: ${intervalMs / 1000}s)...`);

    // Ensure the isRunning property is initialized on the poller function itself
    if (typeof pollCompletedJackpotSessions.isRunning === 'undefined') {
        pollCompletedJackpotSessions.isRunning = false;
    }

    // Initial delay for the first run
    const initialPollDelay = (parseInt(process.env.INIT_DELAY_MS, 10) || 7000) + 5000; // Stagger start

    setTimeout(() => {
        if (isShuttingDown) {
            console.log("[JackpotSessionPoll_Start] Shutdown initiated before first poll. Not starting poller.");
            return;
        }

        console.log("[JackpotSessionPoll_Start] Executing initial jackpot session poll...");
        pollCompletedJackpotSessions().catch(err => {
            console.error("❌ [Initial Jackpot Session Poll Run] Uncaught Error:", err.message, err.stack?.substring(0, 500));
            if (typeof notifyAdmin === 'function' && typeof escapeMarkdownV2 === 'function') {
                notifyAdmin(`🚨 Initial Jackpot Poll Error: ${escapeMarkdownV2(String(err.message || err))}`, {parse_mode:'MarkdownV2'});
            }
        });

        jackpotSessionPollIntervalId = setInterval(() => {
            if (isShuttingDown) {
                clearInterval(jackpotSessionPollIntervalId);
                console.log("[JackpotSessionPoll_Start] Shutdown detected. Stopping recurring jackpot poll.");
                return;
            }
            pollCompletedJackpotSessions().catch(err => {
                console.error("❌ [Recurring Jackpot Session Poll Run] Uncaught Error:", err.message, err.stack?.substring(0, 500));
                if (typeof notifyAdmin === 'function' && typeof escapeMarkdownV2 === 'function') {
                    notifyAdmin(`🚨 Recurring Jackpot Poll Error: ${escapeMarkdownV2(String(err.message || err))}`, {parse_mode:'MarkdownV2'});
                }
            });
        }, intervalMs);

        if (jackpotSessionPollIntervalId && typeof jackpotSessionPollIntervalId.unref === 'function') {
            jackpotSessionPollIntervalId.unref();
        }
        console.log(`✅ [JackpotSessionPoll_Start] Jackpot Session Poller is now active and scheduled.`);

    }, initialPollDelay);
}
// --- End of 5e Background Task Initializers ---
// --- Start of Part 5a, Section 2 (CORRECTED - BOT_NAME & _CONST usage - General Command Handler Implementations, with NEW handleClaimLevelBonus) ---
// index.js - Part 5a, Section 2: General Casino Bot Command Implementations
//----------------------------------------------------------------------------------
// Assumed dependencies from previous Parts:
// Part 1: safeSendMessage, escapeMarkdownV2, escapeHTML, bot, BOT_NAME, BOT_VERSION, ADMIN_USER_ID, pool,
//         MIN_BET_USD_val, MAX_BET_USD_val, TARGET_JACKPOT_SCORE_CONST, TARGET_JACKPOT_SCORE, // Added TARGET_JACKPOT_SCORE
//         MAIN_JACKPOT_ID, GAME_IDS, LEVEL_CONFIG, // Added LEVEL_CONFIG for handleClaimLevelBonus
//         RULES_CALLBACK_PREFIX_CONST, QUICK_DEPOSIT_CALLBACK_ACTION_CONST, WITHDRAW_CALLBACK_ACTION_CONST, LAMPORTS_PER_SOL,
//         getSolUsdPrice, convertUSDToLamports, convertLamportsToUSDString, userStateCache
// Part 2: getOrCreateUser, getUserBalance, queryDatabase, getUserByReferralCode, generateReferralCode, findRecipientUser
// Part 3: getPlayerDisplayReference, formatCurrency, formatBalanceForDisplay
// Part P2: updateUserBalanceAndLedger (for handleClaimLevelBonus)
// Part P3: clearUserState, handleMenuAction, handleWithdrawalConfirmation
// (Other game-specific constants like LADDER_PAYOUTS, SLOT_PAYOUTS, etc., are assumed to be available from Part 1 if used directly here)

// --- Command Handler Functions (General Casino Bot Commands) ---

// CORRECTED handleStartCommand with Referral Logging
async function handleStartCommand(msg, args) {
    const userId = String(msg.from.id || msg.from.telegram_id);
    const chatId = String(msg.chat.id);
    const chatType = msg.chat.type;
    const LOG_PREFIX_START = `[StartCmd_V5_RefDebug UID:${userId} CH:${chatId}]`;

    console.log(`${LOG_PREFIX_START} /start command received. ChatType: ${chatType}, Args: ${args.join(', ')}`);

    let referrerId = null;
    let deepLinkParam = null;

    if (args && args[0]) {
        deepLinkParam = args[0];
        if (deepLinkParam.startsWith('ref_')) {
            const refCode = deepLinkParam.substring(4);
            console.log(`${LOG_PREFIX_START} Found referral deep link with code: ${refCode}`);
            const referrerUserRecord = await getUserByReferralCode(refCode);
            if (referrerUserRecord && String(referrerUserRecord.telegram_id) !== userId) {
                referrerId = referrerUserRecord.telegram_id;
                console.log(`${LOG_PREFIX_START} Successfully identified referrer ID: ${referrerId} from code ${refCode}.`);
            } else if (!referrerUserRecord) {
                console.warn(`${LOG_PREFIX_START} The referral code ${refCode} did NOT match any user.`);
            } else {
                 console.warn(`${LOG_PREFIX_START} User tried to use their own referral code.`);
            }
        }
    }
    
    // getOrCreateUser will now handle creating the user AND linking the referrer atomically.
    console.log(`${LOG_PREFIX_START} Calling getOrCreateUser for new user ${userId} with referrerId: ${referrerId}`);
    let userObject = await getOrCreateUser(userId, msg.from.username, msg.from.first_name, msg.from.last_name, referrerId);

    if (!userObject) {
        await safeSendMessage(chatId, "😕 Error fetching your player profile. Please try typing <code>/start</code> again.", { parse_mode: 'HTML' });
        return;
    }

    const playerRefHTML = escapeHTML(getPlayerDisplayReference(userObject));
    let botUsernameToUse = BOT_NAME || "our bot";
    try {
        const selfInfo = await bot.getMe();
        if (selfInfo.username) botUsernameToUse = selfInfo.username;
    } catch (e) { console.error(`${LOG_PREFIX_START} Could not fetch bot username: ${e.message}`); }
    const botUsernameHTML = escapeHTML(botUsernameToUse);
    
    if (deepLinkParam && deepLinkParam.startsWith('ref_')) {
        const refByDisplayHTML = userObject.referrer_telegram_id ? escapeHTML(getPlayerDisplayReference(await getOrCreateUser(userObject.referrer_telegram_id))) : "a fellow player";
        const referralMsgHTML = `👋 Welcome, ${playerRefHTML}! You started via a link from ${refByDisplayHTML}.\nExplore the casino using the menu I've just displayed!`;
        if (chatType !== 'private') {
            if (msg.message_id) await bot.deleteMessage(chatId, msg.message_id).catch(()=>{});
            await safeSendMessage(chatId, `${playerRefHTML}, welcome! I've sent the main menu to our private chat: @${botUsernameHTML} 📬`, { parse_mode: 'HTML' });
        }
        await safeSendMessage(userId, referralMsgHTML, { parse_mode: 'HTML' });
        const mainChatLink = process.env.MAIN_CHAT_INVITE_LINK;
        if (mainChatLink) {
            const joinGroupText = `🚀 Ready for the full experience? Jump into our main chat to play with others, see live action, and join the community!`;
            const joinGroupKeyboard = { inline_keyboard: [[{ text: "💬 Join the Main Chat!", url: mainChatLink }]] };
            await safeSendMessage(userId, joinGroupText, { parse_mode: 'HTML', reply_markup: joinGroupKeyboard });
        }
        const dmMsgContext = { from: userObject, chat: { id: userId, type: 'private' }, message_id: null, isCallbackEditing: false };
        await handleHelpCommand(dmMsgContext);
        return;
    }
    
    // ... (rest of the handleStartCommand function remains the same)
    if (deepLinkParam && (deepLinkParam.startsWith('cb_') || deepLinkParam.startsWith('menu_'))) {
        const prefixLength = deepLinkParam.startsWith('cb_') ? 3 : 5;
        const fullActionString = deepLinkParam.substring(prefixLength); 
        if (chatType !== 'private' && msg.message_id) await bot.deleteMessage(chatId, msg.message_id).catch(()=>{});
        const userGuidanceTextHTML = `👋 Welcome back, ${playerRefHTML}!\nTaking you to the requested section.`;
        await safeSendMessage(userId, userGuidanceTextHTML, {parse_mode: 'HTML'});
        if (typeof handleMenuAction === 'function') {
            await handleMenuAction(userId, userId, null, fullActionString, [], false, 'private', msg);
        } else {
            const dmMsgContext = { from: userObject, chat: { id: userId, type: 'private' }, message_id: null, isCallbackEditing: false };
            await handleHelpCommand(dmMsgContext);
        }
        return;
    }

    if (typeof clearUserState === 'function') clearUserState(userId); else userStateCache.delete(userId);

    if (chatType === 'group' || chatType === 'supergroup') {
        if (msg.message_id && chatId !== userId) await bot.deleteMessage(chatId, msg.message_id).catch(() => {});
        await safeSendMessage(chatId, `Hi ${playerRefHTML}! 👋 For commands & our main menu, please check our private chat: @${botUsernameHTML} 📬 I've sent it to you there!`, { parse_mode: 'HTML' });
        const dmMsgContext = { from: userObject, chat: { id: userId, type: 'private' }, message_id: null, isCallbackEditing: false };
        await handleHelpCommand(dmMsgContext);
    } else { 
        if (msg.message_id) await bot.deleteMessage(userId, msg.message_id).catch(() => {});
        const privateStartMsgContext = { ...msg, message_id: null, from: userObject, chat: {id: userId, type: 'private'}, isCallbackEditing: false };
        await handleHelpCommand(privateStartMsgContext);
    }
}

async function handleHelpCommand(msg) {
    const userId = String(msg.from.id || msg.from.telegram_id);
    const dmChatId = String(msg.chat.id); 
    // messageIdToEdit is for when this function is called to *edit* an existing message in DM,
    // e.g., when coming back to the main menu from another menu.
    // If msg.isCallbackEditing is a flag we set, we use msg.message_id.
    // Otherwise, if it's a direct /help command, msg.message_id is the command itself and should be deleted if a new message is sent.
    let messageIdToEditOrDelete = msg.message_id;
    let shouldEdit = (msg.chat.type === 'private' && msg.isCallbackEditing === true && msg.message_id);


    let userObject = await getOrCreateUser(userId, msg.from.username, msg.from.first_name, msg.from.last_name);
    if (!userObject) {
        await safeSendMessage(dmChatId, "😕 Error fetching your player profile. Please try <code>/start</code> again.", { parse_mode: 'HTML' });
        return;
    }
    const playerRefHTML = escapeHTML(getPlayerDisplayReference(userObject));
    const botNameToUse = BOT_NAME || "our bot"; 

    // If it's a typed /help command in DM, delete the command message before sending the menu
    if (msg.chat.type === 'private' && !msg.isCallbackEditing && msg.text && msg.text.startsWith('/help') && messageIdToEditOrDelete) {
        await bot.deleteMessage(dmChatId, messageIdToEditOrDelete).catch(() => {});
        shouldEdit = false; // Force sending a new message
        messageIdToEditOrDelete = null;
    }


    const helpMessageHTML = `🎉 Welcome to <b>${escapeHTML(botNameToUse)}</b>, ${playerRefHTML}!\n\n` +
                            `Your casino adventure starts here. What would you like to do?`;
    
    // --- MODIFIED KEYBOARD: Added "Join Community Chat" button ---
    const helpKeyboardRows = [
        [{ text: "💰 My Wallet & Funds", callback_data: "menu:wallet" }],
        [{ text: "🌟 Level Up Bonus", callback_data: "menu:bonus_dashboard_back" }], 
        [{ text: "📖 Game Rules", callback_data: "menu:rules_list" }],
        [{ text: "🤝 Referral Program", callback_data: "menu:referral" }],
    ];
    
    const mainChatLink = process.env.MAIN_CHAT_INVITE_LINK;
    if (mainChatLink) {
        helpKeyboardRows.unshift([{ text: "💬 Join Community Chat", url: mainChatLink }]); // Add button to the top
    }

    const helpKeyboard = {
        inline_keyboard: helpKeyboardRows
    };

    if (shouldEdit && messageIdToEditOrDelete) {
        try {
            await bot.editMessageText(helpMessageHTML, {
                chat_id: dmChatId, message_id: Number(messageIdToEditOrDelete),
                parse_mode: 'HTML', reply_markup: helpKeyboard, disable_web_page_preview: true
            });
        } catch (e) {
            // If editing fails (e.g., message not found or not modified error if content is same), send a new one.
            if (!e.message || !e.message.toLowerCase().includes("message is not modified")) {
                console.warn(`[handleHelpCommand] Failed to edit message ${messageIdToEditOrDelete}, sending new. Error: ${e.message}`);
                await safeSendMessage(dmChatId, helpMessageHTML, { parse_mode: 'HTML', reply_markup: helpKeyboard, disable_web_page_preview: true });
            }
        }
    } else {
        // If not editing (e.g., group redirect, or typed /help in DM where command was deleted), send a new message.
        await safeSendMessage(dmChatId, helpMessageHTML, { parse_mode: 'HTML', reply_markup: helpKeyboard, disable_web_page_preview: true });
    }
}

async function handleRulesCommand(invokedInChatIdStr, userObj, msgIdInInvokedChatStr = null, isEditAttempt = false, invokedChatType = 'private') {
    const invokedInChatId = String(invokedInChatIdStr);
    const msgIdInInvokedChat = msgIdInInvokedChatStr ? Number(msgIdInInvokedChatStr) : null;
    const userIdAsDmChatId = String(userObj.telegram_id);
    
    const playerRefHTML = escapeHTML(getPlayerDisplayReference(userObj));
    let botUsernameToUse = BOT_NAME || "our bot"; // Use global BOT_NAME
    try { const selfInfo = await bot.getMe(); if (selfInfo.username) botUsernameToUse = selfInfo.username; } catch (e) {}
    const botUsernameHTML = escapeHTML(botUsernameToUse); // escape for HTML

    if (invokedChatType !== 'private') {
        const redirectMsgHTML = `${playerRefHTML}, I've sent the Game Rules menu to our private chat: @${botUsernameHTML} 📖 Please check your DMs.`;
        if (isEditAttempt && msgIdInInvokedChat) {
            try {
                await bot.editMessageText(redirectMsgHTML, {
                    chat_id: invokedInChatId, message_id: msgIdInInvokedChat, parse_mode: 'HTML',
                    reply_markup: { inline_keyboard: [[{ text: `📬 Open DM @${botUsernameHTML}`, url: `https://t.me/${botUsernameToUse}?start=menu_rules_list` }]]}
                });
            } catch (e) {
                 if (!e.message?.toLowerCase().includes("message is not modified")) {
                    await safeSendMessage(invokedInChatId, redirectMsgHTML, { parse_mode: 'HTML' });
                }
            }
        } else {
            if(msgIdInInvokedChat) await bot.deleteMessage(invokedInChatId, msgIdInInvokedChat).catch(()=>{});
            await safeSendMessage(invokedInChatId, redirectMsgHTML, { parse_mode: 'HTML' });
        }
    }

    const rulesIntroTextHTML = `📚 <b>${escapeHTML(BOT_NAME)} Gamepedia Central</b> 📚\n\n` + // Use global BOT_NAME
                               `Hey ${playerRefHTML}, welcome! Select a game to learn its rules. 👇`;

    const gameRuleButtons = Object.entries(GAME_IDS)
        .filter(([key, gameCode]) => 
            (gameCode === GAME_IDS.COINFLIP || 
             gameCode === GAME_IDS.RPS || 
             gameCode === GAME_IDS.DICE_ESCALATOR || 
             gameCode === GAME_IDS.DICE_21 ||        
             gameCode === GAME_IDS.DUEL ||           
             gameCode === GAME_IDS.MINES ||          
             gameCode === GAME_IDS.OVER_UNDER_7 ||
             gameCode === GAME_IDS.LADDER ||
             gameCode === GAME_IDS.SEVEN_OUT ||      
             gameCode === GAME_IDS.SLOT_FRENZY) &&
            !key.endsWith("_PVB") && !key.endsWith("_PVP") && !key.includes("_FROM_") 
            && gameCode !== GAME_IDS.DIRECT_PVP_CHALLENGE 
            && !key.endsWith("_UNIFIED_OFFER") && gameCode !== GAME_IDS.MINES_OFFER
        )
        .map(([key, gameCode]) => {
            let gameName = gameCode.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            let ruleCallbackKey = gameCode; 
            let emoji = '❓';
            
            if (gameCode === GAME_IDS.COINFLIP) { gameName = "Coinflip"; emoji = '🪙'; }
            else if (gameCode === GAME_IDS.RPS) { gameName = "Rock Paper Scissors"; emoji = '✂️'; }
            else if (gameCode === GAME_IDS.DICE_ESCALATOR) { gameName = "Dice Escalator"; emoji = '🎲'; ruleCallbackKey = GAME_IDS.DICE_ESCALATOR_UNIFIED_OFFER;}
            else if (gameCode === GAME_IDS.DICE_21) { gameName = "Dice 21 (Blackjack)"; emoji = '🃏'; }
            else if (gameCode === GAME_IDS.DUEL) { gameName = "Duel / Highroller"; emoji = '⚔️'; ruleCallbackKey = GAME_IDS.DUEL_UNIFIED_OFFER; }
            else if (gameCode === GAME_IDS.MINES) { gameName = "Mines"; emoji = '💣';}
            else if (gameCode === GAME_IDS.OVER_UNDER_7) { gameName = "Over/Under 7"; emoji = '🎲'; }
            else if (gameCode === GAME_IDS.LADDER) { gameName = "Greed's Ladder"; emoji = '🪜'; }
            else if (gameCode === GAME_IDS.SEVEN_OUT) { gameName = "Lucky Sum"; emoji = '🎲'; }
            else if (gameCode === GAME_IDS.SLOT_FRENZY) { gameName = "Slot Frenzy"; emoji = '🎰'; }
            
            return { text: `${emoji} ${escapeHTML(gameName)}`, callback_data: `${RULES_CALLBACK_PREFIX_CONST}${ruleCallbackKey}` };
        })
        .filter((button, index, self) => index === self.findIndex((b) => b.callback_data === button.callback_data));


    const rows = [];
    for (let i = 0; i < gameRuleButtons.length; i += 2) rows.push(gameRuleButtons.slice(i, i + 2));
    rows.push([{ text: '⬅️ Back to Main Menu', callback_data: 'menu:main' }]);

    const keyboard = { inline_keyboard: rows };
    const options = { parse_mode: 'HTML', reply_markup: keyboard, disable_web_page_preview: true };

    let messageIdToOperateOn = (invokedChatType === 'private' && isEditAttempt && msgIdInInvokedChat) ? msgIdInInvokedChat : null;
    if (invokedChatType === 'private' && !isEditAttempt && msgIdInInvokedChat) {
        await bot.deleteMessage(userIdAsDmChatId, msgIdInInvokedChat).catch(()=>{});
        messageIdToOperateOn = null; 
    }

    if (messageIdToOperateOn) {
        try {
            await bot.editMessageText(rulesIntroTextHTML, { chat_id: userIdAsDmChatId, message_id: messageIdToOperateOn, ...options });
        } catch (e) {
            if (!e.message || !e.message.toLowerCase().includes("message is not modified")) {
                await safeSendMessage(userIdAsDmChatId, rulesIntroTextHTML, options);
            }
        }
    } else {
        await safeSendMessage(userIdAsDmChatId, rulesIntroTextHTML, options);
    }
}

async function handleGamesOverviewMenu(msg) { 
    const userId = String(msg.from.id || msg.from.telegram_id);
    const dmChatId = String(msg.chat.id); 
    const messageIdToEdit = msg.message_id; 
    
    const playerRefHTML = escapeHTML(getPlayerDisplayReference(msg.from));
    const messageTextHTML = `<b>Choose Your Challenge, ${playerRefHTML}!</b> 🎯\n\n` +
                            `Select a game category or explore all our exciting offerings below. Good luck!`;
    const keyboard = {
        inline_keyboard: [
            [{ text: "🎰 View All Games & Rules", callback_data: "menu:rules_list" }],
            [{ text: "⬅️ Back to Main Menu", callback_data: "menu:main" }]
        ]
    };

    if (messageIdToEdit) {
        try {
            await bot.editMessageText(messageTextHTML, {
                chat_id: dmChatId, message_id: Number(messageIdToEdit),
                parse_mode: 'HTML', reply_markup: keyboard, disable_web_page_preview: true
            });
        } catch (e) {
            if (!e.message || !e.message.toLowerCase().includes("message is not modified")) {
                await safeSendMessage(dmChatId, messageTextHTML, { parse_mode: 'HTML', reply_markup: keyboard, disable_web_page_preview: true });
            }
        }
    } else {
        await safeSendMessage(dmChatId, messageTextHTML, { parse_mode: 'HTML', reply_markup: keyboard, disable_web_page_preview: true });
    }
}

async function handleDisplayGameRules(originalInvokedChatIdStr, originalMessageIdStr, gameCode, userObj, originalInvokedChatType = 'private') {
    const originalInvokedChatId = String(originalInvokedChatIdStr);
    const originalMessageId = originalMessageIdStr ? Number(originalMessageIdStr) : null;
    const userIdAsDmChatId = String(userObj.telegram_id);
    
    const playerRefHTML = escapeHTML(getPlayerDisplayReference(userObj));
    const botNameToUse = BOT_NAME || "our bot"; // Use global BOT_NAME

    const targetDmChatId = userIdAsDmChatId; 
    let messageIdToEditInDm = (originalInvokedChatType === 'private' && originalMessageId) ? originalMessageId : null;

    let generalBettingInfoHTML = "<i>General betting information is currently unavailable.</i>\n\n";
    try {
        const solPrice = await getSolUsdPrice();
        const minBetInLamports = convertUSDToLamports(MIN_BET_USD_val, solPrice);
        const minBetDisplayHTML = escapeHTML(await formatBalanceForDisplay(minBetInLamports, 'USD'));
        const maxBetDisplayHTML = escapeHTML(`$${MAX_BET_USD_val.toFixed(2)}`);
        const defaultBetDisplayHTML = minBetDisplayHTML; 
        generalBettingInfoHTML = `<b>💰 General Betting Info:</b>\n` +
            ` • Place bets in USD (e.g., <code>5</code>, <code>10.50</code>).\n` +
            ` • Current Bet Limits (USD Equivalent): <b>${minBetDisplayHTML}</b> to <b>${maxBetDisplayHTML}</b>.\n` +
            ` • If no bet amount is specified, it defaults to min bet (approx. <b>${defaultBetDisplayHTML}</b>).\n\n`;
    } catch (priceError) { generalBettingInfoHTML = "Error loading bet limit info.\n\n"; }

    let rulesTitle = gameCode.replace(/_/g, ' ').replace(' Unified Offer', '').replace(/\b\w/g, l => l.toUpperCase());
    let gameEmoji = '📜';
    let rulesTextHTML = "";

    switch (gameCode) {
        case GAME_IDS.COINFLIP:
            gameEmoji = '🪙'; rulesTitle = "Coinflip Challenge";
            rulesTextHTML = `${gameEmoji} <b>${escapeHTML(rulesTitle)}</b> ${gameEmoji}\n\nHey ${playerRefHTML}!\n\n<b>Objective:</b> Correctly predict Heads or Tails.\n\n<b>How to Play:</b>\n• <code>/coinflip &lt;bet&gt; [@user]</code> in a group.\n• Play vs Bot or PvP.\n• Caller predicts, coin is flipped.\n\n<b>Payout:</b> 2x bet for winner.\n\n${generalBettingInfoHTML}`;
            break;
        case GAME_IDS.RPS:
            gameEmoji = '✂️'; rulesTitle = "Rock Paper Scissors";
            rulesTextHTML = `${gameEmoji} <b>${escapeHTML(rulesTitle)}</b> ${gameEmoji}\n\nHey ${playerRefHTML}!\n\n<b>Objective:</b> Outsmart opponent with Rock, Paper, or Scissors.\n\n<b>How to Play:</b>\n• <code>/rps &lt;bet&gt; [@user]</code> in a group.\n• Play vs Bot or PvP (secret choices via DM).\n• Winner determined by classic rules.\n\n<b>Payout:</b> Winner takes 2x bet. Draw is a Push.\n\n${generalBettingInfoHTML}`;
            break;
        case GAME_IDS.DICE_ESCALATOR_UNIFIED_OFFER:
        case GAME_IDS.DICE_ESCALATOR: 
            gameEmoji = '🎲'; rulesTitle = "Dice Escalator";
            rulesTextHTML = `${gameEmoji} <b>${escapeHTML(rulesTitle)}</b> ${gameEmoji}\n\nHey ${playerRefHTML}!\n\n<b>Objective:</b> Higher score than opponent without busting.\n\n<b>How to Play:</b>\n• <code>/de &lt;bet&gt; [@user]</code> in a group.\n• Send 🎲 emoji to roll.\n• Bust: Rolling <b>${escapeHTML(String(DICE_ESCALATOR_BUST_ON))}</b> scores 0 for that die & ends turn.\n• Stand: Keep current score.\n\n<b>PvB:</b> Bot rolls ${DE_PVB_BOT_ROLL_COUNT} dice. Win 2x. Tie is Push. Jackpot: Score <b>${escapeHTML(String(TARGET_JACKPOT_SCORE))}</b>+ & beat Bot. Jackpot Run at 18+.\n<b>PvP:</b> P1 rolls then P2. Highest score wins 2x. Tie is Push. No Jackpot.\n\n${generalBettingInfoHTML}`; // Used TARGET_JACKPOT_SCORE
            break;
        case GAME_IDS.DICE_21: 
        case GAME_IDS.DICE_21_UNIFIED_OFFER: 
            gameEmoji = '🃏'; rulesTitle = "Dice 21 (Blackjack)";
            rulesTextHTML = `${gameEmoji} <b>${escapeHTML(rulesTitle)}</b> ${gameEmoji}\n\nHey ${playerRefHTML}!\n\n<b>Objective:</b> Sum closer to <b>${escapeHTML(String(DICE_21_TARGET_SCORE))}</b> than opponent, no bust.\n\n<b>How to Play:</b>\n• <code>/d21 &lt;bet&gt; [@user]</code> in a group.\n• Two initial dice. Send 🎲 to Hit. Click Stand.\n• Bust: Score > ${escapeHTML(String(DICE_21_TARGET_SCORE))}.\n\n<b>PvB:</b> Bot stands on <b>${escapeHTML(String(DICE_21_BOT_STAND_SCORE))}+</b>.\n<b>Payouts:</b> Win 2x. Blackjack (21 on first 2 dice) 2.5x. Push returns bet.\n\n${generalBettingInfoHTML}`;
            break;
        case GAME_IDS.OVER_UNDER_7:
            gameEmoji = '🎲'; rulesTitle = "Over/Under 7";
            rulesTextHTML = `${gameEmoji} <b>${escapeHTML(rulesTitle)}</b> ${gameEmoji}\n\nHey ${playerRefHTML}!\n\n<b>Objective:</b> Predict if sum of <b>${escapeHTML(String(OU7_DICE_COUNT))} dice</b> is Over 7, Under 7, or Exactly 7.\n\n<b>How to Play:</b>\n• <code>/ou7 &lt;bet&gt;</code>.\n• Choose prediction: Under 7 (2-6), Exactly 7, Over 7 (8-12).\n\n<b>Payouts (Total Return):</b>\n• Under/Over 7: <b>${escapeHTML(String(OU7_PAYOUT_NORMAL + 1))}x</b> bet.\n• Exactly 7: <b>${escapeHTML(String(OU7_PAYOUT_SEVEN + 1))}x</b> bet!\n\n${generalBettingInfoHTML}`;
            break;
        case GAME_IDS.DUEL_UNIFIED_OFFER: 
        case GAME_IDS.DUEL: 
            gameEmoji = '⚔️'; rulesTitle = "Duel / Highroller";
            rulesTextHTML = `${gameEmoji} <b>${escapeHTML(rulesTitle)}</b> ${gameEmoji}\n\nHey ${playerRefHTML}!\n\n<b>Objective:</b> Higher sum with <b>${escapeHTML(String(DUEL_DICE_COUNT))} dice</b> than opponent.\n\n<b>How to Play:</b>\n• <code>/duel &lt;bet&gt; [@user]</code> in a group.\n• Each player (or player & bot) rolls ${escapeHTML(String(DUEL_DICE_COUNT))} dice (send 🎲 when prompted).\n\n<b>Winning:</b> Highest sum wins.\n<b>Payouts:</b> Winner 2x bet. Tie is Push.\n\n${generalBettingInfoHTML}`;
            break;
        case GAME_IDS.LADDER:
            gameEmoji = '🪜'; rulesTitle = "Greed's Ladder";
            rulesTextHTML = `${gameEmoji} <b>${escapeHTML(rulesTitle)}</b> ${gameEmoji}\n\nHey ${playerRefHTML}!\n\n<b>Objective:</b> High sum with <b>${escapeHTML(String(LADDER_ROLL_COUNT))} dice</b>. Beware the bust!\n\n<b>How to Play:</b>\n• <code>/ladder &lt;bet&gt;</code>. All dice rolled at once.\n• Bust: Rolling <b>${escapeHTML(String(LADDER_BUST_ON))}</b> on ANY die means you bust!\n\n<b>Payouts (Total Sum if NO Bust; includes stake):</b>\n`;
            LADDER_PAYOUTS.forEach(p => { rulesTextHTML += ` • Sum <b>${escapeHTML(String(p.min))}-${escapeHTML(String(p.max))}</b>: <b>${escapeHTML(String(p.multiplier + 1))}x</b> <i>(${escapeHTML(p.label)})</i>\n`; });
            rulesTextHTML += `\n${generalBettingInfoHTML}`;
            break;
        case GAME_IDS.SEVEN_OUT:
            gameEmoji = '🎲'; rulesTitle = "Lucky Sum (Fast Sevens)";
            rulesTextHTML = `${gameEmoji} <b>${escapeHTML(rulesTitle)}</b> ${gameEmoji}\n\nHey ${playerRefHTML}!\n\n<b>Objective:</b> Roll two dice. Certain sums win, others lose!\n\n<b>How to Play:</b>\n• <code>/s7 &lt;bet&gt;</code>.\n• Two dice are rolled by the bot.\n\n<b>Outcomes & Payouts (Total Return):</b>\n`;
            for (const sumKey in LUCKY_SUM_PAYOUTS) { rulesTextHTML += ` • Sum <b>${escapeHTML(sumKey)}</b> (${escapeHTML(LUCKY_SUM_PAYOUTS[sumKey].label)}): <b>${escapeHTML(String(LUCKY_SUM_PAYOUTS[sumKey].multiplier + 1))}x</b>\n`; }
            rulesTextHTML += ` • Sums <b>${LUCKY_SUM_LOSING_NUMBERS.map(n => escapeHTML(String(n))).join(', ')}</b>: Loss.\n\n${generalBettingInfoHTML}`;
            break;
        case GAME_IDS.SLOT_FRENZY:
            gameEmoji = '🎰'; rulesTitle = "Slot Frenzy";
            rulesTextHTML = `${gameEmoji} <b>${escapeHTML(rulesTitle)}</b> ${gameEmoji}\n\nHey ${playerRefHTML}!\n\n<b>Objective:</b> Match symbols for wins! Outcome via Helper Bot value (1-64).\n\n<b>How to Play:</b>\n• <code>/slot &lt;bet&gt;</code>.\n• Helper Bot spin determines win.\n\n<b>Payouts (Total Return):</b>\n`;
            for (const key in SLOT_PAYOUTS) { if (SLOT_PAYOUTS[key].multiplier >= 0) rulesTextHTML += ` • ${escapeHTML(SLOT_PAYOUTS[key].symbols)} (${escapeHTML(SLOT_PAYOUTS[key].label)}): <b>${escapeHTML(String(SLOT_PAYOUTS[key].multiplier + 1))}x</b>\n`; }
            rulesTextHTML += ` • Others: Loss.\n\n${generalBettingInfoHTML}`;
            break;
        case GAME_IDS.MINES: // Covers MINES_OFFER too
            gameEmoji = '💣'; rulesTitle = "Mines Field Sweeper";
            rulesTextHTML = `${gameEmoji} <b>${escapeHTML(rulesTitle)}</b> ${gameEmoji}\n\nHey ${playerRefHTML}!\n\n<b>Objective:</b> Reveal gems 💎, avoid mines 💣. Each gem increases multiplier. Cash out anytime or find all gems!\n\n<b>How to Play:</b>\n• <code>/mines &lt;bet&gt;</code> in group.\n• Select difficulty.\n• Click tiles. Mine 💣 = loss. Gem 💎 = payout increases.\n• Click "Cash Out" to take current winnings.\n\n<b>Payouts:</b> Vary by difficulty and gems found. Max payout for all gems!\n\n${generalBettingInfoHTML}`;
            break;
        default:
            if (!rulesTextHTML) { 
                rulesTitle = "Unknown Game";
                rulesTextHTML = `${gameEmoji} <b>${escapeHTML(rulesTitle)} Rules</b> ${gameEmoji}\n\nHey ${playerRefHTML}!\n\n📜 Rules for "<code>${escapeHTML(gameCode)}</code>" are under construction.`;
            }
    }
    rulesTextHTML += `\n\nPlay smart, play responsibly! 🍀`;

    const keyboard = { inline_keyboard: [[{ text: "📚 Back to Rules List", callback_data: "menu:rules_list" }]] };
    const options = { parse_mode: 'HTML', reply_markup: keyboard, disable_web_page_preview: true };

    if (messageIdToEditInDm) {
        try {
            await bot.editMessageText(rulesTextHTML, { chat_id: userIdAsDmChatId, message_id: Number(messageIdToEditInDm), ...options });
        } catch (e) {
            if (!e.message || !e.message.toLowerCase().includes("message is not modified")) {
                await safeSendMessage(userIdAsDmChatId, rulesTextHTML, options);
            }
        }
    } else {
        await safeSendMessage(userIdAsDmChatId, rulesTextHTML, options);
    }
}

async function handleReferralCommand(msgOrCbMsg) {
    const userId = String(msgOrCbMsg.from.id || msgOrCbMsg.from.telegram_id);
    const commandChatId = String(msgOrCbMsg.chat.id);
    const originalMessageId = msgOrCbMsg.message_id;
    // Determine if this is a menu action in DM (which might involve editing a message)
    // or a command typed directly (which might involve deleting the command message).
    const isFromMenuActionEditingInDm = msgOrCbMsg.message && msgOrCbMsg.message.chat && msgOrCbMsg.message.chat.id === userId && originalMessageId && (msgOrCbMsg.isCallbackEditing === true || (msgOrCbMsg.data && msgOrCbMsg.data.startsWith("menu:referral")));

    const LOG_PREFIX_REF_CMD = `[ReferralCmd_V6_HTML_GroupInfo UID:${userId} Chat:${commandChatId}]`; // V6

    let user = await getOrCreateUser(userId, msgOrCbMsg.from?.username, msgOrCbMsg.from?.first_name, msgOrCbMsg.from?.last_name);
    if (!user) {
        await safeSendMessage(commandChatId === userId ? userId : commandChatId, "Error fetching your player profile for referral info. Please try <code>/start</code>.", { parse_mode: 'HTML' });
        return;
    }
    // For HTML messages, use escapeHTML with the raw display name functions
    const playerRefHTML = escapeHTML(getRawPlayerDisplayReference(user)); // Assumes getRawPlayerDisplayReference is defined
    let botUsername = BOT_NAME || "our_bot";
    try {
        const selfInfo = await bot.getMe();
        if (selfInfo.username) botUsername = selfInfo.username;
    } catch (e) { console.warn(`${LOG_PREFIX_REF_CMD} Could not fetch bot username: ${e.message}`); }

    clearUserState(userId); // Assuming clearUserState is defined
    const targetDmChatId = userId; // All detailed dashboards go to DM

    // --- Group Chat Logic ---
    if (commandChatId !== targetDmChatId) { // Command was used in a group
        if (originalMessageId && msgOrCbMsg.text && msgOrCbMsg.text.startsWith('/referral')) { // Delete the typed /referral command
             await bot.deleteMessage(commandChatId, originalMessageId).catch(() => {});
        }

        const successfulReferralsGroup = user.referral_count || 0;
        const totalEarningsPaidLamportsGroup = user.total_referral_earnings_paid_lamports || 0n;
        const totalEarningsPaidUSDGroup = await formatBalanceForDisplay(totalEarningsPaidLamportsGroup, 'USD'); // Assumes formatBalanceForDisplay is HTML-safe or escaped

        let groupReferralMessageHTML = `✨ <b>${playerRefHTML}'s Referral Quick Stats</b> ✨\n\n` +
                                     `🤝 Successful Referrals: <b>${successfulReferralsGroup}</b>\n` +
                                     `💸 Total Earnings Paid Out: ~<b>${escapeHTML(totalEarningsPaidUSDGroup)}</b>\n\n` + // escapeHTML for safety
                                     `📬 Your full Referral Dashboard has been sent to your DMs with @${escapeHTML(botUsername)}.`;

        await safeSendMessage(commandChatId, groupReferralMessageHTML, { parse_mode: 'HTML' });
    }

    // --- DM Logic (Send full dashboard to DM) ---
    // If the command was typed in DM, delete the original /referral command.
    // If it's a menu action in DM trying to edit, delete the old menu message.
    if (commandChatId === targetDmChatId && originalMessageId) {
        if ((msgOrCbMsg.text && msgOrCbMsg.text.startsWith('/referral')) || isFromMenuActionEditingInDm) {
            await bot.deleteMessage(targetDmChatId, originalMessageId).catch(() => {});
        }
    }

    let referralCode = user.referral_code;
    if (!referralCode) {
        referralCode = generateReferralCode(); // Assuming generateReferralCode is defined
        try {
            await queryDatabase("UPDATE users SET referral_code = $1, updated_at = NOW() WHERE telegram_id = $2", [referralCode, userId]);
            user.referral_code = referralCode;
        } catch (dbErr) {
            console.error(`${LOG_PREFIX_REF_CMD} Failed to save new referral code for user ${userId}: ${dbErr.message}`);
            referralCode = "ErrorGenerating";
        }
    }
    const referralLink = `https://t.me/${botUsername}?start=ref_${referralCode}`;
    const enticingShareMessage = `Step into the hottest multiplayer telegram chat 🎲\n\nThey've got fast-paced PvB and PvP multiplayer dice games, huge jackpots, and an awesome community. I'm already playing, you should join too!\n\nClick my link to get started and we can both earn rewards! 👇\n${referralLink}`;

    const successfulReferralsCountDM = user.referral_count || 0;
    const totalEarningsPaidLamportsDM = user.total_referral_earnings_paid_lamports || 0n;
    const totalEarningsPaidUSDDisplayDM = await formatBalanceForDisplay(totalEarningsPaidLamportsDM, 'USD');

    let messageTextHTML = `🤝 <b>Your Referral Dashboard</b> 🤝\n\n` +
                          `<b>Invite Friends & Earn SOL!</b>\n\n` +
                          `🔗 <b>Your Unique Referral Link:</b>\n<a href="${escapeHTML(referralLink)}">${escapeHTML(referralLink)}</a>\n` +
                          `<i>(Use the "Share Your Link!" button below for an enticing, pre-filled message.)</i>\n\n` +
                          `📊 <b>Your Stats:</b>\n` +
                          ` ▫️ Successful Referrals: <b>${successfulReferralsCountDM}</b>\n` +
                          ` ▫️ Total Earnings Paid Out: ~<b>${escapeHTML(totalEarningsPaidUSDDisplayDM)}</b>\n\n` + // escapeHTML for safety
                          `🎁 <b>How You Earn:</b>\n\n` +
                          ` 1️⃣ <b>Initial Bet Bonus:</b>\n` +
                          ` 💰 When your friend places their first qualifying bet (min. <b>$${REFERRAL_QUALIFYING_BET_USD_CONST.toFixed(2)} USD</b>), you earn a percentage of their bet amount! The more friends you refer, the higher your percentage:\n`;

    REFERRAL_INITIAL_BET_TIERS_CONFIG.forEach(tier => {
        const upTo = tier.upToReferrals === Infinity ? "100+" : `Up to ${tier.upToReferrals}`;
        messageTextHTML += ` ▫️ ${escapeHTML(upTo)} Referrals: <b>${(tier.percentage * 100).toFixed(1)}%</b>\n`;
    });

    messageTextHTML += `\n 2️⃣ <b>Wager Milestone Bonus:</b>\n` +
                       ` 💸 As your referred friends play and reach wagering milestones (e.g., they've wagered <b>$${REFERRAL_WAGER_MILESTONES_USD_CONFIG[0]} USD</b>, <b>$${REFERRAL_WAGER_MILESTONES_USD_CONFIG[1]} USD</b> total, etc.), you'll receive <b>${(REFERRAL_WAGER_MILESTONE_BONUS_PERCENTAGE_CONST * 100).toFixed(1)}%</b> of that milestone amount. These bonuses will appear below for you to claim!\n\n`;

    const keyboardRows = [];
    let claimableBonusesMessageHTML = "";
    try {
        // --- FIXED: This logic has been rewritten to use multiple simple queries instead of one complex one, avoiding the syntax error. ---
        const getClaimableBonusesQuery = `
            SELECT referral_id, commission_type, commission_amount_lamports, referred_telegram_id
            FROM referrals
            WHERE referrer_telegram_id = $1 AND status = 'milestone_bonus_claimable'
            ORDER BY created_at ASC`;
        const claimableRes = await queryDatabase(getClaimableBonusesQuery, [userId]);

        if (claimableRes.rows.length > 0) {
            claimableBonusesMessageHTML = "✨ <b>Claim Your Milestone Bonuses:</b>\n";
            for (const bonus of claimableRes.rows) {
                // For each bonus, fetch the referred user's details separately
                const referredUserRes = await queryDatabase(
                    'SELECT username, first_name FROM users WHERE telegram_id = $1',
                    [bonus.referred_telegram_id]
                );
                
                const referredUserTempObj = { 
                    username: referredUserRes.rows[0]?.username, 
                    first_name: referredUserRes.rows[0]?.first_name, 
                    telegram_id: bonus.referred_telegram_id 
                };

                const bonusAmountDisplay = await formatBalanceForDisplay(BigInt(bonus.commission_amount_lamports), 'USD');
                const referredUserDisplay = escapeHTML(getRawPlayerDisplayReference(referredUserTempObj));
                const milestoneType = escapeHTML(bonus.commission_type.replace('wager_milestone_', '').replace('_usd', ' USD Wagered'));

                claimableBonusesMessageHTML += ` ▫️ Approx. <b>${escapeHTML(bonusAmountDisplay)}</b> from ${referredUserDisplay} (${milestoneType})\n`;
                keyboardRows.push([{ text: `💰 Claim ~${escapeHTML(bonusAmountDisplay)} (from ${escapeHTML(getRawPlayerDisplayReference(referredUserTempObj, false).substring(0,10))}...)`, callback_data: `claim_milestone_bonus:${bonus.referral_id}` }]);
            }
            claimableBonusesMessageHTML += "\n";
        }
    } catch (e) {
        console.error(`${LOG_PREFIX_REF_CMD} Error fetching claimable bonuses: ${e.message}`);
        claimableBonusesMessageHTML = "Error fetching claimable bonuses.\n";
    }

    messageTextHTML += claimableBonusesMessageHTML;
    messageTextHTML += `Keep sharing and earning! ✨`;

    keyboardRows.push([{ text: "🔗 Share Your Link!", switch_inline_query: enticingShareMessage }]);
    keyboardRows.push([{ text: '💳 Back to Wallet', callback_data: 'menu:wallet' }]);
    const keyboard = { inline_keyboard: keyboardRows };

    await safeSendMessage(targetDmChatId, messageTextHTML, { parse_mode: 'HTML', reply_markup: keyboard, disable_web_page_preview: true });
}

async function handleBalanceCommand(msg) {
    const userId = String(msg.from.id || msg.from.telegram_id);    
    const commandChatId = String(msg.chat.id);
    const chatType = msg.chat.type;
    const LOG_PREFIX_BALANCE_CMD = `[BalanceCmd_V5_USDOnly UID:${userId} Chat:${commandChatId}]`; // V5

    let user = await getOrCreateUser(userId, msg.from.username, msg.from.first_name, msg.from.last_name);
    if (!user) {
        await safeSendMessage(commandChatId, "😕 Apologies! We couldn't fetch your player profile to show your balance. Please try <code>/start</code> again.", { parse_mode: 'HTML' });
        return;
    }
    const playerRefHTML = escapeHTML(getPlayerDisplayReference(user)); 
    
    let botUsernameToUse = BOT_NAME || "our bot";
    try {
        const selfInfo = await bot.getMe();
        if (selfInfo.username) botUsernameToUse = selfInfo.username;
    } catch (e) { /* ignore */ }    

    const balanceLamports = await getUserBalance(userId);
    if (balanceLamports === null) {
        const errorMsgTextHTML = "🏦 Oops! We couldn't retrieve your balance right now. This is unusual.<br>Please try again in a moment, or contact support if this issue persists.";
        if (chatType === 'private') {
            await safeSendMessage(userId, errorMsgTextHTML, { parse_mode: 'HTML' });    
        } else {
            if (msg.message_id && commandChatId !== userId) await bot.deleteMessage(commandChatId, msg.message_id).catch(() => {});
            await safeSendMessage(commandChatId, `${playerRefHTML}, there was a hiccup fetching your balance. I've sent details to your DMs with @${escapeHTML(botUsernameToUse)}.`, { parse_mode: 'HTML' });
            await safeSendMessage(userId, errorMsgTextHTML, { parse_mode: 'HTML' }); 
        }
        return;
    }

    // Get USD value for display
    const balanceUSD_HTML = escapeHTML(await formatBalanceForDisplay(balanceLamports, 'USD'));

    if (msg.message_id && commandChatId) {
        await bot.deleteMessage(commandChatId, msg.message_id).catch(() => {});
    }

    if (chatType !== 'private') {
        // Group chat message - USD only, no "Approx."
        const groupBalanceMessageHTML = `💰 <b>${playerRefHTML}'s Balance</b> 💰\n\n` +
                                        `USD Balance: <b>${balanceUSD_HTML}</b>\n\n` + // Changed "Approx. Value"
                                        `ℹ️ For detailed wallet actions & history, please check your DMs with @${escapeHTML(botUsernameToUse)}. I've sent your full statement there!`;
        await safeSendMessage(commandChatId, groupBalanceMessageHTML, { parse_mode: 'HTML' });
    }
    
    // Send detailed message to DM regardless, now using HTML and USD-centric
    const balanceMessageDmHTML = `⚜️ <b>Your Casino Wallet</b> ⚜️\n\n` +
                                 `Hey ${playerRefHTML}!\n\n` +
                                 `Your current casino balance is:\n` +
                                 `💰 <b>${balanceUSD_HTML}</b>\n` +
                                 `   (This is the USD value of your SOL balance based on live market rates)\n\n`+
                                 // Optionally, if you still want to show lamports for user's own reference, but not SOL directly:
                                 // `   Equivalent to: <code>${escapeHTML(String(balanceLamports))}</code> Lamports\n\n` +
                                 `-------------------------------\n` +
                                 `Manage your funds or dive into the games! Good luck! ✨`;

    const keyboardDm = {
        inline_keyboard: [
            [{ text: "➕ Deposit SOL", callback_data: QUICK_DEPOSIT_CALLBACK_ACTION_CONST }, { text: "➖ Withdraw SOL", callback_data: WITHDRAW_CALLBACK_ACTION_CONST }],
            [{ text: "📜 Transaction History", callback_data: "menu:history" }, { text: "🔗 Link/Update Wallet", callback_data: "menu:link_wallet_prompt" }],
            [{ text: "🎲 View Games & Rules", callback_data: "menu:rules_list" }, { text: "🤝 Referrals", callback_data: "menu:referral" }],
            [{ text: "🌟 Level Up Bonus", callback_data: "menu:bonus_dashboard_back" }]
        ]
    };
    await safeSendMessage(userId, balanceMessageDmHTML, { parse_mode: 'HTML', reply_markup: keyboardDm });
}

async function handleJackpotCommand(chatId, userObj, chatType) {
    const LOG_PREFIX_JACKPOT = `[JackpotCmd UID:${userObj.telegram_id} Chat:${chatId}]`;
    const playerRef = getPlayerDisplayReference(userObj); 

    try {
        const result = await queryDatabase('SELECT current_amount FROM jackpots WHERE jackpot_id = $1', [MAIN_JACKPOT_ID]);
        let jackpotAmountLamports = 0n;
        if (result.rows.length > 0 && result.rows[0].current_amount) {
            jackpotAmountLamports = BigInt(result.rows[0].current_amount);
        }

        const jackpotUSD = await formatBalanceForDisplay(jackpotAmountLamports, 'USD');
        const jackpotSOL = formatCurrency(jackpotAmountLamports, 'SOL');
        const jackpotTargetScoreDisplay = escapeMarkdownV2(String(TARGET_JACKPOT_SCORE)); // Used TARGET_JACKPOT_SCORE

        const jackpotMessage = `🏆 **Dice Escalator (PvB) Super Jackpot Alert!** 🏆\n\n` +
            `Hey ${playerRef}, the current Super Jackpot for the Player vs Bot Dice Escalator game is a shimmering mountain of riches:\n\n` +
            `💰 Approx. Value: *${escapeMarkdownV2(jackpotUSD)}*\n` +    
            `🪙 SOL Amount: *${escapeMarkdownV2(jackpotSOL)}*\n\n` +
            `To claim this colossal prize, you must win a round of Dice Escalator (PvB Mode) with a score of *${jackpotTargetScoreDisplay} or higher* AND beat the Bot Dealer! Do you have what it takes? ✨\n\nType \`/de <bet>\` to try your luck in a group chat!`;    

        await safeSendMessage(chatId, jackpotMessage, { parse_mode: 'MarkdownV2', disable_web_page_preview: true });

    } catch (error) {
        console.error(`${LOG_PREFIX_JACKPOT} Error fetching jackpot: ${error.message}`);
        await safeSendMessage(chatId, "⚙️ Apologies, there was a momentary glitch fetching the current Jackpot amount. Please try `/jackpot` again soon.", { parse_mode: 'MarkdownV2' });    
    }
}

async function handleLeaderboardsCommand(msg, args) {
    const userId = String(msg.from.id || msg.from.telegram_id);    
    const chatId = String(msg.chat.id);
    const user = await getOrCreateUser(userId, msg.from.username, msg.from.first_name, msg.from.last_name);
    if (!user) {
         await safeSendMessage(chatId, "Error fetching your profile. Please try `/start`.", {});    
         return;
    }
    const playerRef = getPlayerDisplayReference(user); 
    const typeArg = args[0] || 'overall_wagered';
    const typeDisplay = escapeMarkdownV2(typeArg.replace(/_/g, " ").replace(/\b\w/g, l => l.toUpperCase()));
    const botNameToUse = BOT_NAME || "Solana Casino Royale"; // Use global BOT_NAME

    const leaderboardMessage = `🏆 **${escapeMarkdownV2(botNameToUse)} Hall of Fame** 🏆 - _Coming Soon!_\n\n` +    
        `Greetings, ${playerRef}! Our legendary leaderboards for categories like *${typeDisplay}* are currently under meticulous construction by our top casino architects. 🏗️\n\n` +    
        `Soon, you'll be able to see who's dominating the casino floor, raking in the biggest wins, and making the boldest wagers!\n\n` +    
        `Keep playing, sharpen your skills, and prepare to etch your name in ${escapeMarkdownV2(botNameToUse)} history! Check back soon for the grand unveiling! ✨`;    
    await safeSendMessage(chatId, leaderboardMessage, { parse_mode: 'MarkdownV2' });
}

async function handleGrantCommand(msg, args, adminUserObj) {
    const LOG_PREFIX_GRANT = `[GrantCmd UID:${adminUserObj.telegram_id}]`;
    const chatId = String(msg.chat.id);
    const adminUserIdStr = String(adminUserObj.telegram_id);

    if (!ADMIN_USER_ID || adminUserIdStr !== ADMIN_USER_ID) {
        return;    
    }

    if (args.length < 2) {
        await safeSendMessage(chatId, "⚙️ **Admin Grant Usage:** `/grant <target_user_id_or_@username> <amount_SOL_or_Lamports> [Optional: reason]`\n*Examples:*\n`/grant @LuckyPlayer 10 SOL Welcome Bonus`\n`/grant 123456789 50000000 lamports Correction`\n`/grant @RiskTaker -2 SOL BetSettleFix`", { parse_mode: 'MarkdownV2' });    
        return;
    }

    const targetUserIdentifier = args[0];
    const amountArg = args[1];
    const reason = args.slice(2).join(' ') || `Admin grant by ${adminUserObj.username || adminUserIdStr}`;
    let amountToGrantLamports;
    let targetUser;

    try {
        if (targetUserIdentifier.startsWith('@')) {
            const usernameToFind = targetUserIdentifier.substring(1);
            const userRes = await queryDatabase('SELECT telegram_id, username, first_name FROM users WHERE LOWER(username) = LOWER($1)', [usernameToFind]);
            if (userRes.rowCount === 0) throw new Error(`User not found: \`${escapeMarkdownV2(targetUserIdentifier)}\`.`);
            targetUser = await getOrCreateUser(userRes.rows[0].telegram_id, userRes.rows[0].username, userRes.rows[0].first_name);
        } else if (/^\d+$/.test(targetUserIdentifier)) {
            targetUser = await getOrCreateUser(targetUserIdentifier);
        } else {
            throw new Error(`Invalid target: \`${escapeMarkdownV2(targetUserIdentifier)}\`. Use Telegram ID or @username.`);
        }
        if (!targetUser) throw new Error(`Could not find or create target user \`${escapeMarkdownV2(targetUserIdentifier)}\`.`);
        
        const amountArgLower = String(amountArg).toLowerCase();
        let parsedAmount;

        if (amountArgLower.endsWith('sol')) {
            parsedAmount = parseFloat(amountArgLower.replace('sol', '').trim());
            if (isNaN(parsedAmount)) throw new Error("Invalid SOL amount.");
            amountToGrantLamports = BigInt(Math.floor(parsedAmount * Number(LAMPORTS_PER_SOL)));
        } else if (amountArgLower.endsWith('lamports')) {
            const lamportsStr = amountArgLower.replace('lamports','').trim();
            try {
                amountToGrantLamports = BigInt(lamportsStr);
            } catch (bigIntError){
                 throw new Error("Invalid lamports amount: not a whole number.");
            }
        } else {
            try {
                parsedAmount = parseFloat(amountArg);
                if (isNaN(parsedAmount)) throw new Error("Invalid numeric amount.");
                if (String(amountArg).includes('.') || (Number.isInteger(parsedAmount) && Math.abs(parsedAmount) < 1000000) ) {
                    amountToGrantLamports = BigInt(Math.floor(parsedAmount * Number(LAMPORTS_PER_SOL)));
                } else {
                    amountToGrantLamports = BigInt(amountArg);
                }
            } catch (e) {
                 throw new Error("Could not parse grant amount. Use SOL (e.g., 10 or 10.5 sol) or lamports (e.g., 10000000 lamports).");
            }
        }

        if (isNaN(Number(amountToGrantLamports))) throw new Error("Could not resolve grant amount to a valid number of lamports.");

    } catch (e) {
        await safeSendMessage(chatId, `⚠️ **Grant Parameter Error:**\n${escapeMarkdownV2(e.message)}`, { parse_mode: 'MarkdownV2' });
        return;
    }

    let grantClient = null;
    try {
        grantClient = await pool.connect();
        await grantClient.query('BEGIN');

        if (typeof updateUserBalanceAndLedger !== 'function') {
            console.error(`${LOG_PREFIX_GRANT} FATAL: updateUserBalanceAndLedger is undefined for grant.`);
            await safeSendMessage(chatId, "🛠️ **Internal System Error:** Grant functionality is offline. Core balance function missing.", { parse_mode: 'MarkdownV2' });    
            await grantClient.query('ROLLBACK'); return;
        }
        const transactionType = amountToGrantLamports >= 0n ? 'admin_grant_credit' : 'admin_grant_debit';
        const grantNotes = `Admin Action: ${reason}. By: ${adminUserObj.username || adminUserIdStr} (${adminUserIdStr}). To: ${targetUser.username || targetUser.telegram_id} (${targetUser.telegram_id}). Amount: ${formatCurrency(amountToGrantLamports, 'SOL')}`;
        
        const grantResult = await updateUserBalanceAndLedger(
            grantClient, targetUser.telegram_id, amountToGrantLamports, transactionType, {}, grantNotes
        );

        if (grantResult.success) {
            await grantClient.query('COMMIT');
            const grantAmountDisplay = escapeMarkdownV2(formatCurrency(amountToGrantLamports, 'SOL'));
            const newBalanceDisplay = escapeMarkdownV2(await formatBalanceForDisplay(grantResult.newBalanceLamports, 'USD')); 
            const targetUserDisplay = getPlayerDisplayReference(targetUser); 
            const verb = amountToGrantLamports >= 0n ? "credited to" : "debited from";

            await safeSendMessage(chatId, `✅ **Admin Action Successful!**\n*${grantAmountDisplay}* has been ${verb} ${targetUserDisplay} (ID: \`${targetUser.telegram_id}\`).\nNew balance for user: *${newBalanceDisplay}*.`, { parse_mode: 'MarkdownV2' });    
            
            const userNotifText = amountToGrantLamports >= 0n
                ? `🎉 Good news! You have received an admin credit of *${grantAmountDisplay}* from the Casino Royale team! Your new balance is *${newBalanceDisplay}*. Reason: _${escapeMarkdownV2(reason)}_`
                : `⚖️ Admin Adjustment: Your account has been debited by *${grantAmountDisplay}* by the Casino Royale team. Your new balance is *${newBalanceDisplay}*. Reason: _${escapeMarkdownV2(reason)}_`;
            await safeSendMessage(targetUser.telegram_id, userNotifText, { parse_mode: 'MarkdownV2' });
        } else {
            await grantClient.query('ROLLBACK');
            await safeSendMessage(chatId, `❌ **Admin Action Failed:** Failed to ${amountToGrantLamports >= 0n ? 'credit' : 'debit'} funds. Reason: \`${escapeMarkdownV2(grantResult.error || "Unknown balance update error.")}\``, { parse_mode: 'MarkdownV2' });    
        }
    } catch (grantError) {
        if (grantClient) await grantClient.query('ROLLBACK').catch(() => {});
        console.error(`${LOG_PREFIX_GRANT} Admin Grant DB Transaction Error: ${grantError.message}`, grantError.stack?.substring(0,500));
        await safeSendMessage(chatId, `❌ **Database Error During Grant:** \`${escapeMarkdownV2(grantError.message)}\`. The action was not completed.`, { parse_mode: 'MarkdownV2' });    
    } finally {
        if (grantClient) grantClient.release();
    }
}

// --- NEW Command Handler for /bonus (Place in Part 5a, Section 2) ---

// REVISED handleBonusCommand function (to be placed in Part 5a, Section 2)

async function handleBonusCommand(msg) {
    const userId = String(msg.from.id || msg.from.telegram_id);
    const chatId = String(msg.chat.id);
    const chatType = msg.chat.type;
    const LOG_PREFIX_BONUS_CMD = `[BonusCmd_V6_SyntaxReview UID:${userId} CH:${chatId} Type:${chatType}]`; // V6

    let userObject = await getOrCreateUser(userId, msg.from.username, msg.from.first_name, msg.from.last_name);
    if (!userObject) {
        await safeSendMessage(chatId, "Error fetching your player profile. Please try `/start` again.", { parse_mode: 'MarkdownV2' });
        return;
    }
    const playerRefHTML = escapeHTML(getPlayerDisplayReference(userObject)); 

    let botUsername = BOT_NAME || "our_bot"; 
    try {
        const selfInfo = await bot.getMe();
        if (selfInfo.username) botUsername = selfInfo.username;
    } catch (e) { console.warn(`${LOG_PREFIX_BONUS_CMD} Could not fetch bot username: ${e.message}`); }

    // --- Group Chat Logic ---
    if (chatType === 'group' || chatType === 'supergroup') {
        if (msg.message_id && msg.text && msg.text.startsWith('/bonus') ) { 
            await bot.deleteMessage(chatId, msg.message_id).catch(() => {});
        }

        let client = null;
        try {
            client = await pool.connect();
            
            // Fetch necessary data for group message
            const currentUserDetailsQueryGroup = `
                SELECT u.total_wagered_lamports, ul.order_index AS current_level_order_index, ul.level_name as current_level_name
                FROM users u
                LEFT JOIN user_levels ul ON u.current_level_id = ul.level_id
                WHERE u.telegram_id = $1`;
            const currentUserDetailsResGroup = await client.query(currentUserDetailsQueryGroup, [userId]);
            if (currentUserDetailsResGroup.rowCount === 0) throw new Error("User not found for group bonus info.");
            
            const currentUserDataGroup = currentUserDetailsResGroup.rows[0];
            const totalWageredLamportsGroup = BigInt(currentUserDataGroup.total_wagered_lamports || '0');
            const currentLevelOrderIndexGroup = currentUserDataGroup.current_level_order_index || 0;
            const currentLevelNameGroup = currentUserDataGroup.current_level_name || "Newcomer";

            const solPriceGroup = await getSolUsdPrice();
            const totalWageredUSDGroup = Number(totalWageredLamportsGroup) / Number(LAMPORTS_PER_SOL) * solPriceGroup;

            const nextLevelQueryGroup = `
                SELECT level_name, wager_threshold_usd, bonus_amount_usd 
                FROM user_levels 
                WHERE order_index > $1 ORDER BY order_index ASC LIMIT 1`;
            const nextLevelResGroup = await client.query(nextLevelQueryGroup, [currentLevelOrderIndexGroup]);
            const nextLevelDataGroup = nextLevelResGroup.rows.length > 0 ? nextLevelResGroup.rows[0] : null;

            let wagerNeededUSDText = "🏅 You've reached the highest tier! Congratulations!";
            if (nextLevelDataGroup) {
                const nextLevelThresholdUSD = parseFloat(nextLevelDataGroup.wager_threshold_usd);
                const wagerNeededUSD = Math.max(0, nextLevelThresholdUSD - totalWageredUSDGroup);
                const nextLevelBonusUSD = parseFloat(nextLevelDataGroup.bonus_amount_usd).toFixed(2);
                wagerNeededUSDText = `🎯 Next Tier: <b>${escapeHTML(nextLevelDataGroup.level_name)}</b>. Wager ~<b>$${wagerNeededUSD.toFixed(2)} USD</b> more (Bonus: ~$${nextLevelBonusUSD}!)`;
            }

            const claimableBonusQueryGroup = `
                SELECT ul.level_id, ul.bonus_amount_usd, ul.level_name
                FROM user_levels ul
                WHERE ul.order_index <= $1 
                AND ul.bonus_amount_usd > 0
                AND NOT EXISTS (
                    SELECT 1 FROM user_claimed_level_bonuses uclb
                    WHERE uclb.user_telegram_id = $2 AND uclb.level_id = ul.level_id
                ) ORDER BY ul.order_index ASC LIMIT 1;`;
            const claimableBonusResGroup = await client.query(claimableBonusQueryGroup, [currentLevelOrderIndexGroup, userId]);
            const nextClaimableBonusGroup = claimableBonusResGroup.rows.length > 0 ? claimableBonusResGroup.rows[0] : null;

            let groupBonusMessageHTML = `✨ <b>${playerRefHTML}'s Bonus Check</b> ✨\n\n` +
                                       `🏆 Current Tier: <b>${escapeHTML(currentLevelNameGroup)}</b>\n` +
                                       `${wagerNeededUSDText}\n\n`;
            
            let buttonText = "💰 My Bonus Dashboard (DM)";
            if (nextClaimableBonusGroup) {
                const bonusAmountToClaimUSD = parseFloat(nextClaimableBonusGroup.bonus_amount_usd).toFixed(2);
                groupBonusMessageHTML += `🎉 Bonus available! Check DMs with @${escapeHTML(botUsername)} to claim.`;
                buttonText = `🎁 Claim ~$${bonusAmountToClaimUSD} Bonus (DM)`;
            } else {
                groupBonusMessageHTML += `💡 No new bonuses ready to claim right now. Keep playing!`;
            }

            const groupKeyboard = {
                inline_keyboard: [
                    [{ text: buttonText, url: `https://t.me/${botUsername}?start=menu_bonus_dashboard_back` }]
                ]
            };
            await safeSendMessage(chatId, groupBonusMessageHTML, { parse_mode: 'HTML', reply_markup: groupKeyboard });

        } catch (error) {
            console.error(`${LOG_PREFIX_BONUS_CMD} Error generating group bonus message: ${error.message}`, error.stack);
            await safeSendMessage(chatId, `${playerRefHTML}, sorry, I couldn't fetch your bonus quick view. Please try again or check your DM with @${escapeHTML(botUsername)}.`, { parse_mode: 'HTML' });
        } finally {
            if (client) client.release();
        }
        return; 
    }

    // --- Private Chat (DM) Logic ---
    let workingMessageId = msg.message_id; 
    const isEditingExistingDashboard = msg.message_id && msg.isCallbackEditing === true;

    if (!isEditingExistingDashboard && msg.message_id && msg.text && msg.text.startsWith('/bonus')) {
        await bot.deleteMessage(chatId, msg.message_id).catch(() => {});
        workingMessageId = null; 
    }
    
    if (workingMessageId) { 
        try {
            await bot.editMessageText("⏳ Fetching your Level Up Bonus status...", {
                chat_id: chatId, message_id: Number(workingMessageId),
                parse_mode: 'HTML', reply_markup: { inline_keyboard: [] }
            });
        } catch (editError) {
            console.warn(`${LOG_PREFIX_BONUS_CMD} Failed to edit message ${workingMessageId} to 'Loading...'. Error: ${editError.message}. Will send new message.`);
            workingMessageId = null; 
        }
    }
    
    if (!workingMessageId) { 
        const loadingMsg = await safeSendMessage(chatId, "⏳ Fetching your Level Up Bonus status...", { parse_mode: 'HTML' });
        workingMessageId = loadingMsg?.message_id;
    }

    if (!workingMessageId) {
        console.error(`${LOG_PREFIX_BONUS_CMD} Failed to establish a message context for DM bonus display.`);
        await safeSendMessage(chatId, "Sorry, there was an issue loading your bonus dashboard. Please try again.", {parse_mode: 'HTML'});
        return;
    }

    let clientDm = null; 
    try {
        clientDm = await pool.connect();
        let messageTextHTML = `🌟 <b>Level Up Bonus Dashboard</b> 🌟\n\nHi ${playerRefHTML}! Play games, boost your wagers, and climb the ranks to unlock awesome level-up bonuses!\n\n`;
        const keyboardRows = [];

        const currentUserDetailsQueryDm = `
            SELECT u.total_wagered_lamports, u.current_level_id, 
                   ul.level_name AS current_level_name, 
                   ul.wager_threshold_usd AS current_level_threshold_usd, 
                   ul.order_index AS current_level_order_index
            FROM users u
            LEFT JOIN user_levels ul ON u.current_level_id = ul.level_id
            WHERE u.telegram_id = $1`;
        const currentUserDetailsDm = await clientDm.query(currentUserDetailsQueryDm, [userId]);

        if (currentUserDetailsDm.rowCount === 0) {
            throw new Error("User profile not found in database for bonus check.");
        }

        const userDataDm = currentUserDetailsDm.rows[0];
        const totalWageredLamportsDm = BigInt(userDataDm.total_wagered_lamports || '0');
        const solPriceDm = await getSolUsdPrice();
        const totalWageredUSDDm = Number(totalWageredLamportsDm) / Number(LAMPORTS_PER_SOL) * solPriceDm;
        const currentLevelNameDm = userDataDm.current_level_name || "Newcomer";
        const currentLevelOrderIndexDm = userDataDm.current_level_order_index || 0;
        
        messageTextHTML += `🏆 Your Current Tier: <b>${escapeHTML(currentLevelNameDm)}</b>\n` +
                             `💰 Total Wagered: ~<b>${escapeHTML(await formatBalanceForDisplay(totalWageredLamportsDm, 'USD'))}</b>\n\n`;

        const nextLevelDataQueryDm = `
            SELECT level_name, wager_threshold_usd, bonus_amount_usd 
            FROM user_levels
            WHERE order_index > $1 ORDER BY order_index ASC LIMIT 1`;
        const nextLevelDataDm = await clientDm.query(nextLevelDataQueryDm, [currentLevelOrderIndexDm]);

        if (nextLevelDataDm.rowCount > 0) {
            const nl = nextLevelDataDm.rows[0];
            const nextLevelThresholdUSD = parseFloat(nl.wager_threshold_usd);
            const wagerNeededUSD = Math.max(0, nextLevelThresholdUSD - totalWageredUSDDm);
            const nextBonusUSD = parseFloat(nl.bonus_amount_usd).toFixed(2);
            messageTextHTML += `🏅 Next Tier: <b>${escapeHTML(nl.level_name)}</b>\n` +
                                 `🎯 Wager <b>$${wagerNeededUSD.toFixed(2)} USD</b> more to reach it and unlock a bonus of approx. <b>$${nextBonusUSD} USD</b>!\n\n`;
        } else {
            messageTextHTML += `🏅 You've reached the Highest Tier! Truly a casino legend! Congratulations!\n\n`;
        }
        
        const claimableBonusesQueryDm = `
            SELECT ul.level_id, ul.level_name, ul.bonus_amount_usd, ul.order_index 
            FROM user_levels ul
            WHERE ul.order_index <= $1 AND ul.bonus_amount_usd > 0 
            AND NOT EXISTS (
                SELECT 1 FROM user_claimed_level_bonuses uclb
                WHERE uclb.user_telegram_id = $2 AND uclb.level_id = ul.level_id
            ) ORDER BY ul.order_index ASC`;
        const claimableBonusesResDm = await clientDm.query(claimableBonusesQueryDm, [currentLevelOrderIndexDm, userId]);

        if (claimableBonusesResDm.rows.length > 0) {
            messageTextHTML += "✨ <b>Available Tier Bonuses to Claim:</b>\n";
            claimableBonusesResDm.rows.forEach(bonus => {
                const bonusAmountToClaimUSD = parseFloat(bonus.bonus_amount_usd).toFixed(2);
                messageTextHTML += `  ▫️ <b>${escapeHTML(bonus.level_name)}</b> - Bonus: approx. <b>$${bonusAmountToClaimUSD} USD</b>\n`;
                keyboardRows.push([{ text: `💰 Claim $${bonusAmountToClaimUSD} (${escapeHTML(bonus.level_name)})`, callback_data: `claim_level_bonus:${bonus.level_id}` }]);
            });
            messageTextHTML += "\n";
        } else {
            messageTextHTML += "✅ No new tier bonuses available to claim at this moment.\n\n";
        }

        keyboardRows.push([{ text: "📜 View All Tiers & Rewards", callback_data: "menu:levels_info" }]);
        keyboardRows.push([{ text: "⬅️ Back to Main Menu", callback_data: "menu:main" }]);
        
        const keyboard = { inline_keyboard: keyboardRows };
        await bot.editMessageText(messageTextHTML, { 
            chat_id: chatId, 
            message_id: Number(workingMessageId), 
            parse_mode: 'HTML', 
            reply_markup: keyboard, 
            disable_web_page_preview: true 
        });
    } catch (error) {
        console.error(`${LOG_PREFIX_BONUS_CMD} Error displaying bonus dashboard (DM): ${error.message}`, error.stack);
        const errorText = `⚙️ Apologies, ${playerRefHTML}. We couldn't fetch your bonus information: ${escapeHTML(error.message.replace(/<br\s*\/?>/gi, '\n'))}`;
        const errorKbd = { inline_keyboard: [[{ text: "⬅️ Back to Main Menu", callback_data: "menu:main" }]] };
        await bot.editMessageText(errorText, { chat_id: chatId, message_id: Number(workingMessageId), parse_mode: 'HTML', reply_markup: errorKbd })
            .catch(async () => { 
                await safeSendMessage(chatId, errorText, { parse_mode: 'HTML', reply_markup: errorKbd });
            });
    } finally {
        if (clientDm) {
            clientDm.release();
        }
    }
}

// --- NEW Core Function to Handle Claiming a Level Up Bonus ---
// REVISED AND CORRECTED - handleClaimLevelBonus
// FINAL CORRECTED handleClaimLevelBonus
async function handleClaimLevelBonus(userId, levelIdToClaim, dbClient) {
    const LOG_PREFIX_HCLB_CORE = `[HandleClaimLevelBonusCore_V4_LockFix UID:${userId} LevelID:${levelIdToClaim}]`;

    try {
        // 1. Fetch details of the level being claimed first
        const levelToClaimRes = await dbClient.query(
            `SELECT level_id, level_name, bonus_amount_usd, order_index FROM user_levels WHERE level_id = $1`,
            [levelIdToClaim]
        );
        if (levelToClaimRes.rowCount === 0) {
            return { success: false, error: "Bonus level not found." };
        }
        const levelToClaimData = levelToClaimRes.rows[0];

        // 2. NOW, fetch and LOCK the user's record. This is the critical change to avoid the JOIN issue.
        const userRes = await dbClient.query(
            `SELECT current_level_id FROM users WHERE telegram_id = $1 FOR UPDATE`,
            [userId]
        );
        if (userRes.rowCount === 0) {
            return { success: false, error: "User not found." };
        }
        const userCurrentLevelId = userRes.rows[0].current_level_id;

        // 3. Get the order_index for the user's current level
        let currentUserLevelOrderIndex = 0;
        if (userCurrentLevelId) {
            const userLevelDetailsRes = await dbClient.query(`SELECT order_index FROM user_levels WHERE level_id = $1`, [userCurrentLevelId]);
            if (userLevelDetailsRes.rows.length > 0) {
                currentUserLevelOrderIndex = userLevelDetailsRes.rows[0].order_index;
            }
        }

        // 4. Perform validations
        if (currentUserLevelOrderIndex < levelToClaimData.order_index) {
            return { success: false, error: `You haven't reached ${escapeHTML(levelToClaimData.level_name)} yet.` };
        }

        // 5. Atomically INSERT to prevent race conditions.
        const insertRes = await dbClient.query(
            `INSERT INTO user_claimed_level_bonuses (user_telegram_id, level_id, notes)
             VALUES ($1, $2, 'Claimed by user') ON CONFLICT (user_telegram_id, level_id) DO NOTHING
             RETURNING claim_id;`,
            [userId, levelIdToClaim]
        );

        if (insertRes.rowCount === 0) {
            return { success: false, error: `You've already claimed the bonus for ${escapeHTML(levelToClaimData.level_name)}.` };
        }
        const claimId = insertRes.rows[0].claim_id;

        // 6. If insert was successful, proceed with crediting the user's balance
        const bonusAmountUSD = parseFloat(levelToClaimData.bonus_amount_usd);
        if (bonusAmountUSD <= 0) {
             return { success: true, messageForUser: `Bonus for ${escapeHTML(levelToClaimData.level_name)} recorded (0 value).` };
        }
        
        const solPrice = await getSolUsdPrice();
        const bonusAmountLamports = convertUSDToLamports(bonusAmountUSD, solPrice);
        
        const ledgerNotes = `Level Up Bonus: ${levelToClaimData.level_name} ($${bonusAmountUSD.toFixed(2)})`;
        const creditResult = await updateUserBalanceAndLedger(
            dbClient, userId, bonusAmountLamports,
            'level_up_bonus_claimed',
            { custom_level_id: levelIdToClaim, custom_level_name: levelToClaimData.level_name, custom_claim_id: claimId },
            ledgerNotes
        );

        if (!creditResult.success) {
            throw new Error(creditResult.error || "Failed to credit level up bonus to user balance.");
        }
        
        // 7. Update the claim record with the amount credited
        await dbClient.query(
            'UPDATE user_claimed_level_bonuses SET bonus_amount_claimed_lamports = $1 WHERE claim_id = $2',
            [bonusAmountLamports.toString(), claimId]
        );

        const bonusAmountUSDDisplay = escapeHTML((await formatBalanceForDisplay(bonusAmountLamports, 'USD')).replace(/[$#]/g, ''));
        return { success: true, messageForUser: `🎉 Bonus for ${escapeHTML(levelToClaimData.level_name)} (~${bonusAmountUSDDisplay}) claimed and added to your balance!` };

    } catch (error) {
        console.error(`${LOG_PREFIX_HCLB_CORE} Error claiming level bonus: ${error.message}`, error.stack);
        return { success: false, error: error.message || "Could not claim bonus due to a server error." };
    }
}

// Add this function to Part 5a, Section 2

// Add or replace this function in your code (e.g., in Part 5a, Section 2)
async function handleTipCommand(msg, args, senderUserObj) {
    const senderId = String(senderUserObj.telegram_id);
    const chatId = String(msg.chat.id);
    const logPrefix = `[TipCmd_V3_Fix UID:${senderId} CH:${chatId}]`;

    if (args.length < 2) {
        await safeSendMessage(chatId, "⚙️ <b>Tip Usage:</b> <code>/tip &lt;@username_or_ID&gt; &lt;amount&gt; [sol]</code>\nExample: <code>/tip @friend 5</code>", { parse_mode: 'HTML' });
        return;
    }

    const recipientIdentifier = args[0];
    const amountArg = args[1];
    const senderRefHTML = escapeHTML(getPlayerDisplayReference(senderUserObj));

    let tipAmountLamports;
    let recipientUser;

    // Phase 1: Validate Inputs
    try {
        recipientUser = await findRecipientUser(recipientIdentifier);
        if (!recipientUser) {
            throw new Error(`Player ${escapeHTML(recipientIdentifier)} not found.`);
        }
        if (String(recipientUser.telegram_id) === senderId) {
            throw new Error("You can't tip yourself!");
        }

        tipAmountLamports = await parseBetAmount(amountArg, chatId, msg.chat.type, senderId);
        if (!tipAmountLamports || tipAmountLamports <= 0n) {
            throw new Error("Invalid tip amount. Please provide a positive number.");
        }

        const senderBalance = BigInt(senderUserObj.balance);
        if (senderBalance < tipAmountLamports) {
            const balanceDisplay = escapeHTML(await formatBalanceForDisplay(senderBalance, 'USD'));
            const neededDisplay = escapeHTML(await formatBalanceForDisplay(tipAmountLamports - senderBalance, 'USD'));
            throw new Error(`Your balance of <b>${balanceDisplay}</b> is too low. You need ~<b>${neededDisplay}</b> more.`);
        }
    } catch (validationError) {
        await safeSendMessage(chatId, `⚠️ Oops, ${senderRefHTML}! Your tip failed.\n<b>Reason:</b> ${validationError.message}`, { parse_mode: 'HTML' });
        return;
    }
    
    // Phase 2: Perform DB Transaction
    let client = null;
    try {
        client = await pool.connect();
        await client.query('BEGIN');

        // To prevent deadlocks, always lock users in a consistent order (by ID)
        const [userA, userB] = [senderUserObj, recipientUser].sort((a, b) => String(a.telegram_id).localeCompare(String(b.telegram_id)));
        
        // Lock both user rows
        await client.query('SELECT 1 FROM users WHERE telegram_id = $1 FOR UPDATE', [userA.telegram_id]);
        // FIX IS HERE: Corrected the placeholder from $2 to $1
        await client.query('SELECT 1 FROM users WHERE telegram_id = $1 FOR UPDATE', [userB.telegram_id]);

        // Debit Sender
        const debitResult = await updateUserBalanceAndLedger(client, senderId, -tipAmountLamports, 'tip_sent', { opponent_id_custom_field: recipientUser.telegram_id }, `Tip to ${getPlayerDisplayReference(recipientUser)}`);
        if (!debitResult.success) throw new Error(`Failed to debit your account: ${debitResult.error}`);

        // Credit Recipient
        const creditResult = await updateUserBalanceAndLedger(client, recipientUser.telegram_id, tipAmountLamports, 'tip_received', { opponent_id_custom_field: senderId }, `Tip from ${getPlayerDisplayReference(senderUserObj)}`);
        if (!creditResult.success) throw new Error(`Failed to credit recipient's account: ${creditResult.error}`);

        await client.query('COMMIT');

    } catch (dbError) {
        if (client) await client.query('ROLLBACK');
        console.error(`${logPrefix} Error during DB transaction: ${dbError.message}`);
        await safeSendMessage(chatId, `⚙️ A database error occurred during the transfer. The transaction was automatically cancelled. Please try again.`, { parse_mode: 'HTML' });
        return; 
    } finally {
        if (client) client.release();
    }

    // Phase 3: Send Confirmation Messages (only runs if DB transaction was successful)
    try {
        const tipAmountDisplayHTML = escapeHTML(await formatBalanceForDisplay(tipAmountLamports, 'USD'));
        const recipientRefHTML = escapeHTML(getPlayerDisplayReference(recipientUser));

        await safeSendMessage(chatId, `✅ ${senderRefHTML} has successfully tipped <b>${tipAmountDisplayHTML}</b> to ${recipientRefHTML}!`, { parse_mode: 'HTML' });
        await safeSendMessage(recipientUser.telegram_id, `🎁 You received a tip of <b>${tipAmountDisplayHTML}</b> from ${senderRefHTML}! It has been added to your casino balance.`, { parse_mode: 'HTML' });

    } catch (messagingError) {
        console.error(`${logPrefix} Error sending confirmation messages after successful tip: ${messagingError.message}`);
        // The tip was successful, but the confirmation message failed. You could notify admin here if desired.
    }
}

// --- End of Part 5a, Section 2 ---
// --- Start of Part 5a, Section 4 (REVISED for New Dice Escalator UI & Simplified Post-Game Keyboard) ---
// index.js - Part 5a, Section 4: UI Helpers and Shared Utilities for General Commands & Simple Group Games
//----------------------------------------------------------------------------------------------------
// Assumed dependencies from previous Parts:
// Part 1: GAME_IDS (with new DE, CF, RPS IDs), QUICK_DEPOSIT_CALLBACK_ACTION, RULES_CALLBACK_PREFIX, escapeMarkdownV2
// Part 3: formatCurrency

// Note: `parseBetAmount` is a critical shared utility but is defined in Part 5a, Section 1.
// (Self-correction: parseBetAmount was actually in Original Part 5a, Section 1, which is being moved later.
// However, it's primarily used by the message command router which is also in Original Part 5a, Section 1.
// If any functions *before* Original Part 5a, Section 1 (in the new order) needed parseBetAmount, that would be an issue.
// A quick scan shows game start handlers receive betAmountLamports directly. parseBetAmount is used when commands like `/de <bet>` are parsed.
// So its placement within the later "Original Part 5a, Section 1" should be fine.)

/**
 * Creates a standardized inline keyboard for post-game actions.
 * Now only includes a "Quick Deposit" button.
 * @param {string} gameCode - The game identifier (e.g., GAME_IDS.COINFLIP, GAME_IDS.DICE_ESCALATOR_PVB). (Still passed but not used for button variety)
 * @param {bigint} betAmountLamports - The bet amount from the concluded game (passed but not used for button variety).
 * @returns {object} Telegram InlineKeyboardMarkup object.
 */
function createPostGameKeyboard(gameCode, betAmountLamports) {
    const keyboardRows = [
        [
            // Use the corrected constant name
            { text: "💸 Quick Deposit", callback_data: QUICK_DEPOSIT_CALLBACK_ACTION_CONST }
        ]
    ];

    return { inline_keyboard: keyboardRows };
}

/**
 * Creates a simple "Back to Menu X" inline keyboard.
 * @param {string} [menuTargetCallbackData='menu:main'] - The callback data for the menu button.
 * @param {string} [menuButtonText='🏛️ Back to Main Menu'] - Text for the menu button.
 * @returns {object} Telegram InlineKeyboardMarkup object.
 */
function createBackToMenuKeyboard(menuTargetCallbackData = 'menu:main', menuButtonText = '🏛️ Back to Main Menu') {
    return {
        inline_keyboard: [
            [{ text: escapeMarkdownV2(menuButtonText), callback_data: menuTargetCallbackData }]
        ]
    };
}

/**
 * Generates a standardized title string for game messages or UI sections.
 * @param {string} titleText The main text of the title.
 * @param {string} [emoji='✨'] Optional leading/trailing emoji.
 * @returns {string} MarkdownV2 formatted title string.
 */
function createStandardTitle(titleText, emoji = '✨') {
    return `${emoji} *${escapeMarkdownV2(titleText)}* ${emoji}`;
}

// console.log("Part 5a, Section 4 (REVISED for Simplified Post-Game Keyboard) - Complete.");
// --- End of Part 5a, Section 4 ---
// --- Start of Part 5a, Section 1 (CORRECTED - BOT_NAME & Play Again fixed - Core Listeners Setup - GRANULAR ACTIVE GAME LIMITS) ---
// index.js - Part 5a, Section 1: Core Listeners Setup (Message & Callback) and Populated Routers
// (This entire block should be placed LATE in your index.js, AFTER all game logic, general commands, and UI helpers, but BEFORE Part 6)
//----------------------------------------------------------------------------------------------

// Dependencies from previous Parts (assumed to be globally available or correctly imported)
// Part 1: isShuttingDown, userStateCache, COMMAND_COOLDOWN_MS, bot, getPlayerDisplayReference,
//         safeSendMessage, escapeMarkdownV2, escapeHTML, MIN_BET_USD_val, MAX_BET_USD_val, LAMPORTS_PER_SOL,
//         getSolUsdPrice, convertUSDToLamports, convertLamportsToUSDString, ADMIN_USER_ID, BOT_NAME, 
//         MIN_BET_AMOUNT_LAMPORTS_config, MAX_BET_AMOUNT_LAMPORTS_config, stringifyWithBigInt,
//         RULES_CALLBACK_PREFIX_CONST, DEPOSIT_CALLBACK_ACTION_CONST, WITHDRAW_CALLBACK_ACTION_CONST, QUICK_DEPOSIT_CALLBACK_ACTION_CONST,
//         userCooldowns, pool, activeGames, groupGameSessions, GAME_IDS,
//         UNIFIED_OFFER_TIMEOUT_MS, DIRECT_CHALLENGE_ACCEPT_TIMEOUT_MS, ACTIVE_GAME_TURN_TIMEOUT_MS, INSTANT_GAME_ACTION_TIMEOUT_MS, GAME_ACTIVITY_LIMITS,
//         checkUserActiveGameLimit 
// Part 2: getOrCreateUser, findRecipientUser
// Part 3: createUserMention, formatCurrency
// Part P3: clearUserState, routeStatefulInput, handleMenuAction, handleWithdrawalConfirmation
// Game Logic Parts (e.g., Part 5a-S3 for Coinflip/RPS, Part 5b-S1 for Dice Escalator): Game logic functions are defined *before* this section.
// Mines handlers like handleStartMinesCommand (from Part 5d) are defined before this.
// General command handlers (Part 5a, Section 2 - handleStartCommand, handleHelpCommand etc.) are defined before this.


// --- Helper to parse bet amount for game commands (USD primary) ---
const parseBetAmount = async (arg, commandInitiationChatId, commandInitiationChatType, userIdForLog = 'N/A') => {
    const LOG_PREFIX_PBA = `[ParseBet CH:${commandInitiationChatId} UID:${userIdForLog}]`;
    let betAmountLamports;
    let minBetLamports, maxBetLamports;
    let minBetDisplay, maxBetDisplay;
    let defaultBetDisplay;

    try {
        const solPrice = await getSolUsdPrice();

        minBetLamports = convertUSDToLamports(MIN_BET_USD_val, solPrice);
        maxBetLamports = convertUSDToLamports(MAX_BET_USD_val, solPrice);

        minBetDisplay = escapeMarkdownV2(convertLamportsToUSDString(minBetLamports, solPrice));
        maxBetDisplay = escapeMarkdownV2(convertLamportsToUSDString(maxBetLamports, solPrice));
        defaultBetDisplay = minBetDisplay;

        if (!arg || String(arg).trim() === "") {
            betAmountLamports = minBetLamports;
            return betAmountLamports;
        } else {
            const argStr = String(arg).trim().toLowerCase();
            let isExplicitSol = argStr.endsWith('sol');
            let isExplicitLamports = argStr.endsWith('lamports');
            let potentialNumberPart = argStr.replace('sol', '').replace('lamports', '').trim();
            let parsedValueFloat = parseFloat(potentialNumberPart);
            let parsedValueBigInt = null;
            try { parsedValueBigInt = BigInt(potentialNumberPart); } catch {}

            if (isExplicitSol) {
                if (isNaN(parsedValueFloat) || parsedValueFloat <= 0) throw new Error("Invalid amount for 'sol' suffix.");
                betAmountLamports = BigInt(Math.floor(parsedValueFloat * Number(LAMPORTS_PER_SOL)));
                const equivalentUsdValue = parsedValueFloat * solPrice;
                if (equivalentUsdValue < MIN_BET_USD_val || equivalentUsdValue > MAX_BET_USD_val) {
                    const betInSOLDisplayDynamic = escapeMarkdownV2(formatCurrency(betAmountLamports, 'SOL'));
                    const message = `⚠️ Your bet of *${betInSOLDisplayDynamic}* (approx. ${escapeMarkdownV2(convertLamportsToUSDString(betAmountLamports, solPrice))}) is outside current USD limits (*${minBetDisplay}* - *${maxBetDisplay}*). Your bet is set to the minimum: *${defaultBetDisplay}*.`;
                    await safeSendMessage(commandInitiationChatId, message, { parse_mode: 'MarkdownV2' });
                    betAmountLamports = minBetLamports;
                }
            } else if (isExplicitLamports) {
                if (parsedValueBigInt === null || parsedValueBigInt <= 0n) throw new Error("Invalid amount for 'lamports' suffix.");
                betAmountLamports = parsedValueBigInt;
                const equivalentUsdValue = Number(betAmountLamports) / Number(LAMPORTS_PER_SOL) * solPrice;
                if (equivalentUsdValue < MIN_BET_USD_val || equivalentUsdValue > MAX_BET_USD_val) {
                    const betInLamportsDisplay = escapeMarkdownV2(formatCurrency(betAmountLamports, 'lamports', true));
                    const message = `⚠️ Your bet of *${betInLamportsDisplay}* (approx. ${escapeMarkdownV2(convertLamportsToUSDString(betAmountLamports, solPrice))}) is outside current USD limits (*${minBetDisplay}* - *${maxBetDisplay}*). Your bet is set to the minimum: *${defaultBetDisplay}*.`;
                    await safeSendMessage(commandInitiationChatId, message, { parse_mode: 'MarkdownV2' });
                    betAmountLamports = minBetLamports;
                }
            } else {
                if (!isNaN(parsedValueFloat) && parsedValueFloat > 0) {
                    const usdThreshold = MAX_BET_USD_val * 1.5; 

                    if ( (argStr.includes('.')) || (!argStr.includes('.') && parsedValueFloat <= usdThreshold && parsedValueFloat >= MIN_BET_USD_val) ) {
                        let usdAmountToConvert = parsedValueFloat;
                        betAmountLamports = convertUSDToLamports(usdAmountToConvert, solPrice);

                        if (usdAmountToConvert < MIN_BET_USD_val || usdAmountToConvert > MAX_BET_USD_val) {
                            const betUsdDisplay = escapeMarkdownV2(usdAmountToConvert.toFixed(2));
                            const message = `⚠️ Your bet of *${betUsdDisplay} USD* is outside the allowed limits: *${minBetDisplay}* - *${maxBetDisplay}*. Your bet has been adjusted to the minimum: *${defaultBetDisplay}*.`;
                            await safeSendMessage(commandInitiationChatId, message, { parse_mode: 'MarkdownV2' });
                            betAmountLamports = minBetLamports;
                        }
                    } else {
                        if (parsedValueBigInt !== null && parsedValueBigInt > 0n) {
                            betAmountLamports = parsedValueBigInt;
                            const equivalentUsdValue = Number(betAmountLamports) / Number(LAMPORTS_PER_SOL) * solPrice;

                            if (betAmountLamports === minBetLamports) { 
                            } else if (betAmountLamports === maxBetLamports) {
                            } else if (equivalentUsdValue < MIN_BET_USD_val || equivalentUsdValue > MAX_BET_USD_val) {
                                const betInSOLDisplayDynamic = escapeMarkdownV2(formatCurrency(betAmountLamports, 'SOL'));
                                let adjustmentMessage;
                                if (equivalentUsdValue < MIN_BET_USD_val) {
                                    adjustmentMessage = `⚠️ Your bet of *${betInSOLDisplayDynamic}* (approx. ${escapeMarkdownV2(convertLamportsToUSDString(betAmountLamports, solPrice))}) is below the minimum limit of *${minBetDisplay}*. Adjusted to minimum.`;
                                    betAmountLamports = minBetLamports;
                                } else { // equivalentUsdValue > MAX_BET_USD_val
                                    adjustmentMessage = `⚠️ Your bet of *${betInSOLDisplayDynamic}* (approx. ${escapeMarkdownV2(convertLamportsToUSDString(betAmountLamports, solPrice))}) exceeds the maximum limit of *${maxBetDisplay}*. Adjusted to maximum.`;
                                    betAmountLamports = maxBetLamports;
                                }
                                await safeSendMessage(commandInitiationChatId, adjustmentMessage, { parse_mode: 'MarkdownV2' });
                            }
                        } else {
                            throw new Error("Invalid numeric bet value provided (large integer path).");
                        }
                    }
                } else {
                    throw new Error("Could not parse bet amount. Use numbers, or 'sol'/'lamports' suffix.");
                }
            }
        }

        const effectiveMinLamportsSystem = MIN_BET_AMOUNT_LAMPORTS_config;
        const effectiveMaxLamportsSystem = MAX_BET_AMOUNT_LAMPORTS_config;

        if (betAmountLamports === minBetLamports) {
            if (betAmountLamports > effectiveMaxLamportsSystem) {
                const adjustedMaxDisplaySystem = await formatBalanceForDisplay(effectiveMaxLamportsSystem, 'USD', solPrice);
                console.warn(`${LOG_PREFIX_PBA} minBetLamports (${formatCurrency(betAmountLamports)}) somehow exceeds effectiveMaxLamportsSystem (${formatCurrency(effectiveMaxLamportsSystem)}). Clamping to system max.`);
                await safeSendMessage(commandInitiationChatId, `ℹ️ Your $${MIN_BET_USD_val.toFixed(2)} bet (converted to lamports) unusually exceeded the system's absolute maximum. Adjusted to *${escapeMarkdownV2(adjustedMaxDisplaySystem)}*.`, { parse_mode: 'MarkdownV2' });
                return effectiveMaxLamportsSystem;
            }
            if (betAmountLamports < effectiveMinLamportsSystem) {
                console.warn(`${LOG_PREFIX_PBA} minBetLamports derived from USD (${formatCurrency(betAmountLamports)}) is less than absolute system min (${formatCurrency(effectiveMinLamportsSystem)}). Using system min.`);
                return effectiveMinLamportsSystem;
            }
            return betAmountLamports; 
        }

        if (betAmountLamports < effectiveMinLamportsSystem) {
            const adjustedMinDisplaySystem = await formatBalanceForDisplay(effectiveMinLamportsSystem, 'USD', solPrice);
            console.warn(`${LOG_PREFIX_PBA} Bet ${formatCurrency(betAmountLamports)} is BELOW absolute system lamport limit ${formatCurrency(effectiveMinLamportsSystem)}. Adjusting to ${escapeMarkdownV2(adjustedMinDisplaySystem)}.`);
            await safeSendMessage(commandInitiationChatId, `ℹ️ Your specified bet was below the system's absolute minimum value and has been adjusted to *${escapeMarkdownV2(adjustedMinDisplaySystem)}*.`, { parse_mode: 'MarkdownV2' });
            return effectiveMinLamportsSystem;
        }
        if (betAmountLamports > effectiveMaxLamportsSystem) {
            if (betAmountLamports === maxBetLamports) {
                if (betAmountLamports > effectiveMaxLamportsSystem) {
                    console.warn(`${LOG_PREFIX_PBA} maxBetLamports derived from USD (${formatCurrency(betAmountLamports)}) is greater than absolute system max (${formatCurrency(effectiveMaxLamportsSystem)}). Using system max.`);
                    return effectiveMaxLamportsSystem;
                }
                return betAmountLamports;
            } else { 
                const adjustedMaxDisplaySystem = await formatBalanceForDisplay(effectiveMaxLamportsSystem, 'USD', solPrice);
                console.warn(`${LOG_PREFIX_PBA} Bet ${formatCurrency(betAmountLamports)} is ABOVE absolute system lamport limit ${formatCurrency(effectiveMaxLamportsSystem)}. Adjusting to ${escapeMarkdownV2(adjustedMaxDisplaySystem)}.`);
                await safeSendMessage(commandInitiationChatId, `ℹ️ Your specified bet exceeded the system's absolute maximum value and has been adjusted to *${escapeMarkdownV2(adjustedMaxDisplaySystem)}*.`, { parse_mode: 'MarkdownV2' });
                return effectiveMaxLamportsSystem;
            }
        }
        return betAmountLamports;

    } catch (priceError) { 
        console.error(`${LOG_PREFIX_PBA} CRITICAL error during bet parsing (e.g. SOL price unavailable): ${priceError.message}`);
        const minLamportsFallbackDisplay = escapeMarkdownV2(formatCurrency(MIN_BET_AMOUNT_LAMPORTS_config, 'SOL'));
        const message = `⚙️ Apologies, we couldn't determine current bet limits due to a price feed issue. Your bet has been set to the internal minimum of *${minLamportsFallbackDisplay}*.`;
        await safeSendMessage(commandInitiationChatId, message, { parse_mode: 'MarkdownV2' });

        try {
            if (!arg || String(arg).trim() === "") return MIN_BET_AMOUNT_LAMPORTS_config;
            let fallbackAmountLamports;
            const argStrFB = String(arg).trim().toLowerCase();
            if (argStrFB.endsWith('sol')) {
                const solValFB = parseFloat(argStrFB.replace('sol', '').trim());
                if (isNaN(solValFB) || solValFB <=0) return MIN_BET_AMOUNT_LAMPORTS_config;
                fallbackAmountLamports = BigInt(Math.floor(solValFB * Number(LAMPORTS_PER_SOL)));
            } else if (argStrFB.endsWith('lamports')) {
                const lampValFB = BigInt(argStrFB.replace('lamports','').trim());
                if (lampValFB <= 0n) return MIN_BET_AMOUNT_LAMPORTS_config;
                fallbackAmountLamports = lampValFB;
            } else {
                try {
                    const numValFB = BigInt(argStrFB);
                    if (numValFB <=0n) return MIN_BET_AMOUNT_LAMPORTS_config;
                    fallbackAmountLamports = numValFB;
                } catch (e) {
                    return MIN_BET_AMOUNT_LAMPORTS_config; 
                }
            }
            if (fallbackAmountLamports < MIN_BET_AMOUNT_LAMPORTS_config) return MIN_BET_AMOUNT_LAMPORTS_config;
            if (fallbackAmountLamports > MAX_BET_AMOUNT_LAMPORTS_config) return MAX_BET_AMOUNT_LAMPORTS_config;
            return fallbackAmountLamports;
        } catch {
            return MIN_BET_AMOUNT_LAMPORTS_config;
        }
    }
};

// --- Definitions of Callback Forwarding Helper Functions (Play Again cases REMOVED) ---
async function forwardCoinflipRPSCallback(action, params, userObject, originalMessageId, originalChatId, originalChatType, callbackQueryId) {
    const LOG_PREFIX_CF_RPS_CB_FWD = `[CF_RPS_CB_Fwd UID:${userObject.telegram_id || userObject.id} Act:${action}]`;
    const offerIdOrGameId = params[0];
    const choiceOrPlayerId = params[1];
    const actualChoice = params[2];

    switch (action) {
        case 'cf_accept_bot':
            if (!offerIdOrGameId) { console.error(`${LOG_PREFIX_CF_RPS_CB_FWD} Missing offerId for cf_accept_bot.`); return; }
            if (typeof handleCoinflipAcceptBotGameCallback === 'function') await handleCoinflipAcceptBotGameCallback(offerIdOrGameId, userObject, originalMessageId, originalChatId, originalChatType, callbackQueryId);
            else console.error(`${LOG_PREFIX_CF_RPS_CB_FWD} Missing handler: handleCoinflipAcceptBotGameCallback`);
            break;
        case 'cf_accept_pvp':
            if (!offerIdOrGameId) { console.error(`${LOG_PREFIX_CF_RPS_CB_FWD} Missing offerId for cf_accept_pvp.`); return; }
            if (typeof handleCoinflipAcceptPvPChallengeCallback === 'function') await handleCoinflipAcceptPvPChallengeCallback(offerIdOrGameId, userObject, originalMessageId, originalChatId, originalChatType, callbackQueryId);
            else console.error(`${LOG_PREFIX_CF_RPS_CB_FWD} Missing handler: handleCoinflipAcceptPvPChallengeCallback`);
            break;
        case 'cf_cancel_offer':
            if (!offerIdOrGameId) { console.error(`${LOG_PREFIX_CF_RPS_CB_FWD} Missing offerId for cf_cancel_offer.`); return; }
            if (typeof handleCoinflipCancelOfferCallback === 'function') await handleCoinflipCancelOfferCallback(offerIdOrGameId, userObject, originalMessageId, originalChatId, callbackQueryId);
            else console.error(`${LOG_PREFIX_CF_RPS_CB_FWD} Missing handler: handleCoinflipCancelOfferCallback`);
            break;
        case 'cf_pvb_choice':
            const playerChoiceCF = choiceOrPlayerId;
            if (!offerIdOrGameId || !playerChoiceCF) { console.error(`${LOG_PREFIX_CF_RPS_CB_FWD} Missing gameId or choice for cf_pvb_choice.`); return; }
            if (typeof handleCoinflipPvBChoiceCallback === 'function') await handleCoinflipPvBChoiceCallback(offerIdOrGameId, playerChoiceCF, userObject, originalMessageId, callbackQueryId);
            else console.error(`${LOG_PREFIX_CF_RPS_CB_FWD} Missing handler: handleCoinflipPvBChoiceCallback`);
            break;
        case 'cf_pvp_call':
            const callerIdCheckCF = choiceOrPlayerId;
            const callChoiceCF = actualChoice;
            if (!offerIdOrGameId || !callerIdCheckCF || !callChoiceCF) { console.error(`${LOG_PREFIX_CF_RPS_CB_FWD} Missing params for cf_pvp_call.`); return; }
            if (typeof handleCoinflipPvPCallCallback === 'function') await handleCoinflipPvPCallCallback(offerIdOrGameId, callerIdCheckCF, callChoiceCF, userObject, originalMessageId, callbackQueryId);
            else console.error(`${LOG_PREFIX_CF_RPS_CB_FWD} Missing handler: handleCoinflipPvPCallCallback`);
            break;
        case 'rps_accept_bot':
            if (!offerIdOrGameId) { console.error(`${LOG_PREFIX_CF_RPS_CB_FWD} Missing offerId for rps_accept_bot.`); return; }
            if (typeof handleRPSAcceptBotGameCallback === 'function') await handleRPSAcceptBotGameCallback(offerIdOrGameId, userObject, originalMessageId, originalChatId, originalChatType, callbackQueryId);
            else console.error(`${LOG_PREFIX_CF_RPS_CB_FWD} Missing handler: handleRPSAcceptBotGameCallback`);
            break;
        case 'rps_accept_pvp':
            if (!offerIdOrGameId) { console.error(`${LOG_PREFIX_CF_RPS_CB_FWD} Missing offerId for rps_accept_pvp.`); return; }
            if (typeof handleRPSAcceptPvPChallengeCallback === 'function') await handleRPSAcceptPvPChallengeCallback(offerIdOrGameId, userObject, originalMessageId, originalChatId, originalChatType, callbackQueryId);
            else console.error(`${LOG_PREFIX_CF_RPS_CB_FWD} Missing handler: handleRPSAcceptPvPChallengeCallback`);
            break;
        case 'rps_cancel_offer':
            if (!offerIdOrGameId) { console.error(`${LOG_PREFIX_CF_RPS_CB_FWD} Missing offerId for rps_cancel_offer.`); return; }
            if (typeof handleRPSCancelOfferCallback === 'function') await handleRPSCancelOfferCallback(offerIdOrGameId, userObject, originalMessageId, originalChatId, callbackQueryId);
            else console.error(`${LOG_PREFIX_CF_RPS_CB_FWD} Missing handler: handleRPSCancelOfferCallback`);
            break;
        case 'rps_pvb_choice':
            const playerChoiceRPS = choiceOrPlayerId;
            if (!offerIdOrGameId || !playerChoiceRPS) { console.error(`${LOG_PREFIX_CF_RPS_CB_FWD} Missing gameId or choiceKey for rps_pvb_choice.`); return; }
            if (typeof handleRPSPvBChoiceCallback === 'function') await handleRPSPvBChoiceCallback(offerIdOrGameId, playerChoiceRPS, userObject, originalMessageId, callbackQueryId);
            else console.error(`${LOG_PREFIX_CF_RPS_CB_FWD} Missing handler: handleRPSPvBChoiceCallback`);
            break;
        case 'rps_pvp_choice':
            const chooserIdRPS = choiceOrPlayerId;
            const choiceKeyRPS = actualChoice;
            if (!offerIdOrGameId || !chooserIdRPS || !choiceKeyRPS) { console.error(`${LOG_PREFIX_CF_RPS_CB_FWD} Missing params for rps_pvp_choice.`); return; }
            if (typeof handleRPSPvPChoiceCallback === 'function') await handleRPSPvPChoiceCallback(offerIdOrGameId, chooserIdRPS, choiceKeyRPS, userObject, originalMessageId, callbackQueryId);
            else console.error(`${LOG_PREFIX_CF_RPS_CB_FWD} Missing handler: handleRPSPvPChoiceCallback`);
            break;
        default:
            console.warn(`${LOG_PREFIX_CF_RPS_CB_FWD} Unhandled Coinflip/RPS action in forwarder: ${action}`);
            await bot.answerCallbackQuery(callbackQueryId, {text: "Unknown game action.", show_alert: false}).catch(()=>{});
            break;
    }
}

async function forwardGameCallback(action, params, userObject, originalMessageId, originalChatId, originalChatType, callbackQueryId) {
    const LOG_PREFIX_GAME_CB_FWD = `[GameCB_Fwd_Legacy UID:${userObject.telegram_id || userObject.id} Act:${action}]`;
    const gameIdOrBetAmountStr = params[0];

    switch (action) {
        case 'join_game':
        case 'cancel_game':
        case 'rps_choose':
            console.warn(`${LOG_PREFIX_GAME_CB_FWD} Legacy action '${action}' received. Ensure this path is still intended or remove.`);
            if (action === 'join_game' && typeof handleJoinGameCallback === 'function') await handleJoinGameCallback(originalChatId, userObject, gameIdOrBetAmountStr, originalMessageId, callbackQueryId, originalChatType);
            else if (action === 'cancel_game' && typeof handleCancelGameCallback === 'function') await handleCancelGameCallback(originalChatId, userObject, gameIdOrBetAmountStr, originalMessageId, callbackQueryId, originalChatType);
            else if (action === 'rps_choose' && typeof handleRPSChoiceCallback === 'function') await handleRPSChoiceCallback(originalChatId, userObject, params[0], params[1], originalMessageId, callbackQueryId, originalChatType);
            else console.error(`${LOG_PREFIX_GAME_CB_FWD} Missing legacy handler for ${action}`);
            break;
        default:
            console.warn(`${LOG_PREFIX_GAME_CB_FWD} Unhandled action in legacy forwardGameCallback: ${action}`);
            await bot.answerCallbackQuery(callbackQueryId, {text: "Unknown action.", show_alert: false}).catch(()=>{});
    }
}

async function forwardDiceEscalatorCallback_New(action, params, userObject, originalMessageId, originalChatId, originalChatType, callbackQueryId) {
    const LOG_PREFIX_DE_CB_FWD_NEW = `[DE_CB_Fwd_New UID:${userObject.telegram_id || userObject.id} Act:${action}]`;
    const gameIdOrOfferIdOrBet = params[0];

    switch (action) {
        case 'de_accept_bot_game':
            if (typeof handleDiceEscalatorAcceptBotGame_New === 'function') await handleDiceEscalatorAcceptBotGame_New(gameIdOrOfferIdOrBet, userObject, originalMessageId, originalChatId, originalChatType, callbackQueryId);
            else console.error(`${LOG_PREFIX_DE_CB_FWD_NEW} Missing handler: handleDiceEscalatorAcceptBotGame_New`);
            break;
        case 'de_accept_pvp_challenge':
            if (typeof handleDiceEscalatorAcceptPvPChallenge_New === 'function') await handleDiceEscalatorAcceptPvPChallenge_New(gameIdOrOfferIdOrBet, userObject, originalMessageId, originalChatId, originalChatType, callbackQueryId);
            else console.error(`${LOG_PREFIX_DE_CB_FWD_NEW} Missing handler: handleDiceEscalatorAcceptPvPChallenge_New`);
            break;
        case 'de_cancel_unified_offer':
            if (typeof handleDiceEscalatorCancelUnifiedOffer_New === 'function') await handleDiceEscalatorCancelUnifiedOffer_New(gameIdOrOfferIdOrBet, userObject, originalMessageId, originalChatId, callbackQueryId);
            else console.error(`${LOG_PREFIX_DE_CB_FWD_NEW} Missing handler: handleDiceEscalatorCancelUnifiedOffer_New`);
            break;
        case 'de_pvb_go_for_jackpot':
            if (typeof handleDEGoForJackpot === 'function') await handleDEGoForJackpot(gameIdOrOfferIdOrBet, userObject, originalMessageId, callbackQueryId, { id: originalChatId, type: originalChatType });
            else console.error(`${LOG_PREFIX_DE_CB_FWD_NEW} Missing handler: handleDEGoForJackpot`);
            break;
        case 'de_stand_pvb':
            if (typeof handleDiceEscalatorPvBStand_New === 'function') await handleDiceEscalatorPvBStand_New(gameIdOrOfferIdOrBet, userObject, originalMessageId, callbackQueryId, { id: originalChatId, type: originalChatType });
            else console.error(`${LOG_PREFIX_DE_CB_FWD_NEW} Missing handler: handleDiceEscalatorPvBStand_New`);
            break;
        case 'de_stand_pvp':
            if (typeof handleDiceEscalatorPvPStand_New === 'function') await handleDiceEscalatorPvPStand_New(gameIdOrOfferIdOrBet, userObject, originalMessageId, callbackQueryId, { id: originalChatId, type: originalChatType });
            else console.error(`${LOG_PREFIX_DE_CB_FWD_NEW} Missing handler: handleDiceEscalatorPvPStand_New`);
            break;
        default:
            await bot.answerCallbackQuery(callbackQueryId, {text: "Unknown DE action.", show_alert: false}).catch(()=>{});
    }
}

async function forwardDice21Callback(action, params, userObject, originalMessageId, originalChatId, originalChatType, callbackQueryId) {
    const LOG_PREFIX_D21_CB_FWD = `[D21_CB_Fwd UID:${userObject.telegram_id || userObject.id} Act:${action}]`;
    const gameIdOrBetAmountStr = params[0];
    const chatDataForHandler = { id: originalChatId, type: originalChatType };

    switch (action) {
        case 'd21_accept_bot_game':
            if (typeof handleDice21AcceptBotGame === 'function') await handleDice21AcceptBotGame(gameIdOrBetAmountStr, userObject, originalMessageId, originalChatId, originalChatType, callbackQueryId);
            else console.error(`${LOG_PREFIX_D21_CB_FWD} Missing handler: handleDice21AcceptBotGame`);
            break;
        case 'd21_accept_pvp_challenge':
            if (typeof handleDice21AcceptPvPChallenge === 'function') await handleDice21AcceptPvPChallenge(gameIdOrBetAmountStr, userObject, originalMessageId, originalChatId, originalChatType, callbackQueryId);
            else console.error(`${LOG_PREFIX_D21_CB_FWD} Missing handler: handleDice21AcceptPvPChallenge`);
            break;
        case 'd21_cancel_unified_offer':
            if (typeof handleDice21CancelUnifiedOffer === 'function') await handleDice21CancelUnifiedOffer(gameIdOrBetAmountStr, userObject, originalMessageId, originalChatId, callbackQueryId);
            else console.error(`${LOG_PREFIX_D21_CB_FWD} Missing handler: handleDice21CancelUnifiedOffer`);
            break;
        case 'd21_stand': 
            if (typeof handleDice21PvBStand === 'function') await handleDice21PvBStand(gameIdOrBetAmountStr, userObject, originalMessageId, callbackQueryId, chatDataForHandler);
            else console.error(`${LOG_PREFIX_D21_CB_FWD} Missing handler: handleDice21PvBStand`);
            break;
        case 'd21_pvb_cancel':
            if (typeof handleDice21PvBCancel === 'function') await handleDice21PvBCancel(gameIdOrBetAmountStr, userObject, originalMessageId, callbackQueryId, chatDataForHandler);
            else console.error(`${LOG_PREFIX_D21_CB_FWD} Missing handler: handleDice21PvBCancel`);
            break;
        case 'd21_pvp_stand':
            const userIdStringForStand = String(userObject.id || userObject.telegram_id); 
            const gameIdForPvPStand = gameIdOrBetAmountStr; 
            if (typeof handleDice21PvPStand === 'function') await handleDice21PvPStand(gameIdForPvPStand, userIdStringForStand, originalMessageId, callbackQueryId, chatDataForHandler);
            else console.error(`${LOG_PREFIX_D21_CB_FWD} Missing handler: handleDice21PvPStand`);
            break;
        default:
            await bot.answerCallbackQuery(callbackQueryId, { text: "Unknown D21 action.", show_alert: false }).catch(() => {});
    }
}

async function forwardDuelCallback(action, params, userObject, originalMessageId, originalChatId, originalChatType, callbackQueryId) {
    const LOG_PREFIX_DUEL_CB_FWD = `[Duel_CB_Fwd UID:${userObject.telegram_id || userObject.id} Act:${action}]`;
    const offerIdOrBetAmountStr = params[0];

    switch (action) {
        case 'duel_accept_bot_game':
            if (typeof handleDuelAcceptBotGameCallback === 'function') await handleDuelAcceptBotGameCallback(offerIdOrBetAmountStr, userObject, originalMessageId, originalChatId, originalChatType, callbackQueryId);
            else console.error(`${LOG_PREFIX_DUEL_CB_FWD} Missing handler: handleDuelAcceptBotGameCallback`);
            break;
        case 'duel_accept_pvp_challenge':
            if (typeof handleDuelAcceptPvPChallengeCallback === 'function') await handleDuelAcceptPvPChallengeCallback(offerIdOrBetAmountStr, userObject, originalMessageId, originalChatId, originalChatType, callbackQueryId);
            else console.error(`${LOG_PREFIX_DUEL_CB_FWD} Missing handler: handleDuelAcceptPvPChallengeCallback`);
            break;
        case 'duel_cancel_unified_offer':
            if (typeof handleDuelCancelUnifiedOfferCallback === 'function') await handleDuelCancelUnifiedOfferCallback(offerIdOrBetAmountStr, userObject, originalMessageId, originalChatId, callbackQueryId);
            else console.error(`${LOG_PREFIX_DUEL_CB_FWD} Missing handler: handleDuelCancelUnifiedOfferCallback`);
            break;
        default:
            await bot.answerCallbackQuery(callbackQueryId, { text: "Unknown Duel action.", show_alert: false }).catch(() => {});
    }
}

async function forwardMinesCallback(action, params, userObject, originalMessageId, originalChatId, originalChatType, callbackQueryId) {
    const LOG_PREFIX_MINES_CB_FWD = `[MinesCB_Fwd UID:${userObject.telegram_id || userObject.id} Act:${action}]`;
    const gameIdOrOfferId = params[0];

    switch(action) {
        case 'mines_difficulty_select':
            const difficultyKey = params[1];
            if (typeof handleMinesDifficultySelectionCallback === 'function') await handleMinesDifficultySelectionCallback(gameIdOrOfferId, userObject, difficultyKey, callbackQueryId, originalMessageId, originalChatId, originalChatType);
            else console.error(`${LOG_PREFIX_MINES_CB_FWD} Missing handler: handleMinesDifficultySelectionCallback`);
            break;
        case 'mines_cancel_offer':
             if (typeof handleMinesCancelOfferCallback === 'function') await handleMinesCancelOfferCallback(gameIdOrOfferId, userObject, originalMessageId, originalChatId, callbackQueryId);
             else console.error(`${LOG_PREFIX_MINES_CB_FWD} Missing handler: handleMinesCancelOfferCallback`);
             break;
        case 'mines_tile':
            const row = params[1]; const col = params[2];
            if (typeof handleMinesTileClickCallback === 'function') await handleMinesTileClickCallback(gameIdOrOfferId, userObject, parseInt(row), parseInt(col), callbackQueryId, originalMessageId, originalChatId);
            else console.error(`${LOG_PREFIX_MINES_CB_FWD} Missing handler: handleMinesTileClickCallback`);
            break;
        case 'mines_cashout':
            if (typeof handleMinesCashOutCallback === 'function') await handleMinesCashOutCallback(gameIdOrOfferId, userObject, callbackQueryId, originalMessageId, originalChatId);
            else console.error(`${LOG_PREFIX_MINES_CB_FWD} Missing handler: handleMinesCashOutCallback`);
            break;
        default:
            await bot.answerCallbackQuery(callbackQueryId, { text: "Unknown Mines action.", show_alert: false }).catch(() => {});
    }
}

async function forwardAdditionalGamesCallback(action, params, userObject, originalMessageId, originalChatId, originalChatType, callbackQueryId) {
    const LOG_PREFIX_ADD_GAME_CB = `[AddGameCB_Fwd UID:${userObject.telegram_id || userObject.id} Act:${action}]`;
    const gameIdOrBetAmountStr = params[0];
    const msgContext = { chatId: originalChatId, chatType: originalChatType, messageId: originalMessageId };

    try {
        switch (action) {
            case 'ou7_choice':
                const choiceOU7 = params[1];
                if (typeof handleOverUnder7Choice === 'function') await handleOverUnder7Choice(gameIdOrBetAmountStr, choiceOU7, userObject, originalMessageId, callbackQueryId, msgContext);
                else console.error(`${LOG_PREFIX_ADD_GAME_CB} Missing handler: handleOverUnder7Choice`);
                break;
            case 's7_roll': 
                console.warn(`${LOG_PREFIX_ADD_GAME_CB} s7_roll action received, but Lucky Sum is auto-roll. Ignoring if it's for Lucky Sum.`);
                await bot.answerCallbackQuery(callbackQueryId, {text:"Action not applicable."}).catch(()=>{});
                break;
            case 'jackpot_display_noop': 
                 await bot.answerCallbackQuery(callbackQueryId).catch(()=>{});
                 break;
            default:
                console.warn(`${LOG_PREFIX_ADD_GAME_CB} Unhandled action: ${action}`);
                await bot.answerCallbackQuery(callbackQueryId, {text: "Unknown action.", show_alert: false}).catch(()=>{});
        }
    } catch (e) {
        console.error(`${LOG_PREFIX_ADD_GAME_CB} Error processing ${action}: ${e.message}`);
        await bot.answerCallbackQuery(callbackQueryId, { text: "Error processing action.", show_alert: true });
    }
}

// --- Main Message Handler (`bot.on('message')`) ---
// --- START OF FULL REPLACEMENT for bot.on('message') function (with D21 debug logs) ---
bot.on('message', async (msg) => {
    const LOG_PREFIX_MSG_HANDLER = `[MsgHandler TID:${msg.message_id || 'N/A'} OriginUID:${msg.from?.id || 'N/A'} ChatID:${msg.chat?.id || 'N/A'}]`;

    if (isShuttingDown) return;
    if (!msg || !msg.from || !msg.chat || !msg.date) return;

    if (msg.from.is_bot) {
        try {
            const selfBotInfo = await bot.getMe();
            if (String(msg.from.id) !== String(selfBotInfo.id)) return; // Ignore other bots
            if (!msg.dice) return; // Only process own dice messages if relevant (e.g. for helper bot system)
        } catch (getMeError) { return; } // If getMe fails, can't confirm if it's self, so ignore.
    }

    const userId = String(msg.from.id || msg.from.telegram_id);
    const chatId = String(msg.chat.id);
    const text = msg.text || "";
    const chatType = msg.chat.type;

    // Dice emoji handling for active games
    if (msg.dice && msg.from && !msg.from.is_bot) { // Ensure it's a user's dice roll
        const diceValue = msg.dice.value;
        const rollerId = String(msg.from.id || msg.from.telegram_id);
        let gameIdForDiceRoll = null;
        let gameDataForDiceRoll = null;
        let isDiceEscalatorEmoji = false;
        let isDice21Emoji = false;
        let isDuelGameEmoji = false;

        for (const [gId, gData] of activeGames.entries()) {
            if (String(gData.chatId) === chatId) {
                if (gData.type === GAME_IDS.DICE_ESCALATOR_PVB && gData.player?.userId === rollerId && (gData.status === 'player_turn_awaiting_emoji' || gData.status === 'player_score_18_plus_awaiting_choice')) {
                    gameIdForDiceRoll = gId; gameDataForDiceRoll = gData; isDiceEscalatorEmoji = true; break;
                }
                if (gData.type === GAME_IDS.DICE_ESCALATOR_PVP) {
                    const isPlayerTurnInDEPvP = (gData.initiator?.userId === rollerId && gData.initiator?.isTurn && gData.initiator?.status === 'awaiting_roll_emoji') || (gData.opponent?.userId === rollerId && gData.opponent?.isTurn && gData.opponent?.status === 'awaiting_roll_emoji');
                    if (isPlayerTurnInDEPvP) { gameIdForDiceRoll = gId; gameDataForDiceRoll = gData; isDiceEscalatorEmoji = true; break; }
                }
                if (gData.type === GAME_IDS.DICE_21 && gData.playerId === rollerId && (gData.status === 'player_turn_hit_stand_prompt' || gData.status === 'player_initial_roll_1_prompted' || gData.status === 'player_initial_roll_2_prompted')) {
                    gameIdForDiceRoll = gId; gameDataForDiceRoll = gData; isDice21Emoji = true; break;
                }
                if (gData.type === GAME_IDS.DICE_21_PVP) {
                    const isPlayerTurnInD21PvP = (gData.initiator?.userId === rollerId && gData.initiator?.isTurn && gData.initiator?.status === 'playing_turn') || (gData.opponent?.userId === rollerId && gData.opponent?.isTurn && gData.opponent?.status === 'playing_turn');
                    if (isPlayerTurnInD21PvP) { gameIdForDiceRoll = gId; gameDataForDiceRoll = gData; isDice21Emoji = true; break; }
                }
                if (gData.type === GAME_IDS.DUEL_PVB && gData.playerId === rollerId && gData.status === 'player_awaiting_roll_emoji') {
                    gameIdForDiceRoll = gId; gameDataForDiceRoll = gData; isDuelGameEmoji = true; break;
                }
                if (gData.type === GAME_IDS.DUEL_PVP) {
                    const isPlayerTurnInDuelPvP = (gData.initiator?.userId === rollerId && gData.initiator?.isTurn && gData.initiator?.status === 'awaiting_roll_emoji') || (gData.opponent?.userId === rollerId && gData.opponent?.isTurn && gData.opponent?.status === 'awaiting_roll_emoji');
                    if (isPlayerTurnInDuelPvP) { gameIdForDiceRoll = gId; gameDataForDiceRoll = gData; isDuelGameEmoji = true; break; }
                }
            }
        }

        if (gameIdForDiceRoll && gameDataForDiceRoll) {
            bot.deleteMessage(chatId, msg.message_id).catch(() => {});

            if (isDiceEscalatorEmoji) {
                if (gameDataForDiceRoll.type === GAME_IDS.DICE_ESCALATOR_PVB && typeof processDiceEscalatorPvBRollByEmoji_New === 'function') {
                    await processDiceEscalatorPvBRollByEmoji_New(gameDataForDiceRoll, diceValue);
                } else if (gameDataForDiceRoll.type === GAME_IDS.DICE_ESCALATOR_PVP && typeof processDiceEscalatorPvPRollByEmoji_New === 'function') {
                    await processDiceEscalatorPvPRollByEmoji_New(gameDataForDiceRoll, diceValue, rollerId);
                }
            } else if (isDice21Emoji) {
                // --- ADDED DEBUG LOGS for D21 Handler Check ---
                console.log(`[DEBUG_D21_HANDLER_CHECK] Type of processDice21PvBRollByEmoji: ${typeof processDice21PvBRollByEmoji}`);
                console.log(`[DEBUG_D21_HANDLER_CHECK] Type of processDice21PvPRoll: ${typeof processDice21PvPRoll}`);
                console.log(`[DEBUG_D21_HANDLER_CHECK] gameDataForDiceRoll.type: ${gameDataForDiceRoll ? gameDataForDiceRoll.type : 'N/A'}`);
                // --- END OF ADDED DEBUG LOGS ---

                if (gameDataForDiceRoll.type === GAME_IDS.DICE_21 && typeof processDice21PvBRollByEmoji === 'function') {
                    await processDice21PvBRollByEmoji(gameDataForDiceRoll, diceValue, msg);
                } else if (gameDataForDiceRoll.type === GAME_IDS.DICE_21_PVP && typeof processDice21PvPRoll === 'function') {
                    await processDice21PvPRoll(gameDataForDiceRoll, diceValue, rollerId);
                } else {
                    console.error(`${LOG_PREFIX_MSG_HANDLER} Missing or misconfigured handler for Dice 21 emoji roll. Game Type: ${gameDataForDiceRoll.type}`);
                }
            } else if (isDuelGameEmoji) {
                if (gameDataForDiceRoll.type === GAME_IDS.DUEL_PVB && typeof processDuelPvBRollByEmoji === 'function') {
                    await processDuelPvBRollByEmoji(gameDataForDiceRoll, diceValue);
                } else if (gameDataForDiceRoll.type === GAME_IDS.DUEL_PVP && typeof processDuelPvPRollByEmoji === 'function') {
                    await processDuelPvPRollByEmoji(gameDataForDiceRoll, diceValue, rollerId);
                }
            }
            return;
        }
    }

    if (userStateCache.has(userId) && !text.startsWith('/')) {
        const currentState = userStateCache.get(userId);
        if (typeof routeStatefulInput === 'function') {
            await routeStatefulInput(msg, currentState);
            return;
        } else {
            if (typeof clearUserState === 'function') clearUserState(userId); else userStateCache.delete(userId);
        }
    }

    if (text.startsWith('/')) {
        if (!userId || userId === "undefined") {
            await safeSendMessage(chatId, "⚠️ Error with user session. Try `/start`.", {});
            return;
        }
        let userForCommandProcessing = await getOrCreateUser(userId, msg.from.username, msg.from.first_name, msg.from.last_name);
        if (!userForCommandProcessing) {
            await safeSendMessage(chatId, "😕 Profile access error. Try `/start`.", {});
            return;
        }

        const now = Date.now();
        if (userCooldowns.has(userId) && (now - userCooldowns.get(userId)) < COMMAND_COOLDOWN_MS) {
            return;
        }
        userCooldowns.set(userId, now);

        let fullCommand = text.substring(1);
        let commandName = fullCommand.split(/\s+/)[0]?.toLowerCase();
        const commandArgs = fullCommand.split(/\s+/).slice(1);
        const originalMessageId = msg.message_id;

        if (commandName.includes('@')) {
            try {
                const selfBotInfo = await bot.getMe();
                const botUsernameLower = selfBotInfo.username.toLowerCase();
                if (commandName.endsWith(`@${botUsernameLower}`)) {
                    commandName = commandName.substring(0, commandName.lastIndexOf(`@${botUsernameLower}`));
                } else if (chatType === 'group' || chatType === 'supergroup') {
                    return;
                } else {
                    commandName = commandName.split('@')[0];
                }
            } catch (getMeErr) {}
        }
        console.log(`${LOG_PREFIX_MSG_HANDLER} CMD: /${commandName}, Args: [${commandArgs.join(', ')}] from User ${userId} (${userForCommandProcessing.username || 'NoUsername'})`);

        const parseGameArgs = (args) => {
            let betArg = null; let targetRaw = null; let otherArgs = [];
            if (args.length === 0) {}
            else if (args.length === 1) {
                const arg0 = args[0];
                if (arg0.startsWith('@') || (/^\d+$/.test(arg0) && arg0.length >= 7 && arg0.length <= 12)) targetRaw = arg0;
                else betArg = arg0;
            } else {
                const arg0IsUserLike = args[0].startsWith('@') || (/^\d+$/.test(args[0]) && args[0].length >= 7);
                const arg1IsUserLike = args.length > 1 && (args[1].startsWith('@') || (/^\d+$/.test(args[1]) && args[1].length >= 7));
                if (!arg0IsUserLike && arg1IsUserLike) { betArg = args[0]; targetRaw = args[1]; otherArgs = args.slice(2); }
                else if (arg0IsUserLike && !arg1IsUserLike) { targetRaw = args[0]; betArg = args[1]; otherArgs = args.slice(2); }
                else if (!arg0IsUserLike && !arg1IsUserLike) { betArg = args[0]; otherArgs = args.slice(1); }
                else { betArg = args[0]; targetRaw = null; otherArgs = args.slice(1); }
            }
            return { betArg, targetRaw, otherArgs };
        };

        try {
            switch (commandName) {
                case 'start': await handleStartCommand(msg, commandArgs); break;
                case 'help': await handleHelpCommand(msg); break;
                case 'balance': case 'bal': await handleBalanceCommand(msg); break;
                case 'rules': case 'info': await handleRulesCommand(chatId, userForCommandProcessing, originalMessageId, false, chatType); break;
                case 'jackpot': await handleJackpotCommand(chatId, userForCommandProcessing, chatType); break;
                case 'leaderboards': await handleLeaderboardsCommand(msg, commandArgs); break;
                case 'wallet': if (typeof handleWalletCommand === 'function') await handleWalletCommand(msg); break;
                case 'deposit': if (typeof handleDepositCommand === 'function') await handleDepositCommand(msg, commandArgs, userId); break;
                case 'withdraw': if (typeof handleWithdrawCommand === 'function') await handleWithdrawCommand(msg, commandArgs, userId); break;
                case 'referral': if (typeof handleReferralCommand === 'function') await handleReferralCommand(msg); break;
                case 'history': if (typeof handleHistoryCommand === 'function') await handleHistoryCommand(msg); break;
                case 'setwallet': if (typeof handleSetWalletCommand === 'function') await handleSetWalletCommand(msg, commandArgs); break;
                case 'grant': await handleGrantCommand(msg, commandArgs, userForCommandProcessing); break;
                case 'tip': if (typeof handleTipCommand === 'function') await handleTipCommand(msg, commandArgs, userForCommandProcessing); break;
                case 'coinflip': case 'cf': {
                    if (chatType === 'private') { await safeSendMessage(chatId, `🪙 Coinflip is in <b>groups</b>! Use <code>/cf &lt;bet&gt; [@user]</code> there.`, { parse_mode: 'HTML' }); break; }
                    if (typeof handleStartCoinflipUnifiedOfferCommand === 'function') { const { betArg, targetRaw } = parseGameArgs(commandArgs); const betCF = await parseBetAmount(betArg, chatId, chatType, userId); if(betCF) await handleStartCoinflipUnifiedOfferCommand(msg, betCF, targetRaw); }
                    else console.error(`${LOG_PREFIX_MSG_HANDLER} Missing: handleStartCoinflipUnifiedOfferCommand`); break;
                }
                case 'rps': {
                    if (chatType === 'private') { await safeSendMessage(chatId, `🪨📄✂️ RPS is in <b>groups</b>! Use <code>/rps &lt;bet&gt; [@user]</code> there.`, { parse_mode: 'HTML' }); break; }
                    if (typeof handleStartRPSUnifiedOfferCommand === 'function') { const { betArg, targetRaw } = parseGameArgs(commandArgs); const betRPS = await parseBetAmount(betArg, chatId, chatType, userId); if(betRPS) await handleStartRPSUnifiedOfferCommand(msg, betRPS, targetRaw); }
                    else console.error(`${LOG_PREFIX_MSG_HANDLER} Missing: handleStartRPSUnifiedOfferCommand`); break;
                }
                case 'de': case 'diceescalator': {
                    if (chatType === 'private') { await safeSendMessage(chatId, `🎲 Dice Escalator is in <b>groups</b>! Use <code>/de &lt;bet&gt; [@user]</code> there.`, { parse_mode: 'HTML' }); break; }
                    if (typeof handleStartDiceEscalatorUnifiedOfferCommand_New === 'function') { const { betArg, targetRaw } = parseGameArgs(commandArgs); const betDE = await parseBetAmount(betArg, chatId, chatType, userId); if(betDE) await handleStartDiceEscalatorUnifiedOfferCommand_New(msg, betDE, targetRaw); }
                    else console.error(`${LOG_PREFIX_MSG_HANDLER} Missing: handleStartDiceEscalatorUnifiedOfferCommand_New`); break;
                }
                case 'd21': case 'blackjack': {
                    if (chatType === 'private') { await safeSendMessage(chatId, `🎲 Dice 21 is in <b>groups</b>! Use <code>/d21 &lt;bet&gt; [@user]</code> there.`, { parse_mode: 'HTML' }); break; }
                    if (typeof handleStartDice21Command === 'function') { const { betArg, targetRaw, otherArgs } = parseGameArgs(commandArgs); const gameModeArgD21 = otherArgs[0] || null; const betD21 = await parseBetAmount(betArg, chatId, chatType, userId); if(betD21) await handleStartDice21Command(msg, betD21, targetRaw, gameModeArgD21); }
                    else console.error(`${LOG_PREFIX_MSG_HANDLER} Missing: handleStartDice21Command`); break;
                }
                case 'duel': case 'highroller': {
                    if (chatType === 'private') { await safeSendMessage(chatId, `⚔️ Duel is in <b>groups</b>! Use <code>/duel &lt;bet&gt; [@user]</code> there.`, { parse_mode: 'HTML' }); break; }
                    if (typeof handleStartDuelUnifiedOfferCommand === 'function') { const { betArg, targetRaw } = parseGameArgs(commandArgs); const betDuel = await parseBetAmount(betArg, chatId, chatType, userId); if(betDuel) await handleStartDuelUnifiedOfferCommand(msg, betDuel, targetRaw); }
                    else console.error(`${LOG_PREFIX_MSG_HANDLER} Missing: handleStartDuelUnifiedOfferCommand`); break;
                }
                case 'ou7': case 'overunder7':
                    if (typeof handleStartOverUnder7Command === 'function') { const betOU7 = await parseBetAmount(commandArgs[0], chatId, chatType, userId); if(betOU7) await handleStartOverUnder7Command(msg, betOU7); }
                    else console.error(`${LOG_PREFIX_MSG_HANDLER} Missing: handleStartOverUnder7Command`); break;
                case 'ladder': case 'greedsladder':
                    if (typeof handleStartLadderCommand === 'function') { const betLadder = await parseBetAmount(commandArgs[0], chatId, chatType, userId); if(betLadder) await handleStartLadderCommand(msg, betLadder); }
                    else console.error(`${LOG_PREFIX_MSG_HANDLER} Missing: handleStartLadderCommand`); break;
                case 's7': case 'sevenout': case 'luckysum':
                    if (typeof handleStartSevenOutCommand === 'function') { const betS7 = await parseBetAmount(commandArgs[0], chatId, chatType, userId); if(betS7) await handleStartSevenOutCommand(msg, betS7); }
                    else console.error(`${LOG_PREFIX_MSG_HANDLER} Missing: handleStartSevenOutCommand`); break;
                case 'slot': case 'slots': case 'slotfrenzy':
                    if (typeof handleStartSlotCommand === 'function') { const betSlot = await parseBetAmount(commandArgs[0], chatId, chatType, userId); if(betSlot) await handleStartSlotCommand(msg, betSlot); }
                    else console.error(`${LOG_PREFIX_MSG_HANDLER} Missing: handleStartSlotCommand`); break;
                case 'mines':
                            if (typeof handleStartMinesCommand === 'function') {
                                await handleStartMinesCommand(msg, commandArgs, userForCommandProcessing);
                            } else {
                                console.error(`${LOG_PREFIX_MSG_HANDLER} Missing: handleStartMinesCommand`);
                            }
                            break;
                        
                        case 'bonus': // New command for Level Up Bonus System
                            if (typeof handleBonusCommand === 'function') {
                                await handleBonusCommand(msg);
                            } else {
                                console.error(`${LOG_PREFIX_MSG_HANDLER} Missing handler: handleBonusCommand`);
                                await safeSendMessage(chatId, "Bonus feature currently unavailable.", {});
                            }
                            break;


                default:
                    const selfBotInfoDefault = await bot.getMe();
                    if (chatType === 'private' || text.includes(`@${selfBotInfoDefault.username}`)) {
                        await safeSendMessage(chatId, `🤔 Unknown command: \`/${escapeMarkdownV2(commandName || "")}\`. Try \`/help\`.`, { parse_mode: 'MarkdownV2' });
                    }
                    break;
            }
        } catch (commandError) {
            console.error(`${LOG_PREFIX_MSG_HANDLER} 🚨 UNHANDLED ERROR IN COMMAND ROUTER for /${commandName}: ${commandError.message}`, commandError.stack?.substring(0, 700));
            await safeSendMessage(chatId, `⚙️ Oops! Error processing \`/${escapeMarkdownV2(commandName || "")}\`. Try again or \`/help\`.`, { parse_mode: 'MarkdownV2' });
            if (typeof notifyAdmin === 'function') notifyAdmin(`🚨 Command Router Error for /${escapeMarkdownV2(commandName)} from User: ${userId}. Error: \`${escapeMarkdownV2(commandError.message)}\``);
        }
    }
});
// --- END OF FULL REPLACEMENT for bot.on('message') function ---

// --- Callback Query Handler (`bot.on('callback_query')`) ---
// FINAL CORRECTED VERSION of bot.on('callback_query', ...)

bot.on('callback_query', async (callbackQuery) => {
    const LOG_PREFIX_CBQ = `[CBQ_V6 ID:${callbackQuery.id} User:${callbackQuery.from.id}]`;

    if (isShuttingDown) {
        await bot.answerCallbackQuery(callbackQuery.id, { text: "Bot shutting down. Try later." }).catch(() => {});
        return;
    }
    const msg = callbackQuery.message;
    const userFromCb = callbackQuery.from;
    const callbackQueryId = callbackQuery.id;
    const data = callbackQuery.data;

    if (!msg || !userFromCb || !data) {
        await bot.answerCallbackQuery(callbackQueryId).catch(() => {});
        return;
    }

    const userId = String(userFromCb.id || userFromCb.telegram_id);
    if (!userId || userId === "undefined") {
        await bot.answerCallbackQuery(callbackQueryId, { text: "⚠️ User session error.", show_alert: true }).catch(() => {});
        return;
    }

    const originalChatId = String(msg.chat.id);
    const originalChatType = msg.chat.type;
    const originalMessageId = String(msg.message_id);

    let userObjectForCallback = await getOrCreateUser(userId, userFromCb.username, userFromCb.first_name, userFromCb.last_name);
    if (!userObjectForCallback) {
        await bot.answerCallbackQuery(callbackQueryId, {text: "Error fetching profile.", show_alert: true}).catch(()=>{});
        return;
    }

    const [action, ...params] = data.split(':');

    // This standardized object is used by handlers to get consistent user/chat info
    const mockMsgObject = {
        from: {
            id: userObjectForCallback.telegram_id,
            is_bot: false,
            first_name: userObjectForCallback.first_name,
            username: userObjectForCallback.username,
            telegram_id: userObjectForCallback.telegram_id
        },
        chat: { id: originalChatId, type: originalChatType },
        message_id: originalMessageId,
        isCallbackEditing: (originalChatType === 'private' && !!originalMessageId),
        message: msg
    };

    try {
        if (action.startsWith(RULES_CALLBACK_PREFIX_CONST)) {
            const gameCodeForRule = action.substring(RULES_CALLBACK_PREFIX_CONST.length);
            // FIX: Use the correct mockMsgObject
            if (typeof handleDisplayGameRules === 'function') await handleDisplayGameRules(mockMsgObject.chat.id, mockMsgObject.message_id, gameCodeForRule, userObjectForCallback, mockMsgObject.chat.type);
            return;
        }
        
        switch (action) {
            // --- NEW: This case now handles the Quick Deposit button and gives the user a choice ---
            case QUICK_DEPOSIT_CALLBACK_ACTION_CONST:
                await bot.answerCallbackQuery(callbackQueryId).catch(() => {});
                const playerRefHTML = escapeHTML(getPlayerDisplayReference(userObjectForCallback));
                const choiceText = `Hi ${playerRefHTML}! Which currency would you like to deposit?`;
                const choiceKeyboard = {
                    inline_keyboard: [
                        [{ text: "➕ Deposit SOL", callback_data: "menu:deposit:sol" }],
                        [{ text: "➕ Deposit LTC", callback_data: "menu:deposit:ltc" }],
                        [{ text: "❌ Cancel", callback_data: "noop_delete" }]
                    ]
                };

                if (originalChatType !== 'private') {
                    let botUsernameForRedirect = BOT_NAME || "our bot";
                    try { const selfInfo = await bot.getMe(); if (selfInfo.username) botUsernameForRedirect = selfInfo.username; } catch (e) {}
                    await safeSendMessage(userId, choiceText, { parse_mode: 'HTML', reply_markup: choiceKeyboard });
                    await bot.answerCallbackQuery(callbackQueryId, { text: `Please check your DM with @${botUsernameForRedirect} to continue.`, show_alert: true });
                } else {
                    await bot.editMessageText(choiceText, {
                        chat_id: originalChatId,
                        message_id: Number(originalMessageId),
                        parse_mode: 'HTML',
                        reply_markup: choiceKeyboard
                    });
                }
                break;

            // This case now routes all menu actions, including the deposit choices from the case above
            case 'menu':
                await handleMenuAction(userId, originalChatId, originalMessageId, params[0], params.slice(1), true, originalChatType, msg);
                break;
            
            // --- ALL OTHER CASES FROM YOUR ORIGINAL FILE ---
            case 'show_rules_menu': 
                if (typeof handleRulesCommand === 'function') await handleRulesCommand(originalChatId, userObjectForCallback, originalMessageId, true, originalChatType); 
                break;
            case DEPOSIT_CALLBACK_ACTION_CONST: // Handles legacy /deposit command button
                 if (typeof handleDepositCommand === 'function') await handleDepositCommand(mockMsgObject, params, userId); 
                 break;
            case WITHDRAW_CALLBACK_ACTION_CONST:
                 if (typeof handleWithdrawCommand === 'function') await handleWithdrawCommand(mockMsgObject, params, userId); 
                 break;
            case 'process_withdrawal_confirm':
                 if (typeof handleWithdrawalConfirmation === 'function') {
                     const decision = params[0]; const currentState = userStateCache.get(userId);
                     const msgIdToEdit = currentState?.messageId || originalMessageId;
                     const dmForWithdraw = currentState?.chatId || userId;
                     if (decision === 'yes' && currentState?.state === 'awaiting_withdrawal_confirmation' && currentState.chatId === String(userId)) {
                         await handleWithdrawalConfirmation(userId, currentState.chatId, currentState.messageId, currentState.data.linkedWallet, currentState.data.amountLamportsStr, currentState.data.feeLamportsStr, currentState.data.originalGroupChatId, currentState.data.originalGroupMessageId);
                     } else {
                         if (bot && msgIdToEdit) await bot.editMessageText(decision === 'no' ? "Withdrawal cancelled." : "Invalid or expired session.", { chat_id: dmForWithdraw, message_id: Number(msgIdToEdit), parse_mode:'HTML', reply_markup: {inline_keyboard:[[{text:"💳 Wallet", callback_data:"menu:wallet"}]]} }).catch(()=>{});
                         clearUserState(userId);
                     }
                 } break;
            case 'dir_chal_acc': case 'dir_chal_dec': case 'dir_chal_can':
            case 'cf_direct_accept': case 'cf_direct_decline': case 'cf_direct_cancel':
            case 'rps_direct_accept': case 'rps_direct_decline': case 'rps_direct_cancel':
            case 'de_direct_accept': case 'de_direct_decline': case 'de_direct_cancel':
            case 'd21_direct_accept': case 'd21_direct_decline': case 'd21_direct_cancel':
            case 'duel_direct_accept': case 'duel_direct_decline': case 'duel_direct_cancel':
                 if (typeof handleDirectChallengeResponse === 'function') {
                     const offerIdFromParams = params[0]; 
                     await handleDirectChallengeResponse(action, offerIdFromParams, userObjectForCallback, originalMessageId, originalChatId, originalChatType, callbackQueryId);
                 } else console.error(`${LOG_PREFIX_CBQ} Missing: handleDirectChallengeResponse`);
                 break;
            case 'cf_accept_bot': case 'cf_accept_pvp': case 'cf_cancel_offer': case 'cf_pvb_choice': case 'cf_pvp_call':
            case 'rps_accept_bot': case 'rps_accept_pvp': case 'rps_cancel_offer': case 'rps_pvb_choice': case 'rps_pvp_choice':
                 if (typeof forwardCoinflipRPSCallback === 'function') await forwardCoinflipRPSCallback(action, params, userObjectForCallback, originalMessageId, originalChatId, originalChatType, callbackQueryId);
                 else await bot.answerCallbackQuery(callbackQueryId, {text: "CF/RPS action error.", show_alert: true}).catch(()=>{});
                 break;
            case 'de_accept_bot_game': case 'de_accept_pvp_challenge': case 'de_cancel_unified_offer':
            case 'de_stand_pvb': case 'de_stand_pvp': case 'de_pvb_go_for_jackpot':
                 if (typeof forwardDiceEscalatorCallback_New === 'function') await forwardDiceEscalatorCallback_New(action, params, userObjectForCallback, originalMessageId, originalChatId, originalChatType, callbackQueryId);
                 else await bot.answerCallbackQuery(callbackQueryId, {text: "DE action error.", show_alert: true}).catch(()=>{});
                 break;
            case 'd21_accept_bot_game': case 'd21_accept_pvp_challenge': case 'd21_cancel_unified_offer':
            case 'd21_stand': case 'd21_pvb_cancel': case 'd21_pvp_stand':
                 if (typeof forwardDice21Callback === 'function') await forwardDice21Callback(action, params, userObjectForCallback, originalMessageId, originalChatId, originalChatType, callbackQueryId);
                 else await bot.answerCallbackQuery(callbackQueryId, {text: "D21 action error.", show_alert: true}).catch(()=>{});
                 break;
            case 'duel_accept_bot_game': case 'duel_accept_pvp_challenge': case 'duel_cancel_unified_offer':
                 if (typeof forwardDuelCallback === 'function') await forwardDuelCallback(action, params, userObjectForCallback, originalMessageId, originalChatId, originalChatType, callbackQueryId);
                 else await bot.answerCallbackQuery(callbackQueryId, {text: "Duel action error.", show_alert: true}).catch(()=>{});
                 break;
            case 'mines_difficulty_select': case 'mines_cancel_offer': case 'mines_tile': case 'mines_cashout':
                 if (typeof forwardMinesCallback === 'function') await forwardMinesCallback(action, params, userObjectForCallback, originalMessageId, originalChatId, originalChatType, callbackQueryId);
                 else await bot.answerCallbackQuery(callbackQueryId, {text: "Mines action error.", show_alert: true}).catch(()=>{});
                 break;
            case 'ou7_choice': case 's7_roll': case 'jackpot_display_noop':
                 if (typeof forwardAdditionalGamesCallback === 'function') await forwardAdditionalGamesCallback(action, params, userObjectForCallback, originalMessageId, originalChatId, originalChatType, callbackQueryId);
                 else console.warn(`${LOG_PREFIX_CBQ} forwardAdditionalGamesCallback not defined for ${action}`);
                 break;
            case 'noop_ok': case 'noop':
                 await bot.answerCallbackQuery(callbackQueryId).catch(()=>{});
                 break;
            case 'noop_delete': // New case for the cancel button
                if(originalMessageId) await bot.deleteMessage(originalChatId, Number(originalMessageId)).catch(()=>{});
                await bot.answerCallbackQuery(callbackQueryId).catch(()=>{});
                break;
            case 'claim_milestone_bonus':
                 const commissionReferralIdToClaim = params[0];
                 if (typeof handleClaimMilestoneBonusCallback === 'function') {
                     await handleClaimMilestoneBonusCallback(callbackQueryId, userObjectForCallback, commissionReferralIdToClaim, originalMessageId, originalChatId);
                 } else {
                     await bot.answerCallbackQuery(callbackQueryId, { text: "Error: Claim feature unavailable.", show_alert: true });
                 }
                 break;
            case 'claim_level_bonus':
                 const levelIdToClaimBonusStr = params[0];
                 if (typeof handleClaimLevelBonusCallback === 'function') {
                     await handleClaimLevelBonusCallback(callbackQueryId, userObjectForCallback, levelIdToClaimBonusStr, originalMessageId, originalChatId);
                 } else {
                     await bot.answerCallbackQuery(callbackQueryId, { text: "Error: Level bonus claim feature unavailable.", show_alert: true });
                 }
                 break;
            default:
                console.warn(`${LOG_PREFIX_CBQ} Unknown callback action: "${action}"`);
                await bot.answerCallbackQuery(callbackQueryId, {text: "Unknown action.", show_alert: false}).catch(()=>{});
        }
    } catch (callbackError) {
        console.error(`${LOG_PREFIX_CBQ} 🚨 UNHANDLED ERROR IN CALLBACK ROUTER for action ${action}: ${callbackError.message}`, callbackError.stack?.substring(0, 700));
        await safeSendMessage(userId, `⚙️ Oops\\! Critical error processing action \\(\`${escapeMarkdownV2(action)}\`\\)\\. Try again or \`/help\`\\.`, { parse_mode: 'MarkdownV2' }); 
        if (typeof notifyAdmin === 'function') notifyAdmin(`🚨 CB Router System Error 🚨\nAction: \`${escapeMarkdownV2(action)}\`\nUser: ${userId}\nError: \`${escapeMarkdownV2(String(callbackError.message || callbackError))}\``);
    }
});

// --- NEW Callback Handler for Claiming Milestone Bonuses ---
// (Place this where other callback query handlers are routed, e.g., within or called by your main bot.on('callback_query', ...) logic)

/**
 * Handles the callback query when a user clicks to claim a specific milestone bonus.
 * @param {string} callbackQueryId - The ID of the callback query.
 * @param {object} userWhoClicked - The user object of the person who clicked the button.
 * @param {string} commissionReferralIdStr - The referral_id of the specific commission to claim, as a string.
 * @param {string} originalMessageId - The ID of the message (the referral dashboard) that had the button.
 * @param {string} originalChatId - The chat ID (should be the user's DM).
 */
async function handleClaimMilestoneBonusCallback(callbackQueryId, userWhoClicked, commissionReferralIdStr, originalMessageId, originalChatId) {
    const userId = String(userWhoClicked.id || userWhoClicked.telegram_id);
    const commissionReferralId = parseInt(commissionReferralIdStr, 10);
    const LOG_PREFIX_CLAIM_CB = `[ClaimMilestoneBonusCB UID:${userId} CommID:${commissionReferralId}]`;

    if (isNaN(commissionReferralId)) {
        console.error(`${LOG_PREFIX_CLAIM_CB} Invalid commissionReferralId: ${commissionReferralIdStr}`);
        await bot.answerCallbackQuery(callbackQueryId, { text: "Error: Invalid bonus ID.", show_alert: true }).catch(() => {});
        return;
    }

    let client = null;
    try {
        client = await pool.connect();
        await client.query('BEGIN'); // Start transaction for the claim process

        // Call the helper function that contains the core logic
        const claimResult = await handleClaimMilestoneBonus(userId, commissionReferralId, client);

        if (claimResult.success) {
            await client.query('COMMIT');
            console.log(`${LOG_PREFIX_CLAIM_CB} Successfully claimed bonus. Message: ${claimResult.messageForUser}`);
            await bot.answerCallbackQuery(callbackQueryId, { text: claimResult.messageForUser || "Bonus claimed and queued for payout!", show_alert: false }).catch(() => {});

            // Refresh the referral dashboard for the user in DM
            // Construct a mock msgOrCbMsg object for handleReferralCommand
            const mockMsgForDashboardRefresh = {
                from: userWhoClicked, // User object
                chat: { id: originalChatId, type: 'private' }, // Should be DM
                message_id: originalMessageId, // The message to be edited/replaced
                isCallbackRedirect: false // Not a redirect, it's an action within DM
            };
            if (typeof handleReferralCommand === 'function') {
                await handleReferralCommand(mockMsgForDashboardRefresh);
            } else {
                console.error(`${LOG_PREFIX_CLAIM_CB} CRITICAL: handleReferralCommand is not defined. Cannot refresh dashboard.`);
                // Send a simple success if dashboard can't be refreshed
                await safeSendMessage(originalChatId, claimResult.messageForUser || "Bonus claimed and queued!", {parse_mode: 'MarkdownV2'});
            }
        } else {
            await client.query('ROLLBACK');
            console.warn(`${LOG_PREFIX_CLAIM_CB} Failed to claim bonus: ${claimResult.error}`);
            await bot.answerCallbackQuery(callbackQueryId, { text: claimResult.error || "Could not claim bonus at this time.", show_alert: true }).catch(() => {});
            // Optionally, refresh the dashboard even on failure to show the current state
             const mockMsgForDashboardRefresh = {
                from: userWhoClicked,
                chat: { id: originalChatId, type: 'private' },
                message_id: originalMessageId,
                isCallbackRedirect: false
            };
            if (typeof handleReferralCommand === 'function') {
                 await handleReferralCommand(mockMsgForDashboardRefresh);
            }
        }
    } catch (error) {
        if (client) {
            try { await client.query('ROLLBACK'); } catch (rbErr) { console.error(`${LOG_PREFIX_CLAIM_CB} Rollback error: ${rbErr.message}`); }
        }
        console.error(`${LOG_PREFIX_CLAIM_CB} Critical error during claim processing: ${error.message}`, error.stack);
        await bot.answerCallbackQuery(callbackQueryId, { text: "Server error while claiming bonus. Please try again later.", show_alert: true }).catch(() => {});
        if (typeof notifyAdmin === 'function') {
            notifyAdmin(`🚨 CRITICAL Error Claiming Milestone Bonus\nUID: ${userId}, CommID: ${commissionReferralId}\nError: ${error.message}`, {parse_mode: 'MarkdownV2'});
        }
    } finally {
        if (client) {
            client.release();
        }
    }
}

// --- NEW Callback Handler for Claiming Level Up Bonuses ---
// (Place this where other callback query handlers are routed)

/**
 * Handles the callback query when a user clicks the "Claim $X Bonus (Level Name)" button.
 * @param {string} callbackQueryId - The ID of the callback query.
 * @param {object} userWhoClicked - The user object of the person who clicked. (Contains .id or .telegram_id)
 * @param {string} levelIdToClaimStr - The level_id (from user_levels table) for the bonus being claimed, as a string.
 * @param {string} originalMessageId - The ID of the /bonus message that had the button.
 * @param {string} originalChatId - The chat ID where the /bonus message is (should be user's DM).
 */
async function handleClaimLevelBonusCallback(callbackQueryId, userWhoClicked, levelIdToClaimStr, originalMessageId, originalChatId) {
    const userId = String(userWhoClicked.id || userWhoClicked.telegram_id);
    const levelIdToClaim = parseInt(levelIdToClaimStr, 10);
    const LOG_PREFIX_CLAIM_LVL_CB = `[ClaimLevelBonusCB UID:${userId} LevelID:${levelIdToClaim}]`;

    if (isNaN(levelIdToClaim)) {
        console.error(`${LOG_PREFIX_CLAIM_LVL_CB} Invalid levelIdToClaim: ${levelIdToClaimStr}`);
        await bot.answerCallbackQuery(callbackQueryId, { text: "Error: Invalid bonus level ID.", show_alert: true }).catch(() => {});
        return;
    }

    let client = null;
    try {
        client = await pool.connect();
        await client.query('BEGIN');

        const claimResult = await handleClaimLevelBonus(userId, levelIdToClaim, client); // Assumes handleClaimLevelBonus is defined

        if (claimResult.success) {
            await client.query('COMMIT');
            console.log(`${LOG_PREFIX_CLAIM_LVL_CB} Successfully claimed bonus. Message: ${claimResult.messageForUser}`);
            await bot.answerCallbackQuery(callbackQueryId, { text: claimResult.messageForUser || "Bonus claimed successfully!", show_alert: false }).catch(() => {});

            const mockMsgForDashboardRefresh = {
                from: userWhoClicked,
                chat: { id: originalChatId, type: 'private' }, 
                message_id: originalMessageId, 
                isCallbackEditing: true // Ensure this flag is passed for handleBonusCommand
            };
            if (typeof handleBonusCommand === 'function') {
                await handleBonusCommand(mockMsgForDashboardRefresh);
            } else {
                console.error(`${LOG_PREFIX_CLAIM_LVL_CB} CRITICAL: handleBonusCommand is not defined. Cannot refresh /bonus dashboard.`);
                await safeSendMessage(originalChatId, claimResult.messageForUser || "Bonus claimed successfully!", { parse_mode: 'MarkdownV2' });
            }
        } else {
            await client.query('ROLLBACK');
            console.warn(`${LOG_PREFIX_CLAIM_LVL_CB} Failed to claim bonus: ${claimResult.error}`);
            await bot.answerCallbackQuery(callbackQueryId, { text: claimResult.error || "Could not claim bonus. It might be already claimed or you might not be eligible.", show_alert: true }).catch(() => {});
            
            const mockMsgForDashboardRefreshOnError = {
                from: userWhoClicked,
                chat: { id: originalChatId, type: 'private' },
                message_id: originalMessageId,
                isCallbackEditing: true // Also refresh on error
            };
            if (typeof handleBonusCommand === 'function') {
                await handleBonusCommand(mockMsgForDashboardRefreshOnError);
            }
        }
    } catch (error) {
        if (client) {
            try { await client.query('ROLLBACK'); } catch (rbErr) { console.error(`${LOG_PREFIX_CLAIM_LVL_CB} Rollback error: ${rbErr.message}`); }
        }
        console.error(`${LOG_PREFIX_CLAIM_LVL_CB} Critical error during level bonus claim processing: ${error.message}`, error.stack);
        await bot.answerCallbackQuery(callbackQueryId, { text: "Server error while claiming bonus. Please try again later or contact support.", show_alert: true }).catch(() => {});
        if (typeof notifyAdmin === 'function' && typeof escapeMarkdownV2 === 'function') {
            notifyAdmin(`🚨 CRITICAL Error Claiming Level Bonus\nUID: ${userId}, LevelID Attempted: ${levelIdToClaim}\nError: ${escapeMarkdownV2(error.message)}`, { parse_mode: 'MarkdownV2' });
        }
    } finally {
        if (client) {
            client.release();
        }
    }
}


// --- Centralized Handler for Direct Challenge Responses (Accept/Decline/Cancel) ---
// --- START OF FULL REPLACEMENT for handleDirectChallengeResponse function ---
async function handleDirectChallengeResponse(actionName, offerId, clickerUserObj, originalMessageIdInGroupStr, originalChatIdFromGroupStr, originalChatTypeFromGroup, callbackQueryId) {
    const clickerId = String(clickerUserObj.id || clickerUserObj.telegram_id);
    const originalMessageIdInGroup = Number(originalMessageIdInGroupStr);
    const originalChatIdFromGroup = String(originalChatIdFromGroupStr);
    const logPrefix = `[DirectChalResp_V6_GranLimit GID:${offerId} Clicker:${clickerId} Act:${actionName}]`;

    console.log(`${logPrefix} Processing direct challenge response. Action: ${actionName}, OfferID: ${offerId}`);

    const offerData = activeGames.get(offerId);

    if (!offerData) {
        console.warn(`${logPrefix} Offer ID ${offerId} not found in activeGames. It may have already been processed or expired.`);
        await bot.answerCallbackQuery(callbackQueryId, { text: "This challenge has expired or is no longer valid.", show_alert: true }).catch(() => {});
        if (originalMessageIdInGroup && bot) {
            bot.editMessageReplyMarkup({}, { chat_id: originalChatIdFromGroup, message_id: originalMessageIdInGroup }).catch(() => {});
        }
        return;
    }

    if (offerData.type !== GAME_IDS.DIRECT_PVP_CHALLENGE || offerData.status !== 'pending_direct_challenge_response') {
        console.warn(`${logPrefix} Offer ${offerId} is not a pending direct PvP challenge. Status: ${offerData.status}, Type: ${offerData.type}`);
        await bot.answerCallbackQuery(callbackQueryId, { text: "This challenge is not in a valid state to respond to.", show_alert: true }).catch(() => {});
        return;
    }

    if (offerData.timeoutId) {
        clearTimeout(offerData.timeoutId);
        offerData.timeoutId = null;
    }

    let pendingDirectChallengeOfferKeyUsed;
    switch (offerData.gameToStart) {
        case GAME_IDS.COINFLIP_PVP:
            pendingDirectChallengeOfferKeyUsed = GAME_IDS.COINFLIP_DIRECT_CHALLENGE_OFFER;
            break;
        case GAME_IDS.RPS_PVP:
            pendingDirectChallengeOfferKeyUsed = GAME_IDS.RPS_DIRECT_CHALLENGE_OFFER;
            break;
        case GAME_IDS.DICE_ESCALATOR_PVP:
            pendingDirectChallengeOfferKeyUsed = GAME_IDS.DICE_ESCALATOR_DIRECT_CHALLENGE_OFFER;
            break;
        case GAME_IDS.DICE_21_PVP:
            pendingDirectChallengeOfferKeyUsed = GAME_IDS.DICE_21_DIRECT_CHALLENGE_OFFER;
            break;
        case GAME_IDS.DUEL_PVP:
            pendingDirectChallengeOfferKeyUsed = GAME_IDS.DUEL_DIRECT_CHALLENGE_OFFER;
            break;
        default:
            console.error(`${logPrefix} CRITICAL: Unknown offerData.gameToStart '${offerData.gameToStart}' for direct challenge offer ${offerId}. Cannot determine correct key for group lock. This could lead to a lingering lock.`);
            pendingDirectChallengeOfferKeyUsed = 'UNKNOWN_DIRECT_CHALLENGE_OFFER_KEY_ASSERTION_FAILED';
            break;
    }
    if (offerData._offerKeyUsedForGroupLock && offerData._offerKeyUsedForGroupLock !== pendingDirectChallengeOfferKeyUsed) {
        console.warn(`${logPrefix} Discrepancy detected! Derived group lock key '${pendingDirectChallengeOfferKeyUsed}' differs from stored key '${offerData._offerKeyUsedForGroupLock}'. Using derived key for removal.`);
    } else if (!offerData._offerKeyUsedForGroupLock) {
        console.warn(`${logPrefix} _offerKeyUsedForGroupLock was missing in offerData. Derived key for removal: ${pendingDirectChallengeOfferKeyUsed}.`);
    }

    const activeGameKeyForNewLimitCheck = offerData.gameToStart;

    let gameDisplayNameForMessages = "Game";
    let specificPvPGameStarterFunction = null;

    switch (offerData.gameToStart) {
        case GAME_IDS.COINFLIP_PVP:
            gameDisplayNameForMessages = "Coinflip";
            specificPvPGameStarterFunction = startCoinflipPvPGame;
            break;
        case GAME_IDS.RPS_PVP:
            gameDisplayNameForMessages = "Rock Paper Scissors";
            specificPvPGameStarterFunction = startRPSPvPGame;
            break;
        case GAME_IDS.DICE_ESCALATOR_PVP:
            gameDisplayNameForMessages = "Dice Escalator";
            specificPvPGameStarterFunction = startDiceEscalatorPvPGame_New;
            break;
        case GAME_IDS.DICE_21_PVP:
            gameDisplayNameForMessages = "Dice 21";
            specificPvPGameStarterFunction = startDice21PvPInitialDeal;
            break;
        case GAME_IDS.DUEL_PVP:
            gameDisplayNameForMessages = "Duel";
            specificPvPGameStarterFunction = startDuelPvPGameSequence;
            break;
        default:
            console.error(`${logPrefix} Unknown gameToStart in offerData: ${offerData.gameToStart}`);
            await bot.answerCallbackQuery(callbackQueryId, { text: "Error: Unknown game type for this challenge.", show_alert: true });
            activeGames.delete(offerId);
            await updateGroupGameDetails(originalChatIdFromGroup, { removeThisId: offerId }, pendingDirectChallengeOfferKeyUsed, null);
            return;
    }

    const initiatorUserObjFull = offerData.initiatorUserObj;
    const targetUserObjFull = offerData.targetUserObj;
    const initiatorMentionHTML = offerData.initiatorMentionHTML || escapeHTML(getPlayerDisplayReference(initiatorUserObjFull));
    const targetMentionHTML = offerData.targetUserMentionHTML || escapeHTML(getPlayerDisplayReference(targetUserObjFull));
    const betDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(offerData.betAmount, 'USD'));

    if (!initiatorUserObjFull || !targetUserObjFull || !targetUserObjFull.telegram_id) {
        console.error(`${logPrefix} Critical: Missing initiator or target user object details in offerData for ${offerId}.`);
        await bot.answerCallbackQuery(callbackQueryId, { text: "Error: Player details missing for challenge.", show_alert: true });
        activeGames.delete(offerId);
        await updateGroupGameDetails(originalChatIdFromGroup, { removeThisId: offerId }, pendingDirectChallengeOfferKeyUsed, null);
        if (bot && offerData.offerMessageIdInGroup) {
            bot.editMessageText("Error processing challenge: Player details missing. Offer cancelled.", { chat_id: originalChatIdFromGroup, message_id: Number(offerData.offerMessageIdInGroup), parse_mode: 'HTML', reply_markup: {} }).catch(() => {});
        }
        return;
    }

    const actionType = actionName.split(':')[0];

    switch (actionType) {
        case 'dir_chal_acc': 
        case 'cf_direct_accept':
        case 'rps_direct_accept':
        case 'de_direct_accept': 
        case 'd21_direct_accept':
        case 'duel_direct_accept':
            if (clickerId !== String(offerData.targetUserId)) {
                await bot.answerCallbackQuery(callbackQueryId, { text: "This challenge was not addressed to you.", show_alert: true });
                return;
            }

            // --- NEW USER ACTIVE GAME LIMIT CHECK (for the clicker/target accepting the offer) ---
            // Pass offerId as gameIdBeingActioned, as the user is actioning this specific offer.
            const activeUserGameCheckForAccept = await checkUserActiveGameLimit(clickerId, false, offerId); 
            if (activeUserGameCheckForAccept.limitReached) {
                const userDisplayName = escapeHTML(getPlayerDisplayReference(clickerUserObj));
                const blockingGameType = activeUserGameCheckForAccept.details.type;
                const cleanGameName = getCleanGameName(blockingGameType);
                let alertMessage = `✨ ${userDisplayName}, you're already in a game of ${escapeHTML(cleanGameName)}. ✨ Finish it first!`;
                alertMessage = alertMessage.substring(0, 200); // Telegram alert length limit

                await bot.answerCallbackQuery(callbackQueryId, { text: alertMessage, show_alert: true }).catch(() => {});
                return;
            }
            // --- END OF NEW USER ACTIVE GAME LIMIT CHECK ---

            const gameSession = await getGroupSession(originalChatIdFromGroup);
            const currentActiveGamesOfThisType = gameSession.activeGamesByTypeInGroup.get(activeGameKeyForNewLimitCheck) || [];
            const limitActive = GAME_ACTIVITY_LIMITS.ACTIVE_GAMES[activeGameKeyForNewLimitCheck] || 1;

            if (currentActiveGamesOfThisType.length >= limitActive) {
                // This message is for the GROUP limit of this game type, not the user's personal limit.
                // The personal limit was checked above.
                await bot.answerCallbackQuery(callbackQueryId, { text: `Cannot accept now. Max ${limitActive} active ${gameDisplayNameForMessages} (from Direct Challenge) game(s) allowed in this group. Please wait.`, show_alert: true });
                return;
            }
            await bot.answerCallbackQuery(callbackQueryId, { text: `Accepting ${gameDisplayNameForMessages} challenge... Verifying...` });

            const freshInitiator = await getOrCreateUser(offerData.initiatorId);
            const freshTarget = await getOrCreateUser(offerData.targetUserId);

            if (!freshInitiator || !freshTarget) {
                console.error(`${logPrefix} Failed to fetch fresh user details for challenge ${offerId}.`);
                await safeSendMessage(originalChatIdFromGroup, `⚙️ Error fetching player details for the challenge. Please try again.`, { parse_mode: 'HTML' });
                return; 
            }
            if (BigInt(freshTarget.balance) < offerData.betAmount) {
                await safeSendMessage(originalChatIdFromGroup, `⚠️ ${targetMentionHTML}, your balance is too low (needs <b>${betDisplayUSD_HTML}</b>) to accept the ${gameDisplayNameForMessages} challenge from ${initiatorMentionHTML}. Challenge cancelled. Initiator's bet refunded.`, { parse_mode: 'HTML' });
                if (bot && offerData.offerMessageIdInGroup) bot.editMessageReplyMarkup({}, { chat_id: originalChatIdFromGroup, message_id: Number(offerData.offerMessageIdInGroup) }).catch(() => {});
                activeGames.delete(offerId);
                await updateGroupGameDetails(originalChatIdFromGroup, { removeThisId: offerId }, pendingDirectChallengeOfferKeyUsed, null);
                console.log(`${logPrefix} Removed offer ${offerId} from group lock (key: ${pendingDirectChallengeOfferKeyUsed}) due to target low funds.`);
                let refundClientNoFunds = null;
                try {
                    refundClientNoFunds = await pool.connect(); await refundClientNoFunds.query('BEGIN');
                    await updateUserBalanceAndLedger(refundClientNoFunds, offerData.initiatorId, offerData.betAmount, 'refund_direct_challenge_target_low_funds', {custom_offer_id: offerId}, `Direct challenge ${offerId} cancelled, target low funds.`);
                    await refundClientNoFunds.query('COMMIT');
                } catch (e) { if(refundClientNoFunds) await refundClientNoFunds.query('ROLLBACK'); console.error(`${logPrefix} REFUND FAIL (target low funds) for ${offerId}: ${e.message}`);}
                finally { if(refundClientNoFunds) refundClientNoFunds.release(); }
                return;
            }
             if (BigInt(freshInitiator.balance) < 0n && (BigInt(freshInitiator.balance) + offerData.betAmount < 0n) ) {
                await safeSendMessage(originalChatIdFromGroup, `⚠️ Challenge from ${initiatorMentionHTML} to ${targetMentionHTML} for ${gameDisplayNameForMessages} (<b>${betDisplayUSD_HTML}</b>) is void. ${initiatorMentionHTML}'s account cannot cover their prior commitment. Original bet (if successfully placed) is being refunded.`, { parse_mode: 'HTML' });
                if (bot && offerData.offerMessageIdInGroup) bot.editMessageReplyMarkup({}, { chat_id: originalChatIdFromGroup, message_id: Number(offerData.offerMessageIdInGroup) }).catch(() => {});
                activeGames.delete(offerId);
                await updateGroupGameDetails(originalChatIdFromGroup, { removeThisId: offerId }, pendingDirectChallengeOfferKeyUsed, null);
                console.log(`${logPrefix} Removed offer ${offerId} from group lock (key: ${pendingDirectChallengeOfferKeyUsed}) due to initiator low funds post-offer.`);
                return;
            }

            let clientAccept = null;
            let newPvPGameId; 
            try {
                clientAccept = await pool.connect(); await clientAccept.query('BEGIN');
                const targetBetRes = await updateUserBalanceAndLedger(clientAccept, offerData.targetUserId, BigInt(-offerData.betAmount), `bet_placed_${offerData.gameToStart.toLowerCase()}_direct_join`, { game_id_custom_field: offerId , opponent_id_custom_field: offerData.initiatorId }, `Direct PvP bet vs ${initiatorMentionHTML} for ${offerData.gameToStart}`);
                if (!targetBetRes.success) throw new Error(targetBetRes.error || "Failed to deduct target's bet.");
                freshTarget.balance = targetBetRes.newBalanceLamports;
                await clientAccept.query('COMMIT');

                activeGames.delete(offerId);
                await updateGroupGameDetails(originalChatIdFromGroup, { removeThisId: offerId }, pendingDirectChallengeOfferKeyUsed, null);
                console.log(`${logPrefix} Removed offer ${offerId} from group lock (key: ${pendingDirectChallengeOfferKeyUsed}) as it was accepted.`);

                const acceptedMsgHTML = `✅ Challenge Accepted by ${targetMentionHTML}!\nA <b>${gameDisplayNameForMessages}</b> duel between ${initiatorMentionHTML} and ${targetMentionHTML} for <b>${betDisplayUSD_HTML}</b> is starting...`;
                if (bot && offerData.offerMessageIdInGroup) {
                    await bot.editMessageText(acceptedMsgHTML, { chat_id: originalChatIdFromGroup, message_id: Number(offerData.offerMessageIdInGroup), parse_mode: 'HTML', reply_markup: {} }).catch(e => {
                        console.warn(`${logPrefix} Could not edit offer message ${offerData.offerMessageIdInGroup} after acceptance: ${e.message}`);
                        safeSendMessage(originalChatIdFromGroup, acceptedMsgHTML, { parse_mode: 'HTML' }); 
                    });
                } else { await safeSendMessage(originalChatIdFromGroup, acceptedMsgHTML, { parse_mode: 'HTML' }); }

                if (typeof specificPvPGameStarterFunction !== 'function') {
                    throw new Error(`PvP starter function for ${offerData.gameToStart} is not defined.`);
                }

                newPvPGameId = generateGameId(offerData.gameToStart); 

                if (offerData.gameToStart === GAME_IDS.DICE_21_PVP || offerData.gameToStart === GAME_IDS.DUEL_PVP) {
                    await specificPvPGameStarterFunction(newPvPGameId, freshInitiator, freshTarget, offerData.betAmount, originalChatIdFromGroup, originalChatTypeFromGroup, null, 'direct_challenge');
                } else {
                    await specificPvPGameStarterFunction(
                        freshInitiator,                 
                        freshTarget,                  
                        offerData.betAmount,          
                        originalChatIdFromGroup,      
                        originalChatTypeFromGroup,    
                        null,                         
                        'direct_challenge'            
                    );
                }

            } catch (e) {
                if (clientAccept) await clientAccept.query('ROLLBACK').catch(()=>{});
                console.error(`${logPrefix} Error accepting direct challenge or starting PvP game: ${e.message}`);
                await safeSendMessage(originalChatIdFromGroup, `⚙️ Error processing challenge acceptance: ${escapeHTML(e.message)}`, { parse_mode: 'HTML' });
                activeGames.delete(offerId); 
                await updateGroupGameDetails(originalChatIdFromGroup, { removeThisId: offerId }, pendingDirectChallengeOfferKeyUsed, null);
                console.log(`${logPrefix} Attempted to remove offer ${offerId} from group lock (key: ${pendingDirectChallengeOfferKeyUsed}) due to error during acceptance phase.`);
                let refundClientCatch = null;
                try {
                    refundClientCatch = await pool.connect(); await refundClientCatch.query('BEGIN');
                    await updateUserBalanceAndLedger(refundClientCatch, offerData.initiatorId, offerData.betAmount, 'refund_direct_challenge_accept_sys_error', {custom_offer_id: offerId}, `Direct challenge ${offerId} accept phase system error.`);
                    await refundClientCatch.query('COMMIT');
                } catch (refErr) { if(refundClientCatch) await refundClientCatch.query('ROLLBACK'); console.error(`${logPrefix} REFUND FAIL (sys error) for ${offerId}: ${refErr.message}`);}
                finally { if(refundClientCatch) refundClientCatch.release(); }
            } finally {
                if (clientAccept) clientAccept.release();
            }
            break;
            
        case 'claim_level_bonus': // New case for claiming level up bonus
            const levelIdToClaimStr = params[0]; // params[0] should be the level_id
            if (typeof handleClaimLevelBonusCallback === 'function') {
                await handleClaimLevelBonusCallback(
                    callbackQueryId,
                    userObjectForCallback,    // This is the user who clicked the button
                    levelIdToClaimStr,
                    originalMessageId,        // ID of the /bonus dashboard message
                    originalChatId            // Chat ID where the /bonus dashboard message is (should be user's DM)
                );
            } else {
                console.error(`${LOG_PREFIX_CBQ} Missing handler: handleClaimLevelBonusCallback`);
                await bot.answerCallbackQuery(callbackQueryId, { text: "Error: Bonus claim feature is currently unavailable.", show_alert: true });
            }
            break;

        // Cases for dir_chal_dec / cf_direct_decline / rps_direct_decline / de_direct_decline / d21_direct_decline / duel_direct_decline
        case 'dir_chal_dec': 
        case 'cf_direct_decline':
        case 'rps_direct_decline':
        case 'de_direct_decline': 
        case 'd21_direct_decline':
        case 'duel_direct_decline':
            if (clickerId !== String(offerData.targetUserId)) {
                await bot.answerCallbackQuery(callbackQueryId, { text: "This challenge was not addressed to you.", show_alert: true }); return;
            }
            await bot.answerCallbackQuery(callbackQueryId, { text: "Challenge declined." });
            activeGames.delete(offerId);
            await updateGroupGameDetails(originalChatIdFromGroup, { removeThisId: offerId }, pendingDirectChallengeOfferKeyUsed, null);
            console.log(`${logPrefix} Removed offer ${offerId} from group lock (key: ${pendingDirectChallengeOfferKeyUsed}) as it was declined.`);
            let refundClientDec = null;
            try {
                refundClientDec = await pool.connect(); await refundClientDec.query('BEGIN');
                await updateUserBalanceAndLedger(refundClientDec, offerData.initiatorId, offerData.betAmount, 'refund_direct_challenge_declined', {custom_offer_id: offerId}, `Direct challenge ${offerId} declined by target.`);
                await refundClientDec.query('COMMIT');
            } catch (e) { if(refundClientDec) await refundClientDec.query('ROLLBACK'); console.error(`${logPrefix} REFUND FAIL on decline for ${offerId}: ${e.message}`);}
            finally { if(refundClientDec) refundClientDec.release(); }
            const declineMsgHTML = `🚫 ${targetMentionHTML} has declined the ${gameDisplayNameForMessages} challenge from ${initiatorMentionHTML} for <b>${betDisplayUSD_HTML}</b>. Initiator's bet refunded.`;
            if (bot && offerData.offerMessageIdInGroup) {
                await bot.editMessageText(declineMsgHTML, { chat_id: originalChatIdFromGroup, message_id: Number(offerData.offerMessageIdInGroup), parse_mode: 'HTML', reply_markup: {} }).catch(e => {
                    console.warn(`${logPrefix} Could not edit offer message ${offerData.offerMessageIdInGroup} after decline: ${e.message}`);
                    safeSendMessage(originalChatIdFromGroup, declineMsgHTML, { parse_mode: 'HTML' }); 
                });
            } else { await safeSendMessage(originalChatIdFromGroup, declineMsgHTML, { parse_mode: 'HTML' }); }
            break;

        // Cases for dir_chal_can / cf_direct_cancel / rps_direct_cancel / de_direct_cancel / d21_direct_cancel / duel_direct_cancel
        case 'dir_chal_can': 
        case 'cf_direct_cancel':
        case 'rps_direct_cancel':
        case 'de_direct_cancel': 
        case 'd21_direct_cancel':
        case 'duel_direct_cancel':
            if (clickerId !== String(offerData.initiatorId)) {
                await bot.answerCallbackQuery(callbackQueryId, { text: "Only the initiator can cancel this challenge.", show_alert: true }); return;
            }
            await bot.answerCallbackQuery(callbackQueryId, { text: "Challenge withdrawn." });
            activeGames.delete(offerId);
            await updateGroupGameDetails(originalChatIdFromGroup, { removeThisId: offerId }, pendingDirectChallengeOfferKeyUsed, null);
            console.log(`${logPrefix} Removed offer ${offerId} from group lock (key: ${pendingDirectChallengeOfferKeyUsed}) as it was cancelled by initiator.`);
            let refundClientCan = null;
            try {
                refundClientCan = await pool.connect(); await refundClientCan.query('BEGIN');
                await updateUserBalanceAndLedger(refundClientCan, offerData.initiatorId, offerData.betAmount, 'refund_direct_challenge_cancelled', {custom_offer_id: offerId}, `Direct challenge ${offerId} cancelled by initiator.`);
                await refundClientCan.query('COMMIT');
            } catch (e) { if(refundClientCan) await refundClientCan.query('ROLLBACK'); console.error(`${logPrefix} REFUND FAIL on cancel for ${offerId}: ${e.message}`); }
            finally { if(refundClientCan) refundClientCan.release(); }
            const cancelMsgHTML = `🚫 ${initiatorMentionHTML} has withdrawn their ${gameDisplayNameForMessages} challenge to ${targetMentionHTML} for <b>${betDisplayUSD_HTML}</b>. Bet refunded.`;
            if (bot && offerData.offerMessageIdInGroup) {
                await bot.editMessageText(cancelMsgHTML, { chat_id: originalChatIdFromGroup, message_id: Number(offerData.offerMessageIdInGroup), parse_mode: 'HTML', reply_markup: {} }).catch(e => {
                    console.warn(`${logPrefix} Could not edit offer message ${offerData.offerMessageIdInGroup} after cancellation: ${e.message}`);
                    safeSendMessage(originalChatIdFromGroup, cancelMsgHTML, { parse_mode: 'HTML' }); 
                });
            } else { await safeSendMessage(originalChatIdFromGroup, cancelMsgHTML, { parse_mode: 'HTML' }); }
            break;

        default:
            await bot.answerCallbackQuery(callbackQueryId, { text: "Unknown challenge action.", show_alert: false });
    }
}
// --- End of Part 5a, Section 1 (CORRECTED - BOT_NAME & Play Again fixed - GRANULAR ACTIVE GAME LIMITS) ---
// index.js - Part 6: Main Application Logic (Initialization, Error Handling, Graceful Shutdown)
//---------------------------------------------------------------------------
// Assumed all necessary functions from previous parts are loaded and available.

// --- Global Error Handlers ---

process.on('uncaughtException', async (error, origin) => {
    console.error(`🚨 UNCAUGHT EXCEPTION! Origin: ${origin}`);
    console.error(error); // Log the full error object
    const errorMessage = error.message || 'No specific message';
    const errorStack = error.stack || 'No stack trace available';
    const adminMessage = `🚨 *CRITICAL: Uncaught Exception* (${escapeMarkdownV2(BOT_NAME)}) 🚨\n\nBot encountered a critical error and will attempt to shut down\\. \n\n*Origin:* \`${escapeMarkdownV2(String(origin))}\`\n*Error:* \`${escapeMarkdownV2(errorMessage)}\`\n*Stack (Partial):*\n\`\`\`\n${escapeMarkdownV2(errorStack.substring(0, 700))}\n\`\`\`\nPlease check server logs immediately for full details\\.`;

    if (!isShuttingDown) { 
        console.log("Initiating shutdown due to uncaught exception...");
        if (typeof notifyAdmin === 'function') {
            await notifyAdmin(adminMessage).catch(err => console.error("Failed to notify admin about uncaught exception:", err.message));
        }
        await gracefulShutdown('uncaught_exception'); 
        setTimeout(() => {
            console.error("Forcing exit after uncaught exception shutdown attempt timeout.");
            process.exit(1);
        }, SHUTDOWN_FAIL_TIMEOUT_MS + 5000); 
    } else {
        console.log("Uncaught exception during ongoing shutdown. Forcing exit.");
        process.exit(1); 
    }
});

process.on('unhandledRejection', async (reason, promise) => {
    console.error('🚨 UNHANDLED PROMISE REJECTION! At Promise:', promise, 'Reason:', reason);
    let reasonString = 'Unknown reason for promise rejection';
    if (reason instanceof Error) {
        reasonString = `${reason.name}: ${reason.message}${reason.stack ? `\nStack (Partial):\n${reason.stack.substring(0, 700)}` : ''}`;
    } else if (typeof reason === 'object' && reason !== null) {
        try {
            reasonString = stringifyWithBigInt(reason);
        } catch (e) {
            reasonString = "Could not stringify complex rejection reason object.";
        }
    } else if (reason !== undefined && reason !== null) {
        reasonString = String(reason);
    }

    const adminMessage = `⚠️ *WARNING: Unhandled Promise Rejection* (${escapeMarkdownV2(BOT_NAME)}) ⚠️\n\nAn unhandled promise rejection occurred\\. This may indicate a bug or an unhandled error case in asynchronous code\\. The bot will continue running but please investigate\\.\n\n*Reason:*\n\`\`\`\n${escapeMarkdownV2(reasonString.substring(0,1000))}\n\`\`\`\nCheck logs for full details and the promise context\\.`;

    if (typeof notifyAdmin === 'function' && !isShuttingDown) {
        await notifyAdmin(adminMessage).catch(err => console.error("Failed to notify admin about unhandled rejection:", err.message));
    }
});

// --- Graceful Shutdown Logic ---
let expressServerInstance = null; 

async function gracefulShutdown(signal = 'SIGINT') {
    if (isShuttingDown) {
        console.log("Graceful shutdown already in progress...");
        return;
    }
    isShuttingDown = true;

    console.log(`\n🛑 Received signal: ${signal}. Initiating graceful shutdown for ${BOT_NAME} v${BOT_VERSION}...`);
    const adminShutdownMessage = `🔌 *Bot Shutdown Initiated* 🔌\n\n${escapeMarkdownV2(BOT_NAME)} v${escapeMarkdownV2(BOT_VERSION)} is now shutting down due to signal: \`${escapeMarkdownV2(signal)}\`\\. Finalizing operations\\.\\.\\.`;
    if (typeof notifyAdmin === 'function' && signal !== 'test_mode_exit' && signal !== 'initialization_error') {
        await notifyAdmin(adminShutdownMessage).catch(err => console.error("Failed to send admin shutdown initiation notification:", err.message));
    }

    console.log("  ⏳ Stopping Telegram bot polling...");
    if (bot && typeof bot.stopPolling === 'function' && typeof bot.isPolling === 'function' && bot.isPolling()) {
        try {
            await bot.stopPolling({ cancel: true });
            console.log("  ✅ Telegram bot polling stopped.");
        } catch (e) {
            console.error("  ❌ Error stopping Telegram bot polling:", e.message);
        }
    } else {
        // console.log("  ℹ️ Telegram bot polling was not active or stopPolling not available/needed.");
    }

    if (typeof stopDepositMonitoring === 'function') {
        console.log("  ⏳ Stopping deposit monitoring...");
        try { await stopDepositMonitoring(); console.log("  ✅ Deposit monitoring stopped."); }
        catch(e) { console.error("  ❌ Error stopping deposit monitoring:", e.message); }
    } else { console.warn("  ⚠️ stopDepositMonitoring function not defined.");}

    if (typeof stopLitecoinDepositMonitoring === 'function') {
        console.log("  ⏳ Stopping LTC deposit monitoring...");
        stopLitecoinDepositMonitoring();
    }

    if (typeof stopSweepingProcess === 'function') {
        console.log("  ⏳ Stopping sweeping process...");
        try { await stopSweepingProcess(); console.log("  ✅ Sweeping process stopped."); }
        catch(e) { console.error("  ❌ Error stopping sweeping process:", e.message); }
    } else { console.warn("  ⚠️ stopSweepingProcess function not defined.");}
    
    // ADDED: Stop Jackpot Session Poller
    if (jackpotSessionPollIntervalId) {
        clearInterval(jackpotSessionPollIntervalId);
        jackpotSessionPollIntervalId = null;
        console.log(" 🛑 [MainBot] Jackpot Session Poller stopped.");
    } else {
        // console.log("  ℹ️ [MainBot] Jackpot Session Poller was not active or ID not found.");
    }
    
    const queuesToStop = { payoutProcessorQueue, depositProcessorQueue }; 
    for (const [queueName, queueInstance] of Object.entries(queuesToStop)) {
        if (queueInstance && typeof queueInstance.onIdle === 'function' && typeof queueInstance.clear === 'function') {
            console.log(`  ⏳ Waiting for ${queueName} (Size: ${queueInstance.size}, Pending: ${queueInstance.pending}) to idle...`);
            try {
                if (queueInstance.size > 0 || queueInstance.pending > 0) {
                    await Promise.race([queueInstance.onIdle(), sleep(15000)]); // Max 15s wait
                }
                queueInstance.clear(); 
                console.log(`  ✅ ${queueName} is idle and cleared.`);
            } catch (qError) {
                console.warn(`  ⚠️ Error or timeout waiting for ${queueName} to idle: ${qError.message}. Clearing queue.`);
                queueInstance.clear();
            }
        } else {
            // console.log(`  ⚠️ Queue ${queueName} not defined or does not support onIdle/clear.`);
        }
    }

    if (expressServerInstance && typeof expressServerInstance.close === 'function') {
        console.log("  ⏳ Closing Express webhook server...");
        await new Promise(resolve => expressServerInstance.close(err => {
            if (err) console.error("  ❌ Error closing Express server:", err.message);
            else console.log("  ✅ Express server closed.");
            resolve();
        }));
    } else {
        // console.log("  ℹ️ Express server not running or not managed by this shutdown process.");
    }

    console.log("  ⏳ Closing PostgreSQL pool...");
    if (pool && typeof pool.end === 'function') {
        try {
            await pool.end();
            console.log("  ✅ PostgreSQL pool closed.");
        } catch (e) {
            console.error("  ❌ Error closing PostgreSQL pool:", e.message);
        }
    } else {
        // console.log("  ⚠️ PostgreSQL pool not active or .end() not available.");
    }

    console.log(`🏁 ${BOT_NAME} shutdown sequence complete. Exiting now.`);
    const finalAdminMessage = `✅ *Bot Shutdown Complete* ✅\n\n${escapeMarkdownV2(BOT_NAME)} v${escapeMarkdownV2(BOT_VERSION)} has successfully shut down\\.`;
    if (typeof notifyAdmin === 'function' && signal !== 'test_mode_exit' && signal !== 'initialization_error') {
        // Intentionally not awaiting this final notification to prevent shutdown delay
        notifyAdmin(finalAdminMessage).catch(err => console.error("Failed to send final admin shutdown notification:", err.message));
    }
    
    // Allow a brief moment for the final notification to attempt sending
    await sleep(500); 
    process.exit(signal === 'uncaught_exception' || signal === 'initialization_error' ? 1 : 0);
}

// Signal Handlers
process.on('SIGINT', () => { if (!isShuttingDown) gracefulShutdown('SIGINT'); }); 
process.on('SIGTERM', () => { if (!isShuttingDown) gracefulShutdown('SIGTERM'); });
process.on('SIGQUIT', () => { if (!isShuttingDown) gracefulShutdown('SIGQUIT'); });

// --- Main Application Function ---
async function main() {
    console.log(`🚀🚀🚀 Starting ${BOT_NAME} v${BOT_VERSION} 🚀🚀🚀`);
    console.log(`Node.js Version: ${process.version}, System Time: ${new Date().toISOString()}`);
    const initDelay = parseInt(process.env.INIT_DELAY_MS, 10) || 7000;
    console.log(`Initialization delay: ${initDelay / 1000}s`);
    await sleep(initDelay);

    try {
        console.log("⚙️ Step 1: Initializing Database Schema...");
        if (typeof initializeDatabaseSchema !== 'function') {
            throw new Error("FATAL: initializeDatabaseSchema function is not defined!");
        }
        await initializeDatabaseSchema();
        console.log("✅ Database schema initialized successfully.");

        // --- NEW: Initialize User Levels Table from Config ---
        console.log("⚙️ Step 1b: Initializing User Levels from Config...");
        if (typeof initializeLevelsDB === 'function') {
            await initializeLevelsDB(); // Call the function here
            // The initializeLevelsDB function handles its own console logs for success/failure
        } else {
            console.warn("⚠️ initializeLevelsDB function not defined. User levels may not be populated from config.");
            // You might want to notify admin here if this is critical
            if (typeof notifyAdmin === 'function') {
                notifyAdmin("⚠️ ALERT: `initializeLevelsDB` function is missing. Level definitions from `LEVEL_CONFIG` cannot be populated into the database. Leveling system might not work correctly.", { parse_mode: 'MarkdownV2' });
            }
        }
        // --- END OF NEW: Initialize User Levels Table ---

        console.log("⚙️ Step 2: Connecting to Telegram & Starting Bot...");
        if (!bot || typeof bot.getMe !== 'function') {
            throw new Error("FATAL: Telegram bot instance is not correctly configured.");
        }
        
        const botInfo = await bot.getMe();
        console.log(`🤖 Bot Name: ${botInfo.first_name}, Username: @${botInfo.username}, ID: ${botInfo.id}`);
        console.log(`🔗 Start chatting with the bot: https://t.me/${botInfo.username}`);
        
        bot.on('polling_error', async (error) => {
            console.error(`[Telegram Polling Error] Code: ${error.code || 'N/A'}, Message: ${error.message || String(error)}`);
            const adminMsg = `📡 *Telegram Polling Error* (${escapeMarkdownV2(BOT_NAME)}) 📡\n\nError: \`${escapeMarkdownV2(String(error.message || error))}\` \\(Code: ${escapeMarkdownV2(String(error.code || 'N/A'))}\\)\\.\nPolling may be affected or try to restart\\.`;
            if (typeof notifyAdmin === 'function' && !isShuttingDown) {
                await notifyAdmin(adminMsg).catch(err => console.error("Failed to notify admin about polling error:", err.message));
            }
        });
        bot.on('webhook_error', async (error) => { 
            console.error(`[Telegram Webhook Error] Code: ${error.code || 'N/A'}, Message: ${error.message || String(error)}`);
            const adminMsg = `📡 *Telegram Webhook Error* (${escapeMarkdownV2(BOT_NAME)}) 📡\n\nError: \`${escapeMarkdownV2(String(error.message || error))}\`\\.\nBot message receiving may be affected\\.`;
            if (typeof notifyAdmin === 'function' && !isShuttingDown) {
                await notifyAdmin(adminMsg).catch(err => console.error("Failed to notify admin about webhook error:", err.message));
            }
        });
        console.log("✅ Telegram Bot is online and polling for messages (or webhook configured).");
        
        if (ADMIN_USER_ID && typeof safeSendMessage === 'function') {
            const currentTime = new Date().toLocaleString('en-GB', { timeZone: 'Europe/London' } || 'UTC'); // Fallback to UTC
            await safeSendMessage(ADMIN_USER_ID, `🚀 *${escapeMarkdownV2(BOT_NAME)} v${escapeMarkdownV2(BOT_VERSION)} Started Successfully* 🚀\nBot is online and operational\\. Current time: ${currentTime}`, {parse_mode: 'MarkdownV2'});
        }

        console.log("⚙️ Step 3: Priming SOL/USD Price Cache...");
        if (typeof getSolUsdPrice === 'function') {
            try {
                const initialPrice = await getSolUsdPrice();
                console.log(`✅ Initial SOL/USD Price: $${initialPrice.toFixed(2)}`);
            } catch (priceError) {
                console.warn(`⚠️ Could not fetch initial SOL/USD price: ${priceError.message}. Price features might be affected initially.`);
            }
        } else {
            console.warn("⚠️ getSolUsdPrice function not defined. Price features will be unavailable.");
        }

        console.log("⚙️ Step 4: Starting Background Payment Processes...");
        if (typeof startDepositMonitoring === 'function') {
            startDepositMonitoring(); 
            // console.log("  ▶️ Deposit monitoring process initiated."); // Reduced log
        } else {
            console.warn("⚠️ Deposit monitoring (startDepositMonitoring) function not defined.");
        }

        if (typeof startSweepingProcess === 'function') {
            startSweepingProcess(); 
            // console.log("  ▶️ Address sweeping process initiated."); // Reduced log
        } else {
            console.warn("⚠️ Address sweeping (startSweepingProcess) function not defined.");
        }

        if (typeof startLitecoinDepositMonitoring === 'function') {
        startLitecoinDepositMonitoring();
    } else {
        console.warn("⚠️ startLitecoinDepositMonitoring function not defined.");
    }

        if (typeof startJackpotSessionPolling === 'function') {
            startJackpotSessionPolling(); // Call the new function to start the DE Jackpot poller
            // console.log("   ▶️ Dice Escalator Jackpot session poller initiated."); // Optional log
        } else {
            console.warn("⚠️ Dice Escalator Jackpot session polling (startJackpotSessionPolling) function not defined.");
        }
        
        if (process.env.ENABLE_PAYMENT_WEBHOOKS === 'true') {
            console.log("⚙️ Step 5: Setting up and starting Payment Webhook Server...");
            if (typeof setupPaymentWebhook === 'function' && app) { 
                const port = parseInt(process.env.PAYMENT_WEBHOOK_PORT, 10) || 3000;
                try {
                    setupPaymentWebhook(app); 
                    
                    expressServerInstance = app.listen(port, () => {
                        console.log(`  ✅ Payment webhook server listening on port ${port} at path ${process.env.PAYMENT_WEBHOOK_PATH || '/webhook/solana-payments'}`);
                    });

                    expressServerInstance.on('error', (serverErr) => {
                        console.error(`  ❌ Express server error: ${serverErr.message}`, serverErr);
                        if (serverErr.code === 'EADDRINUSE') {
                            console.error(`  🚨 FATAL: Port ${port} is already in use for webhooks. Webhook server cannot start.`);
                            if(typeof notifyAdmin === 'function') notifyAdmin(`🚨 Webhook Server Failed to Start 🚨\nPort \`${port}\` is already in use\\. Payment webhooks will not function\\.`, {parse_mode:'MarkdownV2'});
                        }
                    });

                } catch (webhookError) {
                    console.error(`  ❌ Failed to set up or start payment webhook server: ${webhookError.message}`);
                }
            } else {
                console.warn("  ⚠️ Payment webhooks enabled, but setupPaymentWebhook function or Express app instance not available.");
            }
        } else {
            // console.log("ℹ️ Payment webhooks are disabled (ENABLE_PAYMENT_WEBHOOKS is not 'true')."); // Reduced log
        }

        console.log(`\n✨✨✨ ${BOT_NAME} is fully operational! Waiting for commands... ✨✨✨\n`);

    } catch (error) {
        console.error("💥💥💥 FATAL ERROR during bot initialization: 💥💥💥", error);
        const fatalAdminMessage = `🚨 *FATAL BOT INITIALIZATION ERROR* (${escapeMarkdownV2(BOT_NAME)}) 🚨\n\nFailed to start: \n*Error:* \`${escapeMarkdownV2(error.message || "Unknown error")}\`\n*Stack (Partial):*\n\`\`\`\n${escapeMarkdownV2((error.stack || String(error)).substring(0,700))}\n\`\`\`\nBot will attempt shutdown\\.`;
        if (typeof notifyAdmin === 'function' && !isShuttingDown) {
            await notifyAdmin(fatalAdminMessage).catch(err => console.error("Failed to notify admin about fatal initialization error:", err.message));
        }
        if (!isShuttingDown) { 
            await gracefulShutdown('initialization_error');
        }
        setTimeout(() => process.exit(1), SHUTDOWN_FAIL_TIMEOUT_MS + 2000); 
    }
}

// --- Run the main application ---
main();

// console.log("End of index.js script. Bot startup process initiated from main()."); // Removed log
// --- End of Part 6 ---
// --- Start of Part P1 ---
// index.js - Part P1: Solana Payment System - Core Utilities & Wallet Generation
//---------------------------------------------------------------------------
// Assumed DEPOSIT_MASTER_SEED_PHRASE, bip39, derivePath, nacl,
// Keypair, PublicKey, LAMPORTS_PER_SOL, SystemProgram, Transaction, sendAndConfirmTransaction,
// ComputeBudgetProgram, TransactionExpiredBlockheightExceededError, SendTransactionError,
// solanaConnection, queryDatabase, pool,
// escapeMarkdownV2, stringifyWithBigInt,
// PAYOUT_BASE_PRIORITY_FEE_MICROLAMPORTS, PAYOUT_MAX_PRIORITY_FEE_MICROLAMPORTS, PAYOUT_COMPUTE_UNIT_LIMIT,
// INITIAL_RETRY_POLLING_DELAY, MAX_RETRY_POLLING_DELAY, DEPOSIT_ADDRESS_EXPIRY_MS,
// RPC_MAX_RETRIES, RPC_COMMITMENT,
// notifyAdmin, sleep, createHash,
// getNextAddressIndexForUserDB,
// activeDepositAddresses cache are available.

//---------------------------------------------------------------------------
// HD Wallet & Address Generation
//---------------------------------------------------------------------------

/**
 * Creates a cryptographically safe, deterministic index from a user's Telegram ID
 * for use in an HD derivation path (as a non-hardened child).
 * @param {string|number} userId - The user's Telegram ID.
 * @returns {number} A derived, non-hardened index number (0 to 2^31 - 1).
 */
function createSafeUserSpecificIndex(userId) {
    if (typeof createHash !== 'function') {
        console.error("[CreateUserIndex] CRITICAL: createHash (from crypto) is not available. Using insecure fallback. THIS IS NOT PRODUCTION SAFE.");
        let simpleHash = 0;
        const strId = String(userId);
        for (let i = 0; i < strId.length; i++) {
            simpleHash = (simpleHash << 5) - simpleHash + strId.charCodeAt(i);
            simpleHash |= 0;
        }
        return Math.abs(simpleHash) % 2147483647; // Max non-hardened value (2^31 - 1)
    }

    const hash = createHash('sha256').update(String(userId)).digest();
    // Use first 4 bytes, ensure it's positive and within non-hardened range.
    const index = hash.readUInt32BE(0) % 2147483647;
    return index;
}

/**
 * Derives a Solana keypair from a BIP39 seed phrase and a derivation path.
 * @param {string} seedPhrase - The BIP39 mnemonic seed phrase.
 * @param {string} derivationPath - The HD derivation path (e.g., "m/44'/501'/0'/0'/0'").
 * @returns {import('@solana/web3.js').Keypair} The derived Keypair.
 * @throws {Error} If seed phrase or derivation path is invalid, or derivation fails.
 */
function deriveSolanaKeypair(seedPhrase, derivationPath) {
    if (!seedPhrase || typeof seedPhrase !== 'string') {
        throw new Error("Invalid or missing seed phrase for keypair derivation.");
    }
    if (!derivationPath || typeof derivationPath !== 'string' || !derivationPath.startsWith("m/")) {
        throw new Error("Invalid or missing derivation path. Must start with 'm/'.");
    }
    if (typeof bip39 === 'undefined' || typeof bip39.mnemonicToSeedSync !== 'function' ||
        typeof derivePath !== 'function' || typeof nacl === 'undefined' || 
        typeof nacl.sign === 'undefined' || typeof nacl.sign.keyPair === 'undefined' || typeof nacl.sign.keyPair.fromSeed !== 'function' ||
        typeof Keypair === 'undefined' || typeof Keypair.fromSeed !== 'function') {
        throw new Error("CRITICAL Dependency missing for deriveSolanaKeypair (bip39, ed25519-hd-key/derivePath, tweetnacl, or @solana/web3.js/Keypair).");
    }
    try {
        const seed = bip39.mnemonicToSeedSync(seedPhrase);
        const derivedSeedForKeypair = derivePath(derivationPath, seed.toString('hex')).key;
        const naclKeypair = nacl.sign.keyPair.fromSeed(derivedSeedForKeypair.slice(0, 32));
        const keypair = Keypair.fromSeed(naclKeypair.secretKey.slice(0, 32));
        return keypair;
    } catch (error) {
        console.error(`[DeriveSolKeypair Path:${derivationPath}] Error: ${error.message}`, error.stack?.substring(0,300)); // Shortened log
        throw new Error(`Keypair derivation failed for path ${derivationPath}: ${error.message}`);
    }
}

/**
 * Generates a new, unique deposit address for a user and stores its record.
 * This function performs a direct DB insert and should be called within a transaction
 * managed by the caller if atomicity with other user updates is required.
 * @param {string|number} userId - The user's Telegram ID.
 * @param {import('pg').PoolClient} [dbClient=pool] - Optional database client.
 * @returns {Promise<string|null>} The public key string of the generated deposit address, or null on failure.
 */
async function generateUniqueDepositAddress(userId, dbClient = pool) {
    const stringUserId = String(userId);
    const LOG_PREFIX_GUDA = `[GenDepositAddr UID:${stringUserId}]`;

    if (!DEPOSIT_MASTER_SEED_PHRASE) {
        console.error(`${LOG_PREFIX_GUDA} CRITICAL: DEPOSIT_MASTER_SEED_PHRASE is not set.`);
        if (typeof notifyAdmin === 'function') notifyAdmin(`🚨 CRITICAL: DEPOSIT_MASTER_SEED_PHRASE not set. Deposit address generation failing for user ${stringUserId}.`);
        return null;
    }
    if (typeof getNextAddressIndexForUserDB !== 'function') { 
        console.error(`${LOG_PREFIX_GUDA} CRITICAL: getNextAddressIndexForUserDB function not defined.`);
        return null;
    }

    try {
        const safeUserAccountIndex = createSafeUserSpecificIndex(stringUserId);
        const addressIndex = await getNextAddressIndexForUserDB(stringUserId, dbClient); 

        const derivationPath = `m/44'/501'/${safeUserAccountIndex}'/0'/${addressIndex}'`; 
        
        const depositKeypair = deriveSolanaKeypair(DEPOSIT_MASTER_SEED_PHRASE, derivationPath);
        const depositAddress = depositKeypair.publicKey.toBase58();

        const expiresAt = new Date(Date.now() + DEPOSIT_ADDRESS_EXPIRY_MS);

        const insertQuery = `
            INSERT INTO user_deposit_wallets (user_telegram_id, public_key, derivation_path, expires_at, is_active, created_at, updated_at)
            VALUES ($1, $2, $3, $4, TRUE, NOW(), NOW())
            RETURNING wallet_id, public_key;
        `;
        const result = await queryDatabase(insertQuery, [stringUserId, depositAddress, derivationPath, expiresAt], dbClient);

        if (result.rows.length > 0) {
            console.log(`${LOG_PREFIX_GUDA} ✅ New deposit address: ${depositAddress} (Path: ${derivationPath}, Expires: ${expiresAt.toISOString()})`);
            if (typeof activeDepositAddresses !== 'undefined' && activeDepositAddresses instanceof Map) {
                activeDepositAddresses.set(depositAddress, { userId: stringUserId, expiresAt: expiresAt.getTime() });
            }
            return depositAddress;
        } else {
            console.error(`${LOG_PREFIX_GUDA} ❌ Failed to store generated deposit address ${depositAddress} in DB.`);
            throw new Error("Failed to insert deposit address into database and get ID back.");
        }
    } catch (error) {
        console.error(`${LOG_PREFIX_GUDA} ❌ Error generating unique deposit address for user ${stringUserId}: ${error.message}`, error.stack?.substring(0,500));
        if (error.code === '23505') { 
            console.error(`${LOG_PREFIX_GUDA} Unique constraint violation. Path: ${error.detail?.includes('derivation_path') ? error.detail : 'N/A'}`);
             if (typeof notifyAdmin === 'function') notifyAdmin(`⚠️ Error generating deposit address (Unique Constraint) for user \`${escapeMarkdownV2(stringUserId)}\`: \`${escapeMarkdownV2(error.message)}\`. Possible race condition or index issue.`, {parse_mode:'MarkdownV2'});
        } else if (typeof notifyAdmin === 'function') {
            notifyAdmin(`⚠️ Error generating deposit address for user \`${escapeMarkdownV2(stringUserId)}\`: \`${escapeMarkdownV2(error.message)}\`. Check logs.`, {parse_mode:'MarkdownV2'});
        }
        return null;
    }
}

//---------------------------------------------------------------------------
// Solana On-Chain Utilities
//---------------------------------------------------------------------------

/**
 * Checks if a given string is a valid Solana address.
 * @param {string} address - The address string to validate.
 * @returns {boolean} True if valid, false otherwise.
 */
function isValidSolanaAddress(address) {
    if (!address || typeof address !== 'string') return false;
    try {
        const publicKey = new PublicKey(address);
        return PublicKey.isOnCurve(publicKey.toBytes());
    } catch (error) {
        return false; 
    }
}

/**
 * Gets the SOL balance of a given Solana public key.
 * @param {string} publicKeyString - The public key string.
 * @returns {Promise<bigint|null>} The balance in lamports, or null on error/if address not found.
 */
async function getSolBalance(publicKeyString) {
    const LOG_PREFIX_GSB = `[GetSolBalance PK:${publicKeyString ? publicKeyString.slice(0,10) : 'N/A'}...]`;
    if (!isValidSolanaAddress(publicKeyString)) {
        // console.warn(`${LOG_PREFIX_GSB} Invalid public key provided: ${publicKeyString}`); // Reduced log
        return null;
    }
    try {
        const balance = await solanaConnection.getBalance(new PublicKey(publicKeyString), process.env.RPC_COMMITMENT || 'confirmed');
        return BigInt(balance);
    } catch (error) {
        if (error.message && (error.message.includes("Account does not exist") || error.message.includes("could not find account"))) {
            return 0n; 
        }
        console.error(`${LOG_PREFIX_GSB} Error fetching balance for ${publicKeyString}: ${error.message}`);
        return null; 
    }
}

/**
 * Sends SOL from a payer to a recipient.
 * @param {import('@solana/web3.js').Keypair} payerKeypair - The keypair of the account sending SOL.
 * @param {string} recipientPublicKeyString - The public key string of the recipient.
 * @param {bigint} amountLamports - The amount of SOL to send, in lamports.
 * @param {string} [memoText] - Optional memo text. For production, use @solana/spl-memo.
 * @param {number} [priorityFeeMicroLamportsOverride] - Optional override for priority fee.
 * @param {number} [computeUnitsOverride] - Optional override for compute units.
 * @returns {Promise<{success: boolean, signature?: string, error?: string, errorType?: string, blockTime?: number, feeLamports?: bigint, isRetryable?: boolean}>}
 */
async function sendSol(payerKeypair, recipientPublicKeyString, amountLamports, memoText = null, priorityFeeMicroLamportsOverride = null, computeUnitsOverride = null) {
    const LOG_PREFIX_SENDSOL = `[SendSol From:${payerKeypair.publicKey.toBase58().slice(0,6)} To:${recipientPublicKeyString.slice(0,6)} Amt:${amountLamports}]`;
    
    if (!payerKeypair || typeof payerKeypair.publicKey === 'undefined' || typeof payerKeypair.secretKey === 'undefined') {
        console.error(`${LOG_PREFIX_SENDSOL} Invalid payerKeypair.`);
        return { success: false, error: "Invalid payer keypair.", errorType: "InvalidInputError", isRetryable: false };
    }
    if (!isValidSolanaAddress(recipientPublicKeyString)) {
        console.error(`${LOG_PREFIX_SENDSOL} Invalid recipient public key: ${recipientPublicKeyString}`);
        return { success: false, error: "Invalid recipient address.", errorType: "InvalidInputError", isRetryable: false };
    }
    if (typeof amountLamports !== 'bigint' || amountLamports <= 0n) {
        console.error(`${LOG_PREFIX_SENDSOL} Invalid amount: ${amountLamports}. Must be > 0.`);
        return { success: false, error: "Invalid amount (must be > 0).", errorType: "InvalidInputError", isRetryable: false };
    }

    const transaction = new Transaction();
    const instructions = [];

    const computeUnitLimit = computeUnitsOverride || parseInt(process.env.PAYOUT_COMPUTE_UNIT_LIMIT, 10);
    const effectivePriorityFeeMicroLamports = priorityFeeMicroLamportsOverride !== null ? priorityFeeMicroLamportsOverride : parseInt(process.env.PAYOUT_BASE_PRIORITY_FEE_MICROLAMPORTS, 10);
    const maxPriorityFeeMicroLamports = parseInt(process.env.PAYOUT_MAX_PRIORITY_FEE_MICROLAMPORTS, 10);
    
    const finalPriorityFee = Math.min(effectivePriorityFeeMicroLamports, maxPriorityFeeMicroLamports);

    if (computeUnitLimit > 0) {
        instructions.push(ComputeBudgetProgram.setComputeUnitLimit({ units: computeUnitLimit }));
    }
    if (finalPriorityFee > 0) {
        instructions.push(ComputeBudgetProgram.setComputeUnitPrice({ microLamports: finalPriorityFee }));
    }

    instructions.push(
        SystemProgram.transfer({
            fromPubkey: payerKeypair.publicKey,
            toPubkey: new PublicKey(recipientPublicKeyString),
            lamports: amountLamports,
        })
    );

    if (memoText && typeof memoText === 'string' && memoText.trim().length > 0) {
        // console.log(`${LOG_PREFIX_SENDSOL} Conceptual Memo: "${memoText.trim()}". Use @solana/spl-memo.`); // Reduced log
        // Example: instructions.push(createMemoInstruction(memoText.trim(), [payerKeypair.publicKey]));
    }
    
    transaction.add(...instructions);

    let signature = null;
    let retries = 0;
    const maxRetriesConfig = parseInt(process.env.RPC_MAX_RETRIES, 10); 
    const sendAndConfirmMaxRetries = 3; 
    let retryDelayMs = parseInt(process.env.INITIAL_RETRY_POLLING_DELAY, 10);
    const maxRetryDelayMs = parseInt(process.env.MAX_RETRY_POLLING_DELAY, 10);
    const rpcCommitment = process.env.RPC_COMMITMENT || 'confirmed';

    while (retries < maxRetriesConfig) {
        try {
            // console.log(`${LOG_PREFIX_SENDSOL} Attempt ${retries + 1}/${maxRetriesConfig}: Sending transaction...`); // Reduced log
            
            const { blockhash } = await solanaConnection.getLatestBlockhash(rpcCommitment);
            transaction.recentBlockhash = blockhash;
            transaction.feePayer = payerKeypair.publicKey;

            signature = await sendAndConfirmTransaction(
                solanaConnection,
                transaction,
                [payerKeypair],
                {
                    commitment: rpcCommitment,
                    skipPreflight: false,
                    preflightCommitment: rpcCommitment,
                    maxRetries: sendAndConfirmMaxRetries 
                }
            );
            
            console.log(`${LOG_PREFIX_SENDSOL} ✅ TX successful! Sig: ${signature}. Commit: ${rpcCommitment}.`);
            
            let blockTime = null;
            let feeLamports = null;
            try {
                const confirmedTx = await solanaConnection.getTransaction(signature, {commitment: rpcCommitment, maxSupportedTransactionVersion: 0 });
                if (confirmedTx && confirmedTx.blockTime && confirmedTx.meta) {
                    blockTime = confirmedTx.blockTime;
                    feeLamports = BigInt(confirmedTx.meta.fee);
                    // console.log(`${LOG_PREFIX_SENDSOL} Tx details: BlockTime: ${blockTime}, Fee: ${feeLamports}`); // Reduced log
                } else {
                    // console.warn(`${LOG_PREFIX_SENDSOL} Could not fetch full tx details for ${signature}.`); // Reduced log
                }
            } catch (fetchErr) {
                console.warn(`${LOG_PREFIX_SENDSOL} Could not fetch confirmed tx details for ${signature}: ${fetchErr.message}`);
            }
            
            return { success: true, signature, blockTime, feeLamports };

        } catch (error) {
            retries++;
            const errorMessage = error.message || String(error);
            let isRetryableError = false; 
            console.error(`${LOG_PREFIX_SENDSOL} ❌ Attempt ${retries}/${maxRetriesConfig} failed: ${errorMessage}`);
            if (error.stack && retries === maxRetriesConfig) console.error(error.stack.substring(0, 500)); 

            if (error instanceof TransactionExpiredBlockheightExceededError) {
                // console.warn(`${LOG_PREFIX_SENDSOL} Transaction expired. Retrying with new blockhash.`); // Reduced log
                isRetryableError = true;
            } else if (error instanceof SendTransactionError) {
                const transactionLogs = error.logs;
                if (transactionLogs) {
                    // console.error(`${LOG_PREFIX_SENDSOL} Tx logs from SendTransactionError:\n${transactionLogs.join('\n')}`); // Too verbose for regular retry
                    if (transactionLogs.some(log => log.toLowerCase().includes("insufficient lamports"))) {
                        return { success: false, error: "Insufficient SOL to cover transaction fee or amount.", errorType: "InsufficientFundsError", isRetryable: false };
                    }
                    if (transactionLogs.some(log => log.toLowerCase().includes("custom program error") || log.toLowerCase().includes("error processing instruction"))) {
                        return { success: false, error: `Transaction failed: Program error. See logs.`, errorType: "ProgramError", isRetryable: false };
                    }
                }
                isRetryableError = true; 
            } else if (errorMessage.includes("signers") && errorMessage.includes("Transaction was not signed by all")) {
                console.error(`${LOG_PREFIX_SENDSOL} Signing error (code issue).`);
                return {success: false, error: "Transaction signing failed.", errorType: "SigningError", isRetryable: false};
            } else if (errorMessage.toLowerCase().includes("blockhash not found") || errorMessage.toLowerCase().includes("timeout")) {
                isRetryableError = true; 
            }

            if (!isRetryableError || retries >= maxRetriesConfig) {
                console.error(`${LOG_PREFIX_SENDSOL} Max retries or non-retryable error. TX failed permanently.`);
                return { success: false, error: `Transaction failed after ${retries} attempts: ${errorMessage}`, errorType: error.constructor?.name || "UnknownError", isRetryable: false };
            }

            // console.log(`${LOG_PREFIX_SENDSOL} Retrying in ${retryDelayMs / 1000}s...`); // Reduced log
            await sleep(retryDelayMs);
            retryDelayMs = Math.min(retryDelayMs * 2, maxRetryDelayMs); 
        }
    }
    return { success: false, error: "Transaction failed after all attempts.", errorType: "MaxRetriesReached", isRetryable: false };
}

// --- End of Part P1 ---
// --- Start of Part P2 (MODIFIED to include calculateUserRank and call checkAndUpdateUserLevel) ---
// index.js - Part P2: Payment System Database Operations
//---------------------------------------------------------------------------
// Assumed global `pool`, `queryDatabase`,
// `escapeMarkdownV2`, `formatCurrency`, `stringifyWithBigInt`,
// `generateReferralCode`, `getNextAddressIndexForUserDB`,
// `activeDepositAddresses` cache map, `walletCache` map are available.
// Constants like SOL_DECIMALS, LAMPORTS_PER_SOL are assumed available.
// Assumed `checkAndUpdateUserLevel` is defined (e.g., in Part 2).
// Assumed `processQualifyingBetAndInitialBonus` and `processWagerMilestoneBonus` are defined (e.g., in Part 3).
// Assumed `getSolUsdPrice` is available (e.g., from Part 1).

// --- Unified User/Wallet Operations ---

/**
 * Fetches payment-system relevant details for a user.
 * @param {string|number} telegramId The user's Telegram ID.
 * @param {import('pg').PoolClient} [client=pool] Optional database client.
 * @returns {Promise<object|null>} User details with BigInt conversions or null if not found/error.
 */
async function getPaymentSystemUserDetails(telegramId, client = pool) {
    const stringUserId = String(telegramId);
    const LOG_PREFIX_GPSUD = `[GetUserPayDetails TG:${stringUserId}]`;
    // Carefully re-typed SQL query string
    const query = `
SELECT
    telegram_id,
    username,
    first_name,
    last_name,
    balance,
    solana_wallet_address,
    referral_code,
    referrer_telegram_id,
    can_generate_deposit_address,
    last_deposit_address,
    last_deposit_address_generated_at,
    total_deposited_lamports,
    total_withdrawn_lamports,
    total_wagered_lamports,
    total_won_lamports,
    notes,
    created_at,
    updated_at
FROM users
WHERE telegram_id = $1;
`; // Ensure no trailing/leading hidden characters around this backtick or within the string

    try {
        const res = await queryDatabase(query, [stringUserId], client);
        if (res.rows.length > 0) {
            const details = res.rows[0];
            details.telegram_id = String(details.telegram_id); 
            details.balance = BigInt(details.balance || '0');
            details.total_deposited_lamports = BigInt(details.total_deposited_lamports || '0');
            details.total_withdrawn_lamports = BigInt(details.total_withdrawn_lamports || '0');
            details.total_wagered_lamports = BigInt(details.total_wagered_lamports || '0');
            details.total_won_lamports = BigInt(details.total_won_lamports || '0');
            if (details.referrer_telegram_id) {
                details.referrer_telegram_id = String(details.referrer_telegram_id);
            }
            return details;
        }
        return null;
    } catch (err) {
        console.error(`${LOG_PREFIX_GPSUD} ❌ Error fetching user details: ${err.message}`, err.stack?.substring(0,500));
        // Re-throw the error so the caller (handleWalletCommand) can catch it and inform the user appropriately
        throw err; 
    }
}

/**
 * Finds a user by their referral code.
 * @param {string} refCode The referral code.
 * @param {import('pg').PoolClient} [client=pool] Optional database client.
 * @returns {Promise<{telegram_id: string, username?:string, first_name?:string} | null>} User ID (as string) and basic info or null.
 */
async function getUserByReferralCode(refCode, client = pool) {
    const LOG_PREFIX_GUBRC = `[GetUserByRefCode Code:${refCode}]`;
    if (!refCode || typeof refCode !== 'string' || refCode.trim() === "") {
        // console.warn(`${LOG_PREFIX_GUBRC} Invalid or empty referral code provided.`); // Reduced log
        return null;
    }
    try {
        const result = await queryDatabase('SELECT telegram_id, username, first_name FROM users WHERE referral_code = $1', [refCode.trim()], client);
        if (result.rows.length > 0) {
            const userFound = result.rows[0];
            userFound.telegram_id = String(userFound.telegram_id); 
            return userFound;
        }
        return null;
    } catch (err) {
        console.error(`${LOG_PREFIX_GUBRC} ❌ Error finding user by referral code: ${err.message}`, err.stack?.substring(0,500));
        return null;
    }
}

// --- Unified Balance & Ledger Operations ---

/**
 * Atomically updates a user's balance and records the change in the ledger table.
 * This is the PRIMARY function for all financial transactions affecting user balance.
 * MUST be called within an active DB transaction if part of a larger multi-step operation.
 * The `dbClient` parameter MUST be an active client from `pool.connect()`.
 *
 * @param {import('pg').PoolClient} dbClient - The active database client.
 * @param {string|number} telegramId - The user's Telegram ID.
 * @param {bigint} changeAmountLamports - Positive for credit, negative for debit.
 * @param {string} transactionType - Type for the ledger.
 * @param {object} [relatedIds={}] Optional related IDs.
 * @param {string|null} [notes=null] Optional notes for the ledger entry.
 * @returns {Promise<{success: boolean, newBalanceLamports?: bigint, oldBalanceLamports?: bigint, ledgerId?: number, error?: string, errorCode?: string}>}
 */
// FINAL-FIX updateUserBalanceAndLedger (with Explicit Type Casting for Nulls)
async function updateUserBalanceAndLedger(dbClient, telegramId, changeAmountLamports, transactionType, relatedIds = {}, notes = null, solPrice = 0) {
    const stringUserId = String(telegramId);
    const changeAmount = BigInt(changeAmountLamports);
    const logPrefix = `[UpdateBalLedger_V5_TypecastFix UID:${stringUserId}]`;

    if (!dbClient || typeof dbClient.query !== 'function') {
        return { success: false, error: 'Invalid database client provided.', errorCode: 'INVALID_DB_CLIENT' };
    }

    try {
        const selectUserSQL = `SELECT balance, total_deposited_lamports, total_withdrawn_lamports, total_wagered_lamports, total_won_lamports FROM users WHERE telegram_id = $1 FOR UPDATE`;
        const balanceRes = await dbClient.query(selectUserSQL, [stringUserId]);
        
        if (balanceRes.rowCount === 0) {
            return { success: false, error: 'User profile not found for balance update.', errorCode: 'USER_NOT_FOUND' };
        }

        const userData = balanceRes.rows[0];
        const oldBalanceLamports = BigInt(userData.balance);
        const balanceAfter = oldBalanceLamports + changeAmount;

        if (balanceAfter < 0n && !transactionType.startsWith('admin_grant_')) {
            return { success: false, error: 'Insufficient balance.', errorCode: 'INSUFFICIENT_FUNDS' };
        }

        let newTotalDeposited = BigInt(userData.total_deposited_lamports || '0');
        let newTotalWithdrawn = BigInt(userData.total_withdrawn_lamports || '0');
        let newTotalWagered = BigInt(userData.total_wagered_lamports || '0');
        let newTotalWon = BigInt(userData.total_won_lamports || '0');
        const notificationsToReturn = [];

        if (transactionType === 'deposit') {
            newTotalDeposited += changeAmount;
        } else if (transactionType.startsWith('withdrawal')) {
            newTotalWithdrawn -= changeAmount;
        } else if (transactionType.startsWith('bet_placed')) {
            const betAmount = -changeAmount;
            newTotalWagered += betAmount;
        } else if (transactionType.startsWith('win_')) {
            const originalBetAmount = BigInt(relatedIds.original_bet_amount || '0');
            const profit = changeAmount - originalBetAmount;
            if (profit > 0n) {
                newTotalWon += profit;
            }
        } else if (transactionType.startsWith('push_') || transactionType.startsWith('refund_')) {
            const betAmountRefunded = changeAmount;
            if (betAmountRefunded > 0n) {
                newTotalWagered -= betAmountRefunded;
            }
        } else if (transactionType.startsWith('level_up') || transactionType.startsWith('referral_commission') || transactionType === 'tip_received') {
            newTotalWon += changeAmount;
        }
        
        const updateUserQuery = `UPDATE users SET balance = $1, total_deposited_lamports = $2, total_withdrawn_lamports = $3, total_wagered_lamports = $4, total_won_lamports = $5, updated_at = NOW() WHERE telegram_id = $6;`;
        await dbClient.query(updateUserQuery, [balanceAfter.toString(), newTotalDeposited.toString(), newTotalWithdrawn.toString(), newTotalWagered.toString(), newTotalWon.toString(), stringUserId]);

        // --- FIX IS HERE: Added ::INTEGER casts to nullable ID parameters ---
        const ledgerQuery = `INSERT INTO ledger (user_telegram_id, transaction_type, amount_lamports, balance_before_lamports, balance_after_lamports, deposit_id, withdrawal_id, game_log_id, referral_id, related_sweep_id, notes, created_at) VALUES ($1, $2, $3, $4, $5, $6::INTEGER, $7::INTEGER, $8::INTEGER, $9::INTEGER, $10::INTEGER, $11, NOW()) RETURNING ledger_id;`;
        
        await dbClient.query(ledgerQuery, [
            stringUserId, 
            transactionType, 
            changeAmount.toString(), 
            oldBalanceLamports.toString(), 
            balanceAfter.toString(), 
            relatedIds?.deposit_id || null, 
            relatedIds?.withdrawal_id || null, 
            relatedIds?.game_log_id || null, 
            relatedIds?.referral_id || null, 
            relatedIds?.related_sweep_id || null, 
            notes
        ]);
        
        return { success: true, newBalanceLamports: balanceAfter, newTotalWageredLamports: newTotalWagered, notifications: notificationsToReturn };

    } catch (err) {
        console.error(`${logPrefix} ❌ Error in updateUserBalanceAndLedger: ${err.message}`, err.stack);
        return { success: false, error: err.message, errorCode: err.code };
    }
}

// --- Deposit Address & Deposit Operations ---

/**
 * Finds user ID and other details for a given deposit address. Checks cache first.
 * @param {string} depositAddress The deposit address (public key).
 * @returns {Promise<{userId: string, walletId: number, expiresAt: Date, derivationPath: string, isActive:boolean } | null>}
 */
async function findDepositAddressInfoDB(depositAddress) {
    const LOG_PREFIX_FDAI = `[FindDepositAddr Addr:${depositAddress ? depositAddress.slice(0,6) : 'N/A'}...]`; // Shortened
    if (!depositAddress) {
        // console.warn(`${LOG_PREFIX_FDAI} Called with null or undefined depositAddress.`); // Reduced log
        return null;
    }

    if (typeof activeDepositAddresses !== 'undefined' && activeDepositAddresses instanceof Map) {
        const cached = activeDepositAddresses.get(depositAddress);
        if (cached && Date.now() < cached.expiresAt) {
            // Cache hit is useful, but we often need full details from DB.
        }
    }

    try {
        const res = await queryDatabase(
            'SELECT user_telegram_id, wallet_id, expires_at, derivation_path, is_active FROM user_deposit_wallets WHERE public_key = $1',
            [depositAddress]
        );
        if (res.rows.length > 0) {
            const data = res.rows[0];
            const expiresAtDate = new Date(data.expires_at);
            const isActiveCurrent = data.is_active && expiresAtDate.getTime() > Date.now();
            
            if (typeof activeDepositAddresses !== 'undefined' && activeDepositAddresses instanceof Map) {
                if (isActiveCurrent) {
                    activeDepositAddresses.set(depositAddress, { userId: String(data.user_telegram_id), expiresAt: expiresAtDate.getTime() });
                } else {
                    activeDepositAddresses.delete(depositAddress);
                }
            }
            return { 
                userId: String(data.user_telegram_id), 
                walletId: data.wallet_id, 
                expiresAt: expiresAtDate, 
                derivationPath: data.derivation_path, 
                isActive: isActiveCurrent
            };
        }
        return null;
    } catch (err) {
        console.error(`${LOG_PREFIX_FDAI} ❌ Error finding deposit address info: ${err.message}`, err.stack?.substring(0,500));
        return null;
    }
}

/**
 * Marks a deposit address as inactive and optionally as swept.
 * @param {import('pg').PoolClient} dbClient - The active database client.
 * @param {number} userDepositWalletId - The ID of the `user_deposit_wallets` record.
 * @param {boolean} [swept=false] - If true, also sets swept_at.
 * @param {bigint|null} [balanceAtSweep=null] - Optional balance at time of sweep.
 * @returns {Promise<boolean>} True if updated successfully.
 */
async function markDepositAddressInactiveDB(dbClient, userDepositWalletId, swept = false, balanceAtSweep = null) {
    const LOG_PREFIX_MDAI = `[MarkDepositAddrInactive WID:${userDepositWalletId} Swept:${swept}]`; // Shortened
    try {
        let query = 'UPDATE user_deposit_wallets SET is_active = FALSE, updated_at = NOW()';
        const params = [];
        let paramIndex = 1;

        if (swept) {
            query += `, swept_at = NOW()`;
            if (balanceAtSweep !== null && typeof balanceAtSweep === 'bigint') {
                query += `, balance_at_sweep = $${paramIndex++}`;
                params.push(balanceAtSweep.toString());
            } else if (balanceAtSweep === null && swept) { 
                query += `, balance_at_sweep = NULL`;
            }
        }
        query += ` WHERE wallet_id = $${paramIndex++} RETURNING public_key, is_active;`;
        params.push(userDepositWalletId);

        const res = await dbClient.query(query, params);
        if (res.rowCount > 0) {
            const updatedWallet = res.rows[0];
            if (typeof activeDepositAddresses !== 'undefined' && activeDepositAddresses instanceof Map) {
                activeDepositAddresses.delete(updatedWallet.public_key);
            }
            // console.log(`${LOG_PREFIX_MDAI} ✅ Marked wallet ID ${userDepositWalletId} (Addr: ${updatedWallet.public_key.slice(0,6)}) as inactive/swept. Active: ${updatedWallet.is_active}`); // Reduced log
            return true;
        }
        console.warn(`${LOG_PREFIX_MDAI} ⚠️ Wallet ID ${userDepositWalletId} not found or no change made.`);
        return false;
    } catch (err) {
        console.error(`${LOG_PREFIX_MDAI} ❌ Error marking deposit address inactive: ${err.message}`, err.stack?.substring(0,500));
        return false;
    }
}

/**
 * Records a confirmed deposit transaction. Must be called within a transaction using dbClient.
 * @param {import('pg').PoolClient} dbClient
 * @param {string|number} userId
 * @param {number} userDepositWalletId
 * @param {string} depositAddress
 * @param {string} txSignature
 * @param {bigint} amountLamports
 * @param {string|null} [sourceAddress=null]
 * @param {number|null} [blockTime=null]
 * @returns {Promise<{success: boolean, depositId?: number, error?: string, alreadyProcessed?: boolean}>}
 */
async function recordConfirmedDepositDB(dbClient, userId, userDepositWalletId, depositAddress, txSignature, amountLamports, sourceAddress = null, blockTime = null) {
    const stringUserId = String(userId);
    const LOG_PREFIX_RCD = `[RecordDeposit UID:${stringUserId} TX:${txSignature.slice(0,10)}...]`;
    const query = `
        INSERT INTO deposits (user_telegram_id, user_deposit_wallet_id, deposit_address, transaction_signature, amount_lamports, source_address, block_time, confirmation_status, processed_at, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, 'confirmed', NOW(), NOW(), NOW())
        ON CONFLICT (transaction_signature) DO NOTHING 
        RETURNING deposit_id;
    `;
    try {
        const res = await dbClient.query(query, [stringUserId, userDepositWalletId, depositAddress, txSignature, amountLamports.toString(), sourceAddress, blockTime]);
        if (res.rowCount > 0 && res.rows[0].deposit_id) {
            // console.log(`${LOG_PREFIX_RCD} ✅ Deposit recorded successfully. DB ID: ${res.rows[0].deposit_id}`); // Reduced log
            return { success: true, depositId: res.rows[0].deposit_id };
        }
        const existing = await dbClient.query('SELECT deposit_id FROM deposits WHERE transaction_signature = $1', [txSignature]);
        if (existing.rowCount > 0) {
            console.warn(`${LOG_PREFIX_RCD} ⚠️ Deposit TX ${txSignature} already processed (DB ID: ${existing.rows[0].deposit_id}).`);
            return { success: false, error: 'Deposit already processed.', alreadyProcessed: true, depositId: existing.rows[0].deposit_id };
        }
        console.error(`${LOG_PREFIX_RCD} ❌ Failed to record deposit (not duplicate) for TX ${txSignature}.`);
        return { success: false, error: 'Failed to record deposit (unknown issue after conflict check).' };
    } catch(err) {
        console.error(`${LOG_PREFIX_RCD} ❌ Error recording deposit: ${err.message} (Code: ${err.code})`, err.stack?.substring(0,500));
        return { success: false, error: err.message, errorCode: err.code };
    }
}

// --- Sweep Operations ---
/**
 * Records a successful sweep transaction. Must be called within a transaction using dbClient.
 * @param {import('pg').PoolClient} dbClient
 * @param {string} sourceDepositAddress
 * @param {string} destinationMainAddress
 * @param {bigint} amountLamports
 * @param {string} transactionSignature
 * @returns {Promise<{success: boolean, sweepId?: number, error?: string}>}
 */
async function recordSweepTransactionDB(dbClient, sourceDepositAddress, destinationMainAddress, amountLamports, transactionSignature) {
    const LOG_PREFIX_RST = `[RecordSweepTX From:${sourceDepositAddress.slice(0,6)} To:${destinationMainAddress.slice(0,6)} TX:${transactionSignature.slice(0,10)}...]`;
    const query = `
        INSERT INTO processed_sweeps (source_deposit_address, destination_main_address, amount_lamports, transaction_signature, swept_at)
        VALUES ($1, $2, $3, $4, NOW())
        ON CONFLICT (transaction_signature) DO UPDATE SET swept_at = NOW() 
        RETURNING sweep_id;
    `; 
    try {
        const res = await dbClient.query(query, [sourceDepositAddress, destinationMainAddress, amountLamports.toString(), transactionSignature]);
        if (res.rowCount > 0 && res.rows[0].sweep_id) {
            // console.log(`${LOG_PREFIX_RST} ✅ Sweep transaction recorded. DB ID: ${res.rows[0].sweep_id}`); // Reduced log
            return { success: true, sweepId: res.rows[0].sweep_id };
        }
        console.error(`${LOG_PREFIX_RST} ❌ Failed to record sweep transaction or get ID back for TX ${transactionSignature}.`);
        return { success: false, error: 'Failed to record sweep transaction or retrieve ID.' };
    } catch (err) {
        console.error(`${LOG_PREFIX_RST} ❌ Error recording sweep TX: ${err.message} (Code: ${err.code})`, err.stack?.substring(0,500));
        return { success: false, error: err.message, errorCode: err.code };
    }
}

// --- Withdrawal Database Operations ---
async function createWithdrawalRequestDB(dbClient, userId, requestedAmountLamports, feeLamports, recipientAddress, priorityFeeMicroLamports = null, computeUnitLimit = null) {
    const stringUserId = String(userId);
    const LOG_PREFIX_CWR = `[CreateWithdrawalReq UID:${stringUserId} Addr:${recipientAddress.slice(0,6)}]`;
    const query = `
        INSERT INTO withdrawals (user_telegram_id, destination_address, amount_lamports, fee_lamports, status, priority_fee_microlamports, compute_unit_limit, requested_at, updated_at)
        VALUES ($1, $2, $3, $4, 'pending_processing', $5, $6, NOW(), NOW())
        RETURNING withdrawal_id;
    `;
    try {
        const res = await dbClient.query(query, [stringUserId, recipientAddress, requestedAmountLamports.toString(), feeLamports.toString(), priorityFeeMicroLamports, computeUnitLimit]);
        if (res.rows.length > 0 && res.rows[0].withdrawal_id) {
            // console.log(`${LOG_PREFIX_CWR} ✅ Withdrawal request created. DB ID: ${res.rows[0].withdrawal_id}`); // Reduced log
            return { success: true, withdrawalId: res.rows[0].withdrawal_id };
        }
        throw new Error("Withdrawal request creation failed to return ID.");
    } catch (err) {
        console.error(`${LOG_PREFIX_CWR} ❌ Error creating withdrawal request: ${err.message}`, err.stack?.substring(0,500));
        return { success: false, error: err.message, errorCode: err.code };
    }
}

async function updateWithdrawalStatusDB(dbClient, withdrawalId, status, signature = null, errorMessage = null, blockTime = null) {
    const LOG_PREFIX_UWS = `[UpdateWithdrawalStatus ID:${withdrawalId} Status:${status}]`;
    // MODIFIED SQL Query: Added ::VARCHAR to $1
    const query = `
        UPDATE withdrawals 
        SET status = $1::VARCHAR,  -- Explicit cast for status
            transaction_signature = $2, 
            error_message = $3, 
            block_time = $4,
            processed_at = CASE WHEN $1::VARCHAR IN ('completed', 'failed', 'confirmed', 'sent') THEN NOW() ELSE processed_at END, -- Explicit cast here too
            updated_at = NOW()
        WHERE withdrawal_id = $5
        RETURNING withdrawal_id;
    `;
    try {
        // Parameters: [status, signature, errorMessage, blockTime, withdrawalId]
        const res = await dbClient.query(query, [status, signature, errorMessage, blockTime, withdrawalId]);
        if (res.rowCount > 0) {
            // console.log(`${LOG_PREFIX_UWS} ✅ Withdrawal status updated successfully.`); // Reduced log
            return { success: true, withdrawalId: res.rows[0].withdrawal_id };
        }
        console.warn(`${LOG_PREFIX_UWS} ⚠️ Withdrawal ID ${withdrawalId} not found or no status update made (rowCount 0).`);
        return { success: false, error: "Withdrawal record not found or no update made." };
    } catch (err) {
        // This console.error is what you're seeing in your logs for this specific error
        console.error(`${LOG_PREFIX_UWS} ❌ Error updating withdrawal status: ${err.message}`, err.stack?.substring(0,500));
        return { success: false, error: err.message, errorCode: err.code };
    }
}

async function getWithdrawalDetailsDB(withdrawalId, dbClient = pool) {
    const LOG_PREFIX_GWD = `[GetWithdrawalDetails ID:${withdrawalId}]`;
    try {
        const res = await dbClient.query('SELECT * FROM withdrawals WHERE withdrawal_id = $1', [withdrawalId]);
        if (res.rows.length > 0) {
            const details = res.rows[0];
            details.amount_lamports = BigInt(details.amount_lamports);
            details.fee_lamports = BigInt(details.fee_lamports);
            details.user_telegram_id = String(details.user_telegram_id);
            return details;
        }
        return null;
    } catch (err) {
        console.error(`${LOG_PREFIX_GWD} ❌ Error fetching withdrawal details: ${err.message}`, err.stack?.substring(0,500));
        return null;
    }
}

// --- Referral Payout Database Operations ---
/**
 * Records that a referral has met criteria and commission is earned (but not yet paid).
 * Assumes a referral link record already exists from getOrCreateUser.
 * @param {import('pg').PoolClient} dbClient
 * @param {string|number} referrerUserId
 * @param {string|number} referredUserId
 * @param {string} commissionType e.g., 'first_deposit_bonus'
 * @param {bigint} commissionAmountLamports Amount earned.
 * @returns {Promise<{success: boolean, referralId?: number, error?: string}>}
 */
async function recordReferralCommissionEarnedDB(dbClient, referrerUserId, referredUserId, commissionType, commissionAmountLamports) {
    const LOG_PREFIX_RRCE = `[RecordRefCommEarn RefBy:${referrerUserId} RefTo:${referredUserId}]`;
    const query = `
        UPDATE referrals
        SET commission_type = $1, commission_amount_lamports = $2, status = 'earned', updated_at = NOW()
        WHERE referrer_telegram_id = $3 AND referred_telegram_id = $4 AND status = 'pending_criteria'
        RETURNING referral_id;
    `;
    try {
        const res = await dbClient.query(query, [commissionType, commissionAmountLamports.toString(), referrerUserId, referredUserId]);
        if (res.rowCount > 0) {
            console.log(`${LOG_PREFIX_RRCE} ✅ Referral commission of ${commissionAmountLamports} earned. DB ID: ${res.rows[0].referral_id}`);
            return { success: true, referralId: res.rows[0].referral_id };
        }
        // console.warn(`${LOG_PREFIX_RRCE} No eligible 'pending_criteria' referral found or already processed.`); // Can be noisy
        return { success: false, error: "No eligible pending referral found or already processed." };
    } catch (err) {
        console.error(`${LOG_PREFIX_RRCE} ❌ Error recording referral commission earned: ${err.message}`, err.stack?.substring(0,500));
        return { success: false, error: err.message, errorCode: err.code };
    }
}

/**
 * Updates a referral record status, typically after a payout attempt.
 * @param {import('pg').PoolClient} dbClient
 * @param {number} referralId
 * @param {'processing' | 'paid_out' | 'failed'} status
 * @param {string|null} [transactionSignature=null]
 * @param {string|null} [errorMessage=null]
 * @returns {Promise<{success: boolean, error?: string}>}
 */
async function updateReferralPayoutStatusDB(dbClient, referralId, status, transactionSignature = null, errorMessage = null) {
    const LOG_PREFIX_URPS = `[UpdateRefPayoutStatus ID:${referralId} Status:${status}]`;
    const query = `
        UPDATE referrals
        SET status = $1, transaction_signature = $2, updated_at = NOW(),
            notes = CASE WHEN $3 IS NOT NULL THEN COALESCE(notes, '') || 'Payout Error: ' || $3 ELSE notes END
        WHERE referral_id = $4 AND status != 'paid_out' 
        RETURNING referral_id;
    `;
    try {
        const res = await dbClient.query(query, [status, transactionSignature, errorMessage, referralId]);
        if (res.rowCount > 0) {
            // console.log(`${LOG_PREFIX_URPS} ✅ Referral payout status updated.`); // Reduced log
            return { success: true };
        }
        // console.warn(`${LOG_PREFIX_URPS} Referral ID ${referralId} not found or already paid out/no status change needed.`); // Can be noisy
        return { success: false, error: "Referral not found or no update made." };
    } catch (err) {
        console.error(`${LOG_PREFIX_URPS} ❌ Error updating referral payout status: ${err.message}`, err.stack?.substring(0,500));
        return { success: false, error: err.message, errorCode: err.code };
    }
}

async function getReferralDetailsDB(referralId, dbClient = pool) {
    const LOG_PREFIX_GRD = `[GetReferralDetails ID:${referralId}]`;
    try {
        const res = await dbClient.query('SELECT * FROM referrals WHERE referral_id = $1', [referralId]);
        if (res.rows.length > 0) {
            const details = res.rows[0];
            details.referrer_telegram_id = String(details.referrer_telegram_id);
            details.referred_telegram_id = String(details.referred_telegram_id);
            if (details.commission_amount_lamports) {
                details.commission_amount_lamports = BigInt(details.commission_amount_lamports);
            }
            return details;
        }
        return null;
    } catch (err) {
        console.error(`${LOG_PREFIX_GRD} ❌ Error fetching referral details: ${err.message}`, err.stack?.substring(0,500));
        return null;
    }
}

async function getTotalReferralEarningsDB(userId, dbClient = pool) {
    const stringUserId = String(userId);
    const LOG_PREFIX_GTRE = `[GetTotalRefEarnings UID:${stringUserId}]`;
    try {
        const query = `
            SELECT 
                COALESCE(SUM(CASE WHEN status = 'paid_out' THEN commission_amount_lamports ELSE 0 END), 0) AS total_earned_paid_lamports,
                COALESCE(SUM(CASE WHEN status = 'earned' THEN commission_amount_lamports ELSE 0 END), 0) AS total_pending_payout_lamports
            FROM referrals
            WHERE referrer_telegram_id = $1;
        `;
        const res = await dbClient.query(query, [stringUserId]);
        if (res.rows.length > 0) {
            return {
                total_earned_paid_lamports: BigInt(res.rows[0].total_earned_paid_lamports),
                total_pending_payout_lamports: BigInt(res.rows[0].total_pending_payout_lamports)
            };
        }
        return { total_earned_paid_lamports: 0n, total_pending_payout_lamports: 0n };
    } catch (err) {
        console.error(`${LOG_PREFIX_GTRE} ❌ Error fetching total referral earnings: ${err.message}`, err.stack?.substring(0,500));
        return { total_earned_paid_lamports: 0n, total_pending_payout_lamports: 0n };
    }
}

// --- Bet History & Leaderboard Database Operations ---
/**
 * Gets transaction history for a user from the ledger.
 * @param {string|number} userId
 * @param {number} [limit=10]
 * @param {number} [offset=0]
 * @param {string|null} [transactionTypeFilter=null] e.g., 'deposit', 'withdrawal%', 'bet%', 'win%' (SQL LIKE pattern)
 * @param {import('pg').PoolClient} [client=pool]
 * @returns {Promise<Array<object>>} Array of ledger entries with BigInt amounts.
 */
async function getBetHistoryDB(userId, limit = 10, offset = 0, transactionTypeFilter = null, client = pool) {
    const stringUserId = String(userId);
    const LOG_PREFIX_GBH = `[GetBetHistory UID:${stringUserId}]`;
    try {
        let queryText = `
            SELECT l.ledger_id, l.transaction_type, l.amount_lamports, l.balance_after_lamports, l.notes, l.created_at,
                   d.transaction_signature as deposit_tx, w.transaction_signature as withdrawal_tx,
                   g.game_type as game_log_type, g.outcome as game_log_outcome
            FROM ledger l
            LEFT JOIN deposits d ON l.deposit_id = d.deposit_id
            LEFT JOIN withdrawals w ON l.withdrawal_id = w.withdrawal_id
            LEFT JOIN games g ON l.game_log_id = g.game_log_id
            WHERE l.user_telegram_id = $1 
        `;
        const params = [stringUserId];
        let paramIndex = 2;
        if (transactionTypeFilter) {
            queryText += ` AND l.transaction_type ILIKE $${paramIndex++}`;
            params.push(transactionTypeFilter);
        }
        queryText += ` ORDER BY l.created_at DESC LIMIT $${paramIndex++} OFFSET $${paramIndex++};`;
        params.push(limit, offset);

        const res = await queryDatabase(queryText, params, client);
        return res.rows.map(row => ({
            ...row,
            amount_lamports: BigInt(row.amount_lamports),
            balance_after_lamports: BigInt(row.balance_after_lamports)
        }));
    } catch (err) {
        console.error(`${LOG_PREFIX_GBH} ❌ Error fetching ledger history: ${err.message}`, err.stack?.substring(0,500));
        return [];
    }
}

async function getLeaderboardDataDB(type = 'total_wagered', period = 'all_time', limit = 10) {
    const LOG_PREFIX_GLD = `[GetLeaderboard Type:${type} Period:${period}]`;
    // console.log(`${LOG_PREFIX_GLD} Fetching leaderboard data...`); // Reduced log
    let orderByField = 'total_wagered_lamports'; 
    if (type === 'total_won') {
        orderByField = 'total_won_lamports';
    } else if (type === 'net_profit') {
        orderByField = '(total_won_lamports - total_wagered_lamports)'; // Actual calculation for net profit
        // console.warn(`${LOG_PREFIX_GLD} 'net_profit' leaderboard type selected.`); // Informative, can be kept or removed
    }

    if (period !== 'all_time') {
        console.warn(`${LOG_PREFIX_GLD} Period '${period}' not yet implemented. Defaulting to 'all_time'.`);
        // Future: Add date range filtering to the WHERE clause based on `period`.
    }

    const query = `
        SELECT telegram_id, username, first_name, ${orderByField} AS stat_value_ordered
        FROM users
        WHERE is_banned = FALSE
        ORDER BY stat_value_ordered DESC, updated_at DESC
        LIMIT $1;
    `;
    try {
        const res = await queryDatabase(query, [limit]);
        return res.rows.map(row => ({
            telegram_id: String(row.telegram_id),
            username: row.username,
            first_name: row.first_name,
            stat_value: BigInt(row.stat_value_ordered) 
        }));
    } catch (err) {
        console.error(`${LOG_PREFIX_GLD} ❌ Error fetching leaderboard data: ${err.message}`, err.stack?.substring(0,500));
        return [];
    }
}

// --- NEW Function to Calculate User Rank ---
/**
 * Calculates the user's rank based on total_wagered_lamports.
 * @param {string} userId - The user's Telegram ID.
 * @param {import('pg').PoolClient} [dbClient=pool] - Optional database client.
 * @returns {Promise<number|null>} The user's rank or null if not found/error.
 */
async function calculateUserRank(userId, dbClient = pool) {
    const LOG_PREFIX_CALC_RANK = `[CalculateUserRank UID:${userId}]`;
    try {
        const query = `
            WITH ranked_users AS (
                SELECT
                    telegram_id,
                    total_wagered_lamports,
                    RANK() OVER (ORDER BY total_wagered_lamports DESC, created_at ASC) as user_rank
                FROM users
                WHERE is_banned = FALSE -- Consider if you want to exclude banned users from rank calculation basis
            )
            SELECT user_rank
            FROM ranked_users
            WHERE telegram_id = $1;
        `;
        const result = await queryDatabase(query, [userId], dbClient); // queryDatabase is from Part 1

        if (result.rows.length > 0) {
            return parseInt(result.rows[0].user_rank, 10);
        }
        console.warn(`${LOG_PREFIX_CALC_RANK} User not found in ranking query.`);
        return null;
    } catch (error) {
        console.error(`${LOG_PREFIX_CALC_RANK} Error calculating user rank: ${error.message}`, error.stack);
        return null;
    }
}


// --- Dice Roll Request Database Operations ---

/**
 * Inserts a new dice roll request into the database for the Helper Bot to process.
 * MUST be called within an active DB transaction if atomicity with other operations is required.
 * @param {import('pg').PoolClient} dbClient - The active database client.
 * @param {string} gameId - Identifier for the game requesting the roll.
 * @param {string|number} chatId - The chat ID where the dice should be sent.
 * @param {string|number} [userId=null] - The user ID associated with this roll, if applicable.
 * @param {string} [emojiType='🎲'] - The emoji type for bot.sendDice.
 * @param {string|null} [notes=null] - Optional notes for the request.
 * @param {string|null} [handlerType=null] - Optional: Specific handler type for dedicated helpers (e.g., 'DICE_21_ROLL').
 * @returns {Promise<{success: boolean, requestId?: number, error?: string, errorCode?: string}>}
 */
async function insertDiceRollRequest(dbClient, gameId, chatId, userId = null, emojiType = '🎲', notes = null, handlerType = null) {
    const stringChatId = String(chatId);
    const stringUserId = userId ? String(userId) : null;
    const logPrefix = `[InsertDiceReq GID:${gameId} UID:${stringUserId || 'Bot'} HType:${handlerType || 'ANY'}]`;

    if (!dbClient || typeof dbClient.query !== 'function') {
        console.error(`${logPrefix} 🚨 CRITICAL: dbClient is not a valid database client.`);
        return { success: false, error: 'Invalid database client for insertDiceRollRequest.' };
    }
    const query = `
        INSERT INTO dice_roll_requests 
            (game_id, chat_id, user_id, emoji_type, status, notes, requested_at, handler_type)
        VALUES ($1, $2, $3, $4, 'pending', $5, NOW(), $6) -- Added $6 for handler_type
        RETURNING request_id;
    `;
    try {
        const params = [gameId, stringChatId, stringUserId, emojiType, notes, handlerType]; // Pass handlerType
        const res = await dbClient.query(query, params);
        if (res.rows.length > 0 && res.rows[0].request_id) {
            // console.log(`${logPrefix} ✅ Dice roll request created. DB ID: ${res.rows[0].request_id}`); // Can be noisy
            return { success: true, requestId: res.rows[0].request_id };
        }
        throw new Error("Dice roll request creation failed to return ID.");
    } catch (err) {
        // FIX APPLIED HERE: Using the correct logPrefix variable
        console.error(`${logPrefix} ❌ Error creating dice roll request: ${err.message}`, err.stack?.substring(0,500));
        return { success: false, error: err.message, errorCode: err.code };
    }
}

/**
 * Retrieves the status and result of a specific dice roll request.
 * @param {import('pg').PoolClient} dbClient - The active database client.
 * @param {number} requestId - The ID of the dice_roll_requests record.
 * @returns {Promise<{success: boolean, status?: string, roll_value?: number, notes?: string, error?: string}>}
 */
async function getDiceRollRequestResult(dbClient, requestId) {
    const logPrefix = `[GetDiceReqResult RID:${requestId}]`;

    if (!dbClient || typeof dbClient.query !== 'function') {
        console.error(`${logPrefix} 🚨 CRITICAL: dbClient is not a valid database client.`);
        return { success: false, error: 'Invalid database client for getDiceRollRequestResult.' };
    }
    const query = `
        SELECT status, roll_value, notes
        FROM dice_roll_requests
        WHERE request_id = $1;
    `;

    // --- NEW DEBUG LOGS TO ADD ---
    console.log(`[DEBUG] Executing query in getDiceRollRequestResult.`);
    console.log(`[DEBUG] Query Text Length: ${query.length}`);
    console.log(`[DEBUG] Request ID Parameter: ${requestId} (Type: ${typeof requestId})`);
    // --- END OF DEBUG LOGS ---

    try {
        const res = await dbClient.query(query, [requestId]);
        if (res.rows.length > 0) {
            const data = res.rows[0];
            return {
                success: true,
                status: data.status,
                roll_value: data.roll_value,
                notes: data.notes
            };
        }
        return { success: false, error: 'Request ID not found.' };
    } catch (err) {
        // Using the correct logPrefix variable
        console.error(`${logPrefix} ❌ Error fetching dice roll request result: ${err.message}`, err.stack?.substring(0,500));
        return { success: false, error: err.message, errorCode: err.code };
    }
}

/**
 * Sets the user's solana_wallet_address to NULL in the database.
 * @param {string} userId - The user's Telegram ID.
 * @param {import('pg').PoolClient} dbClient - The active database client.
 * @returns {Promise<{success: boolean, error?: string}>}
 */
async function unlinkUserWalletDB(userId, dbClient) {
    const LOG_PREFIX_UNLINK = `[UnlinkWalletDB UID:${userId}]`;
    try {
        const result = await dbClient.query(
            'UPDATE users SET solana_wallet_address = NULL, updated_at = NOW() WHERE telegram_id = $1',
            [userId]
        );
        if (result.rowCount > 0) {
            console.log(`${LOG_PREFIX_UNLINK} Wallet unlinked successfully for user ${userId}.`);
            if (walletCache && walletCache.has(String(userId))) { // Assuming walletCache is accessible
                walletCache.delete(String(userId));
                console.log(`${LOG_PREFIX_UNLINK} Cleared wallet from cache for user ${userId}.`);
            }
            return { success: true };
        } else {
            console.warn(`${LOG_PREFIX_UNLINK} User ${userId} not found or wallet already unlinked. No rows updated.`);
            return { success: false, error: "User not found or wallet already unlinked." };
        }
    } catch (error) {
        console.error(`${LOG_PREFIX_UNLINK} Error unlinking wallet: ${error.message}`, error.stack);
        return { success: false, error: error.message };
    }
}

async function logGameResultToGamesTable(dbClient, gameType, chatId, initiatorId, participantsIds, betAmountLamports, outcomeText, jackpotContributionLamports = null) {
    const LOG_PREFIX_LOG_GAME = `[LogGameToGamesTable Type:${gameType}]`;
    try {
        const query = `
            INSERT INTO games (game_type, chat_id, initiator_telegram_id, participants_ids, bet_amount_lamports, outcome, jackpot_contribution_lamports, game_timestamp)
            VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
            RETURNING game_log_id;
        `;
        // Ensure participantsIds is an array of strings or null for the DB
        const participantsDbArray = participantsIds ? participantsIds.map(id => String(id)) : null;

        const params = [
            String(gameType),
            String(chatId),
            String(initiatorId),
            participantsDbArray,
            betAmountLamports.toString(),
            String(outcomeText).substring(0, 255), // Ensure outcomeText is not too long
            jackpotContributionLamports ? jackpotContributionLamports.toString() : null
        ];
        const res = await dbClient.query(query, params);
        if (res.rows.length > 0 && res.rows[0].game_log_id) {
            console.log(`${LOG_PREFIX_LOG_GAME} Game logged with game_log_id: ${res.rows[0].game_log_id}`);
            return Number(res.rows[0].game_log_id);
        }
        console.error(`${LOG_PREFIX_LOG_GAME} Failed to insert game log or retrieve game_log_id.`);
        return null;
    } catch (error) {
        console.error(`${LOG_PREFIX_LOG_GAME} Error logging game to games table: ${error.message}`, error.stack);
        // Do not throw here if called within a larger transaction that might want to proceed with partial success or specific error handling.
        // The caller should check for null and decide how to proceed.
        return null;
    }
}

// --- End of Part P2 ---
// --- Start of Part P3 ---
// index.js - Part P3: Payment System UI Handlers, Stateful Logic & Webhook Setup
//---------------------------------------------------------------------------
// Assumed global utilities, constants, DB ops, Solana utils, cache utils,
// and processing queues from previous parts are available.

// --- User State Management ---
function clearUserState(userId) {
    const stringUserId = String(userId);
    const state = userStateCache.get(stringUserId);
    if (state) {
        if (state.data?.timeoutId) clearTimeout(state.data.timeoutId);
        userStateCache.delete(stringUserId);
    }
}

async function routeStatefulInput(msg, currentState) {
    const userId = String(msg.from.id);
    const chatId = String(msg.chat.id);
    const text = msg.text || '';
    const stateName = currentState.state || currentState.action;
    const logPrefix = `[StatefulInput UID:${userId} State:${stateName}]`;

    if (currentState.chatId && String(currentState.chatId) !== chatId) {
        console.warn(`${logPrefix} Stateful input in wrong chat (${chatId}) vs expected (${currentState.chatId})\\.`);
        await safeSendMessage(chatId, "Please respond to my previous question in our direct message chat\\. 💬", {parse_mode: 'MarkdownV2'});
        return;
    }

    switch (stateName) {
        case 'awaiting_withdrawal_address':
            await handleWalletAddressInput(msg, currentState);
            break;
        case 'awaiting_withdrawal_amount':
            await handleWithdrawalAmountInput(msg, currentState);
            break;
        default:
            console.warn(`${logPrefix} Unknown or unhandled state: ${stateName}\\. Clearing state\\.`);
            clearUserState(userId);
            await safeSendMessage(chatId, "Your previous action seems to have expired or was unclear.\\nPlease try again using a command from the main menu\\. 🤔", { parse_mode: 'MarkdownV2' });
    }
}

async function handleWalletAddressInput(msg, currentState) {
    const userId = String(msg.from.id);
    const dmChatId = String(msg.chat.id); 
    const potentialNewAddress = msg.text ? msg.text.trim() : '';
    const logPrefix = `[WalletAddrInput_V2 UID:${userId}]`; // V2 for NoBR

    if (!currentState || !currentState.data || currentState.state !== 'awaiting_withdrawal_address' || dmChatId !== userId) {
        console.error(`${logPrefix} Invalid state or context for wallet address input. State ChatID: ${currentState?.chatId}, Msg ChatID: ${dmChatId}, State: ${currentState?.state}`);
        clearUserState(userId);
        await safeSendMessage(dmChatId, "⚙️ There was an issue processing your address input.\nPlease restart from the <code>/wallet</code> menu or use <code>/setwallet YOUR_ADDRESS</code>.", { parse_mode: 'HTML' });
        return;
    }

    const { originalPromptMessageId, originalGroupChatId, originalGroupMessageId } = currentState.data;
    if (originalPromptMessageId && bot) { await bot.deleteMessage(dmChatId, originalPromptMessageId).catch(() => {}); }
    clearUserState(userId);

    const linkingMsgText = `🔗 Validating and attempting to link wallet: <code>${escapeHTML(potentialNewAddress)}</code>...\nPlease hold on a moment.`;
    const linkingMsg = await safeSendMessage(dmChatId, linkingMsgText, { parse_mode: 'HTML' });
    const displayMsgIdInDm = linkingMsg ? linkingMsg.message_id : null;

    try {
        if (!isValidSolanaAddress(potentialNewAddress)) {
            throw new Error("The provided address has an invalid Solana address format.\nPlease double-check and try again.");
        }

        const linkResult = await linkUserWallet(userId, potentialNewAddress); 
        let feedbackText;
        const finalKeyboard = { inline_keyboard: [[{ text: '💳 Back to Wallet Menu', callback_data: 'menu:wallet' }]] };

        if (linkResult.success) {
            feedbackText = linkResult.message ? escapeHTML(linkResult.message.replace(/\\([\`*_~()])/g, '$1')) : `✅ Success! Wallet <code>${escapeHTML(potentialNewAddress)}</code> has been successfully linked to your account.`;
             if (originalGroupChatId && originalGroupMessageId && bot) {
                 const userForGroupMsg = await getOrCreateUser(userId); 
                 await bot.editMessageText(`${escapeHTML(getPlayerDisplayReference(userForGroupMsg || msg.from))} has successfully updated their linked wallet.`, {chat_id: originalGroupChatId, message_id: originalGroupMessageId, parse_mode: 'HTML', reply_markup: {}}).catch(()=>{});
             }
        } else {
            feedbackText = `⚠️ Wallet Link Failed for <code>${escapeHTML(potentialNewAddress)}</code>.\n<b>Reason:</b> ${escapeHTML((linkResult.error || "Please ensure the address is valid and not already in use.").replace(/\\([\`*_~()])/g, '$1'))}`;
            if (originalGroupChatId && originalGroupMessageId && bot) {
                const userForGroupMsg = await getOrCreateUser(userId);
                await bot.editMessageText(`${escapeHTML(getPlayerDisplayReference(userForGroupMsg || msg.from))}, there was an issue linking your wallet. Please check my DM for details and try again.`, {chat_id: originalGroupChatId, message_id: originalGroupMessageId, parse_mode: 'HTML', reply_markup: {}}).catch(()=>{});
            }
        }

        if (displayMsgIdInDm && bot) {
            await bot.editMessageText(feedbackText, { chat_id: dmChatId, message_id: displayMsgIdInDm, parse_mode: 'HTML', reply_markup: finalKeyboard });
        } else {
            await safeSendMessage(dmChatId, feedbackText, { parse_mode: 'HTML', reply_markup: finalKeyboard });
        }
    } catch (e) {
        console.error(`${logPrefix} Error linking wallet ${potentialNewAddress}: ${e.message}`);
        const errorMessageContent = String(e.message || "An unexpected error occurred.").replace(/<br\s*\/?>/gi, '\n');
        const errorTextToDisplay = `⚠️ Error with wallet address: <code>${escapeHTML(potentialNewAddress)}</code>.\n<b>Details:</b> ${escapeHTML(errorMessageContent)}\nPlease ensure it's a valid Solana public key and try again.`;
        const errorKeyboard = { inline_keyboard: [[{ text: '💳 Try Again (Wallet Menu)', callback_data: 'menu:wallet' }]] };
        
        if (displayMsgIdInDm && bot) {
            await bot.editMessageText(errorTextToDisplay, { chat_id: dmChatId, message_id: displayMsgIdInDm, parse_mode: 'HTML', reply_markup: errorKeyboard });
        } else {
            await safeSendMessage(dmChatId, errorTextToDisplay, { parse_mode: 'HTML', reply_markup: errorKeyboard });
        }
        if (originalGroupChatId && originalGroupMessageId && bot) {
            const userForGroupMsg = await getOrCreateUser(userId);
            await bot.editMessageText(`${escapeHTML(getPlayerDisplayReference(userForGroupMsg || msg.from))}, there was an error processing your wallet address. Please check my DM.`, {chat_id: originalGroupChatId, message_id: originalGroupMessageId, parse_mode: 'HTML', reply_markup: {}}).catch(()=>{});
        }
    }
}

async function handleWithdrawalAmountInput(msg, currentState) {
    const userId = String(msg.from.id);
    const dmChatId = String(msg.chat.id); 
    const textAmount = msg.text ? msg.text.trim() : '';
    const logPrefix = `[WithdrawAmountInput_HTML_V5_NoBR UID:${userId}]`; // V5_NoBR

    if (!currentState || !currentState.data || currentState.state !== 'awaiting_withdrawal_amount' || dmChatId !== userId ||
        !currentState.data.linkedWallet || typeof currentState.data.currentBalanceLamportsStr !== 'string') {
        console.error(`${logPrefix} Invalid state or data at START. State: ${stringifyWithBigInt(currentState).substring(0,300)}`);
        clearUserState(userId);
        await safeSendMessage(dmChatId, "⚙️ Error: Withdrawal context lost or invalid.\nPlease restart the withdrawal process from the <code>/wallet</code> menu.", { parse_mode: 'HTML' });
        return;
    }

    const { linkedWallet, originalPromptMessageId, currentBalanceLamportsStr, originalGroupChatId, originalGroupMessageId } = currentState.data;
    const currentBalanceLamports = BigInt(currentBalanceLamportsStr);
    if (originalPromptMessageId && bot) { await bot.deleteMessage(dmChatId, originalPromptMessageId).catch(() => {}); }
    clearUserState(userId); 

    try {
        const solPrice = await getSolUsdPrice(); 
        const effectiveMinWithdrawalLamports = convertUSDToLamports(MIN_WITHDRAWAL_USD_val, solPrice);
        const minWithdrawDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(effectiveMinWithdrawalLamports, 'USD'));

        let amountUSD;
        let amountLamports;

        if (textAmount.toLowerCase() === 'max') {
            const availableToWithdrawAfterFee = currentBalanceLamports - WITHDRAWAL_FEE_LAMPORTS;
            if (availableToWithdrawAfterFee < effectiveMinWithdrawalLamports) {
                throw new Error(`Your balance is too low to withdraw the maximum after fees.\nYou need at least <b>${minWithdrawDisplayUSD_HTML}</b> (plus fee) to make a withdrawal.`);
            }
            amountLamports = availableToWithdrawAfterFee; 
            amountUSD = parseFloat(Number(amountLamports) / Number(LAMPORTS_PER_SOL) * solPrice);
        } else {
            amountUSD = parseFloat(String(textAmount).replace(/[^0-9.]/g, ''));
            if (isNaN(amountUSD) || amountUSD <= 0) {
                throw new Error("Invalid number format or non-positive amount.\nPlease enter a value like <code>50</code> or <code>75.50</code>, or type <code>max</code>.");
            }
            amountLamports = convertUSDToLamports(amountUSD, solPrice); 
        }
        
        const feeLamports = WITHDRAWAL_FEE_LAMPORTS; 
        const totalDeductionLamports = amountLamports + feeLamports; 
        
        const currentBalanceDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(currentBalanceLamports, 'USD')); 
        const amountToWithdrawDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(amountLamports, 'USD')); 
        const feeDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(feeLamports, 'USD'));
        const totalDeductionDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(totalDeductionLamports, 'USD')); 

        if (amountLamports < effectiveMinWithdrawalLamports) {
            throw new Error(`Withdrawal amount of <b>${amountToWithdrawDisplayUSD_HTML}</b> is less than the minimum of <b>${minWithdrawDisplayUSD_HTML}</b> (approx. $${escapeHTML(MIN_WITHDRAWAL_USD_val.toFixed(2))}).`);
        }
        if (currentBalanceLamports < totalDeductionLamports) {
            throw new Error(`Insufficient balance. You need <b>${totalDeductionDisplayUSD_HTML}</b> (amount to receive + fee) to withdraw <b>${amountToWithdrawDisplayUSD_HTML}</b>.\nYour current balance is approx. <b>${currentBalanceDisplayUSD_HTML}</b>.`);
        }

        const confirmationTextHTML = `⚜️ <b>Withdrawal Confirmation</b> ⚜️\n\n` +
                                     `Please review and confirm your withdrawal:\n\n` +
                                     `🔹 Amount You Will Receive: <b>${amountToWithdrawDisplayUSD_HTML}</b>\n` +
                                     `🔹 Withdrawal Fee: <b>${feeDisplayUSD_HTML}</b>\n` +
                                     `🔹 Total Deducted From Your Balance: <b>${totalDeductionDisplayUSD_HTML}</b>\n` +
                                     `🔹 Recipient Wallet: <code>${escapeHTML(linkedWallet)}</code>\n\n` +
                                     `⚠️ Double-check the recipient address! Transactions are irreversible. Proceed?`;

        const sentConfirmMsg = await safeSendMessage(dmChatId, confirmationTextHTML, {
            parse_mode: 'HTML',
            reply_markup: { inline_keyboard: [
                [{ text: '✅ Yes, Confirm Withdrawal', callback_data: `process_withdrawal_confirm:yes` }],
                [{ text: '❌ No, Cancel', callback_data: `process_withdrawal_confirm:no` }]
            ]}
        });

        if (sentConfirmMsg?.message_id) {
            const stateToSetForConfirmation = {
                state: 'awaiting_withdrawal_confirmation',
                chatId: dmChatId,
                messageId: sentConfirmMsg.message_id,
                data: { 
                    linkedWallet: linkedWallet, 
                    amountLamportsStr: amountLamports.toString(),
                    feeLamportsStr: feeLamports.toString(), 
                    originalGroupChatId, 
                    originalGroupMessageId 
                },
                timestamp: Date.now()
            };
            userStateCache.set(userId, stateToSetForConfirmation);
            console.log(`${logPrefix} State SET for awaiting_withdrawal_confirmation. MsgID: ${sentConfirmMsg.message_id}`);
            
            if (originalGroupChatId && originalGroupMessageId && bot) { 
                const userForGroupMsg = await getOrCreateUser(userId);
                await bot.editMessageText(`${escapeHTML(getPlayerDisplayReference(userForGroupMsg || {id: userId, first_name: "Player"}))}, please check your DMs to confirm your withdrawal request.`, {chat_id: originalGroupChatId, message_id: Number(originalGroupMessageId), parse_mode:'HTML', reply_markup:{}}).catch(()=>{});
            }
        } else {
            throw new Error("Failed to send withdrawal confirmation message.\nPlease try again.");
        }
    } catch (e) {
        console.error(`${logPrefix} Error processing withdrawal amount: ${e.message}`);
        const errorMessageContent = String(e.message || "An unexpected error occurred.").replace(/<br\s*\/?>/gi, '\n');
        const errorText = `⚠️ <b>Withdrawal Amount Error:</b>\n${escapeHTML(errorMessageContent)}\nPlease restart the withdrawal process from the <code>/wallet</code> menu.`;
        
        await safeSendMessage(dmChatId, errorText, {
            parse_mode: 'HTML', reply_markup: { inline_keyboard: [[{ text: '💳 Back to Wallet', callback_data: 'menu:wallet' }]] }
        });
        
        if (originalGroupChatId && originalGroupMessageId && bot) { 
            const userForGroupMsg = await getOrCreateUser(userId);
            await bot.editMessageText(`${escapeHTML(getPlayerDisplayReference(userForGroupMsg || {id: userId, first_name: "Player"}))}, there was an error with your withdrawal amount. Please check my DM.`, {chat_id: originalGroupChatId, message_id: Number(originalGroupMessageId), parse_mode:'HTML', reply_markup:{}}).catch(()=>{});
        }
    }
}

// REVISED handleWalletCommand (from Part P3)
// Uses HTML parse_mode; ensure newlines are \n and dynamic content is escaped.
async function handleWalletCommand(receivedMsgObject) {
    const isFromMenuAction = receivedMsgObject && receivedMsgObject.originalChatInfo !== undefined;
    const actualFromObject = receivedMsgObject.from;
    const actualChatObject = receivedMsgObject.chat;
    let userIdFromInput;

    if (actualFromObject && actualFromObject.telegram_id) userIdFromInput = String(actualFromObject.telegram_id);
    else if (actualFromObject && actualFromObject.id) userIdFromInput = String(actualFromObject.id);
    else {
        const tempChatIdError = actualChatObject?.id || ADMIN_USER_ID || 'unknown_chat';
        console.error(`[WalletCmd] CRITICAL: Could not determine userId from receivedMsgObject.from: ${JSON.stringify(actualFromObject)}`);
        await safeSendMessage(tempChatIdError, "An internal error occurred (User ID missing for Wallet). Please try <code>/start</code>.", { parse_mode: 'HTML' });
        return;
    }

    const userId = userIdFromInput;
    const commandChatId = String(actualChatObject.id);
    const LOG_PREFIX_WALLET_CMD = `[WalletCmd_HTML_V7_FontFix UID:${userId}]`; // V7

    let userObject = await getOrCreateUser(userId, actualFromObject?.username, actualFromObject?.first_name, actualFromObject?.last_name);
    if (!userObject) {
        const tempPlayerRef = getPlayerDisplayReference(actualFromObject);
        const errorMessage = `Error fetching your player profile, ${escapeHTML(tempPlayerRef)}. Please try <code>/start</code> again.`;
        await safeSendMessage(userId, errorMessage, { parse_mode: 'HTML' });
        return;
    }
    const playerRefHTML = escapeHTML(getPlayerDisplayReference(userObject));
    clearUserState(userId);

    let botUsername = BOT_NAME || "our bot";
    try { const selfInfo = await bot.getMe(); if(selfInfo.username) botUsername = selfInfo.username; } catch(e) { /* ignore */ }
    const botUsernameHTML = escapeHTML(botUsername);

    const targetDmChatId = userId;
    let messageIdToEditOrDeleteInDm = receivedMsgObject.message_id;

    if (messageIdToEditOrDeleteInDm && targetDmChatId === commandChatId) {
        if (!isFromMenuAction && receivedMsgObject.text && receivedMsgObject.text.startsWith('/wallet')) {
            await bot.deleteMessage(targetDmChatId, messageIdToEditOrDeleteInDm).catch(()=>{});
            messageIdToEditOrDeleteInDm = null; 
        }
    }
    
    const loadingDmMsgText = "Loading your Wallet Dashboard... ⏳";
    let workingMessageId = messageIdToEditOrDeleteInDm;

    if (workingMessageId) { 
        try {
            await bot.editMessageText(loadingDmMsgText, { chat_id: targetDmChatId, message_id: workingMessageId, parse_mode: 'HTML', reply_markup: {inline_keyboard: []} });
        } catch (editError) {
            if (!editError.message?.includes("message is not modified")) { 
                console.warn(`${LOG_PREFIX_WALLET_CMD} Failed to edit message ${workingMessageId} to 'Loading...'. Error: ${editError.message}. Will send new message.`);
                const tempMsg = await safeSendMessage(targetDmChatId, loadingDmMsgText, {parse_mode: 'HTML'});
                workingMessageId = tempMsg?.message_id; 
            }
        }
    } else { 
        const tempMsg = await safeSendMessage(targetDmChatId, loadingDmMsgText, {parse_mode: 'HTML'});
        workingMessageId = tempMsg?.message_id;
    }
    
    if (!workingMessageId) {
        console.error(`${LOG_PREFIX_WALLET_CMD} Failed to establish message context (workingMessageId) for wallet display in DM.`);
        await safeSendMessage(targetDmChatId, "Sorry, there was an issue loading your wallet. Please try again via /start.", {parse_mode: 'HTML'});
        return;
    }
    
    try {
        const userDetails = await getPaymentSystemUserDetails(userId); 
        if (!userDetails) {
            const noUserText = `😕 Could not retrieve your player profile. Please try <code>/start</code> to the bot first.`;
            await bot.editMessageText(noUserText, {chat_id: targetDmChatId, message_id: workingMessageId, parse_mode: 'HTML', reply_markup: {inline_keyboard: [[{text: "Go to /start", callback_data:"menu:main"}]]}});
            return;
        }

        const balanceLamports = BigInt(userDetails.balance || '0');
        const linkedAddress = userDetails.solana_wallet_address;
        const balanceUSD_HTML = escapeHTML(await formatBalanceForDisplay(balanceLamports, 'USD')); 
        const linkedAddress_display_HTML = linkedAddress ? `<code>${escapeHTML(linkedAddress)}</code>` : "<i>Not Set - Essential for Withdrawals!</i>";

        // *** MODIFIED PART: Replaced <font> with <i> for the note ***
        let textHTML = `⚜️ <b>Your Casino Wallet Dashboard</b> ⚜️\n\n` +
                       `👤 Player: ${playerRefHTML}\n\n` +
                       `💰 Current USD Balance:\n   <b>${balanceUSD_HTML}</b>\n` +
                       `   <i>(Based on live SOL/USD rates)</i>\n\n` + // Replaced <font> with <i>
                       `🔗 Linked Withdrawal Address:\n   ${linkedAddress_display_HTML}\n\n`;
        // *** END OF MODIFIED PART ***
        
        if (!linkedAddress) {
            textHTML += `💡 Please link a wallet to enable withdrawals.\n\n`;
        }
        textHTML += `-------------------------------\nWhat would you like to do?`;

        const keyboardActions = [
        // NEW: Deposit buttons are now on their own row
        [{ text: "➕ Deposit SOL", callback_data: "menu:deposit:sol" }, { text: "➕ Deposit LTC", callback_data: "menu:deposit:ltc" }],
        // Withdraw is now on its own dedicated row
        [{ text: "➖ Withdraw SOL", callback_data: WITHDRAW_CALLBACK_ACTION_CONST }],
        // The rest of the buttons remain the same
        [{ text: "📜 Transaction History", callback_data: "menu:history" }],
        linkedAddress 
            ? [{ text: "🔄 Update/Unlink Wallet", callback_data: "menu:link_wallet_prompt" }] 
            : [{ text: "🔗 Link Withdrawal Wallet", callback_data: "menu:link_wallet_prompt" }],
        [{ text: "🎲 View Games & Rules", callback_data: "menu:rules_list" }, { text: "🤝 Referrals", callback_data: "menu:referral" }], 
        [{ text: "🌟 Level Up Bonus", callback_data: "menu:bonus_dashboard_back" }],
        [{ text: "🏛️ Main Menu", callback_data: "menu:main" }] 
    ];
        if(ADMIN_USER_ID === userId && typeof getAdminPanelKeyboard === "function"){ 
             keyboardActions.unshift([{ text: "👑 Admin Panel", callback_data: "menu:admin_main" }]);
        }

        const keyboard = { inline_keyboard: keyboardActions };

        await bot.editMessageText(textHTML, { chat_id: targetDmChatId, message_id: workingMessageId, parse_mode: 'HTML', reply_markup: keyboard, disable_web_page_preview: true });

    } catch (error) {
        console.error(`${LOG_PREFIX_WALLET_CMD} ❌ Error displaying wallet: ${error.message}`, error.stack?.substring(0,500));
        const errorTextForUserHTML = `⚙️ Apologies, we encountered an issue displaying your wallet information. (<code>${escapeHTML(String(error.message || "Unknown error").replace(/<br\s*\/?>/gi, '\n'))}</code>).\nYou can try <code>/start</code>.`;
        await bot.editMessageText(errorTextForUserHTML, {
            chat_id: targetDmChatId, 
            message_id: workingMessageId, 
            parse_mode: 'HTML', 
            reply_markup: {inline_keyboard: [[{text: "Try /start", callback_data:"menu:main"}]]}
        }).catch(async (editFallbackError) => {
            console.warn(`${LOG_PREFIX_WALLET_CMD} Failed to edit error message, sending new. Edit fallback error: ${editFallbackError.message}`);
            await safeSendMessage(targetDmChatId, errorTextForUserHTML, {parse_mode: 'HTML', reply_markup: {inline_keyboard: [[{text: "Try /start", callback_data:"menu:main"}]]} }); 
        });
    }
}

// REPLACE your existing handleLitecoinDepositRequest function with this new version

async function handleLitecoinDepositRequest(msgOrCbMsg) {
    const userId = String(msgOrCbMsg.from.id || msgOrCbMsg.from.telegram_id);
    const dmChatId = userId;
    const originalMessageId = msgOrCbMsg.message_id;
    const logPrefix = `[LTCDepositRequest_V4_HTMLFix UID:${userId}]`;

    if (originalMessageId) {
        await bot.deleteMessage(dmChatId, originalMessageId).catch(() => {});
    }

    const workingMsg = await safeSendMessage(dmChatId, "⏳ Generating your unique Litecoin deposit address...", { parse_mode: 'HTML' });
    const workingMessageId = workingMsg?.message_id;

    if (!workingMessageId) {
        console.error(`${logPrefix} Failed to establish message context for LTC deposit display.`);
        return;
    }

    let client = null;
    try {
        client = await pool.connect();
        await client.query('BEGIN');

        const userObject = await getOrCreateUser(userId, msgOrCbMsg.from.username, msgOrCbMsg.from.first_name, msgOrCbMsg.from.last_name);
        const playerRefHTML = escapeHTML(getPlayerDisplayReference(userObject));

        const existingAddressRes = await client.query(
            "SELECT address, expires_at FROM ltc_user_deposit_wallets WHERE user_telegram_id = $1 AND is_active = TRUE AND expires_at > NOW() ORDER BY created_at DESC LIMIT 1",
            [userId]
        );

        let depositAddress;
        let expiresAtDate;
        let newAddressGenerated = false;

        if (existingAddressRes.rows.length > 0) {
            depositAddress = existingAddressRes.rows[0].address;
            expiresAtDate = new Date(existingAddressRes.rows[0].expires_at);
        } else {
            const safeUserAccountIndex = createSafeUserSpecificIndex(userId);
            const addressIndexResult = await client.query('SELECT COUNT(*) FROM ltc_user_deposit_wallets WHERE user_telegram_id = $1', [userId]);
            const addressIndex = parseInt(addressIndexResult.rows[0].count, 10);
            
            const derivationPath = `m/44'/2'/${safeUserAccountIndex}'/0/${addressIndex}`;
            const { address } = deriveLitecoinAddress(process.env.LITECOIN_MASTER_SEED_PHRASE, derivationPath);

            expiresAtDate = new Date(Date.now() + (24 * 60 * 60 * 1000));

            await client.query(
                `INSERT INTO ltc_user_deposit_wallets (user_telegram_id, address, derivation_path, expires_at, is_active) VALUES ($1, $2, $3, $4, TRUE)`,
                [userId, address, derivationPath, expiresAtDate]
            );
            depositAddress = address;
            newAddressGenerated = true;
        }

        await client.query('COMMIT');
        
        const timeRemainingMs = expiresAtDate.getTime() - Date.now();
        const timeRemainingMinutes = Math.max(1, Math.floor(timeRemainingMs / (60 * 1000)));
        const expiryDateTimeString = expiresAtDate.toLocaleString('en-GB', { hour: '2-digit', minute: '2-digit', day: '2-digit', month: 'short', timeZone: 'UTC' }) + " UTC";

        const message = `💰 <b>Your ${newAddressGenerated ? 'New' : 'Active'} Litecoin Deposit Address</b>\n\n` +
                        `Hi ${playerRefHTML}, please send LTC to your unique deposit address below:\n\n` +
                        `<code>${escapeHTML(depositAddress)}</code>\n` +
                        `<i>(Tap the address above to copy)</i>\n\n` +
                        `This address is valid for approximately <b>${timeRemainingMinutes} minutes</b> (expires around ${expiryDateTimeString}). <u>Do not use after expiry.</u>\n\n` +
                        `Funds require <b>${LTC_DEPOSIT_CONFIRMATIONS}</b> network confirmations to be credited. Deposits are converted to your main SOL balance upon confirmation.\n\n` +
                        // --- FIX IS HERE: Added closing </b> tag ---
                        `⚠️ <b>Important Information:</b>\n` +
                        `• Send only Litecoin (LTC) to this address.\n` +
                        `• Exchange deposits may take longer to confirm.\n` +
                        `• To generate a new address later, use the Deposit option in your /wallet menu.`;

        const solanaPayUrl = `litecoin:${depositAddress}?label=${encodeURIComponent(BOT_NAME + " Deposit")}`;
        const qrCodeUrl = `https://api.qrserver.com/v1/create-qr-code/?size=250x250&data=${encodeURIComponent(solanaPayUrl)}`;

        const depositKeyboard = [
            [{ text: "🔍 View on Blockchair", url: `https://blockchair.com/litecoin/address/${depositAddress}` }],
            [{ text: "📱 Scan QR Code", url: qrCodeUrl }],
            [{ text: "💳 Back to Wallet", callback_data: "menu:wallet" }]
        ];
        const options = { parse_mode: 'HTML', reply_markup: { inline_keyboard: depositKeyboard }, disable_web_page_preview: true };

        await bot.editMessageText(message, { chat_id: dmChatId, message_id: workingMessageId, ...options });

    } catch (error) {
        if (client) await client.query('ROLLBACK');
        console.error(`${logPrefix} Error: ${error.message}`);
        await bot.editMessageText("❌ Failed to generate Litecoin deposit address. Please try again.", {
            chat_id: dmChatId,
            message_id: workingMessageId,
            parse_mode: 'HTML',
            reply_markup: { inline_keyboard: [[{ text: '💳 Back to Wallet', callback_data: 'menu:wallet' }]]}
        });
    } finally {
        if (client) client.release();
    }
}

// REVISED handleSetWalletCommand function (from Part P3)
// Uses MarkdownV2 primarily, so <br> not an issue here, but ensuring consistency.
async function handleSetWalletCommand(msg, args) {
    const userId = String(msg.from.id);
    const commandChatId = String(msg.chat.id);
    const chatType = msg.chat.type;
    const LOG_PREFIX_SETWALLET = `[SetWalletCmd_V2 UID:${userId}]`; // V2

    let userObject = await getOrCreateUser(userId, msg.from.username, msg.from.first_name, msg.from.last_name);
    if (!userObject) { 
        await safeSendMessage(commandChatId, "Error fetching your player profile\\. Please try `/start`\\.", {parse_mode: 'MarkdownV2'});
        return; 
    }
    const playerRef = getPlayerDisplayReference(userObject);
    clearUserState(userId);

    let botUsername = BOT_NAME || "our bot";
    try { const selfInfo = await bot.getMe(); if(selfInfo.username) botUsername = selfInfo.username; } catch(e) { /* ignore */ }

    if (chatType !== 'private') {
        if(msg.message_id && commandChatId !== userId) await bot.deleteMessage(commandChatId, msg.message_id).catch(() => {});
        const dmPrompt = `${playerRef}, for your security, please set your wallet address by sending the command \`/setwallet YOUR_ADDRESS\` directly to me in our private chat: @${escapeMarkdownV2(botUsername)} 💳`;
        await safeSendMessage(commandChatId, dmPrompt, { parse_mode: 'MarkdownV2' });
        await safeSendMessage(userId, `Hi ${playerRef}, to set or update your withdrawal wallet, please reply here with the command:\n\`/setwallet YOUR_SOLANA_ADDRESS\`\n\nExample: \`/setwallet YourSoLaddressHere123...\``, {parse_mode: 'MarkdownV2'});
        return;
    }

    if (args.length < 1 || !args[0].trim()) {
        await safeSendMessage(userId, `💡 To link your Solana wallet for withdrawals, please use the format: \`/setwallet YOUR_SOLANA_ADDRESS\`\n\nExample: \`/setwallet YourSoLaddressHere123...\``, { parse_mode: 'MarkdownV2' });
        return;
    }
    const potentialNewAddress = args[0].trim();

    if(msg.message_id) await bot.deleteMessage(userId, msg.message_id).catch(() => {});

    const linkingMsgText = `🔗 Validating and attempting to link wallet: \`${escapeMarkdownV2(potentialNewAddress)}\`\\.\\.\\. Please hold on\\.`;
    const linkingMsg = await safeSendMessage(userId, linkingMsgText, { parse_mode: 'MarkdownV2' });
    const displayMsgIdInDm = linkingMsg ? linkingMsg.message_id : null;

    try {
        if (!isValidSolanaAddress(potentialNewAddress)) {
            throw new Error("The provided address has an invalid Solana address format\\. Please double\\-check and try again\\.");
        }
        const linkResult = await linkUserWallet(userId, potentialNewAddress); 
        let feedbackText;
        const finalKeyboard = { inline_keyboard: [[{ text: '💳 Back to Wallet Menu', callback_data: 'menu:wallet' }]] };

        if (linkResult.success) {
            feedbackText = linkResult.message || `✅ Success\\! Wallet \`${escapeMarkdownV2(potentialNewAddress)}\` is now linked\\.`;
        } else {
            feedbackText = `⚠️ Wallet Link Failed for \`${escapeMarkdownV2(potentialNewAddress)}\`\\.\n*Reason:* ${linkResult.error || "Please check the address and try again\\."}`;
        }

        if (displayMsgIdInDm && bot) {
            await bot.editMessageText(feedbackText, { chat_id: userId, message_id: displayMsgIdInDm, parse_mode: 'MarkdownV2', reply_markup: finalKeyboard });
        } else {
            await safeSendMessage(userId, feedbackText, { parse_mode: 'MarkdownV2', reply_markup: finalKeyboard });
        }
    } catch (e) {
        console.error(`${LOG_PREFIX_SETWALLET} Error linking wallet ${potentialNewAddress}: ${e.message}`);
        const errorMessageContent = String(e.message || "An unexpected error occurred\\.").replace(/\n/g, '\\n');
        const errorTextToDisplay = `⚠️ Error with wallet address: \`${escapeMarkdownV2(potentialNewAddress)}\`\\.\n*Details:* ${escapeMarkdownV2(errorMessageContent)}\nPlease ensure it's a valid Solana public key\\.`;
        const errorKeyboard = { inline_keyboard: [[{ text: '💳 Try Again (Wallet Menu)', callback_data: 'menu:wallet' }]] };
        
        if (displayMsgIdInDm && bot) {
            await bot.editMessageText(errorTextToDisplay, { chat_id: userId, message_id: displayMsgIdInDm, parse_mode: 'MarkdownV2', reply_markup: errorKeyboard });
        } else {
            await safeSendMessage(userId, errorTextToDisplay, { parse_mode: 'MarkdownV2', reply_markup: errorKeyboard });
        }
    }
}


// REVISED handleDepositCommand
async function handleDepositCommand(msgOrCbMsg, args = [], correctUserIdFromCb = null) {
    const userId = String(correctUserIdFromCb || msgOrCbMsg.from.id);
    const targetDmChatId = userId;
    const originalCommandChatId = String(msgOrCbMsg.chat.id);
    const originalMessageId = msgOrCbMsg.message_id;
    const isCallbackRedirect = msgOrCbMsg.isCallbackRedirect || false;

    const logPrefix = `[DepositCmd UID:${userId} OrigChat:${originalCommandChatId}]`;

    let userObject = await getOrCreateUser(userId, msgOrCbMsg.from?.username, msgOrCbMsg.from?.first_name, msgOrCbMsg.from?.last_name);
    if (!userObject) {
        await safeSendMessage(targetDmChatId, "Error fetching your player profile\\. Please try \`/start\` again\\.", { parse_mode: 'MarkdownV2' });
        return;
    }
    const playerRef = getPlayerDisplayReference(userObject);
    clearUserState(userId);

    let botUsername = "our bot";
    try { const selfInfo = await bot.getMe(); if (selfInfo.username) botUsername = selfInfo.username; } catch (e) { /* Reduced log */ }

    if (originalCommandChatId !== targetDmChatId && !isCallbackRedirect) {
        if (originalMessageId) await bot.deleteMessage(originalCommandChatId, originalMessageId).catch(() => {});
        await safeSendMessage(originalCommandChatId, `${playerRef}, for your security and convenience, I've sent your unique deposit address to our private chat: @${escapeMarkdownV2(botUsername)} 📬 Please check your DMs\\.`, { parse_mode: 'MarkdownV2' });
    }
    
    const generatingText = "⏳ Generating your deposit address... Please wait..."; // Plain text
    let workingMessageId;

    if (originalCommandChatId === targetDmChatId && originalMessageId && !isCallbackRedirect && !msgOrCbMsg.isCallbackRedirect) { // Command typed in DM
        await bot.deleteMessage(targetDmChatId, originalMessageId).catch(()=>{});
        const tempMsg = await safeSendMessage(targetDmChatId, generatingText);
        workingMessageId = tempMsg?.message_id;
    } else if (isCallbackRedirect || (originalCommandChatId === targetDmChatId && (msgOrCbMsg.isCallbackRedirect !== undefined || !!correctUserIdFromCb) )) { 
        // Callback redirected to DM, or callback was already in DM from a menu
        if (originalMessageId && originalCommandChatId === targetDmChatId) { // If callback was in DM, edit that message
            try {
                await bot.editMessageText(generatingText, { chat_id: targetDmChatId, message_id: originalMessageId, reply_markup: { inline_keyboard: [] } });
                workingMessageId = originalMessageId;
            } catch (editError) {
                if (!editError.message?.includes("message is not modified")) {
                    const tempMsg = await safeSendMessage(targetDmChatId, generatingText);
                    workingMessageId = tempMsg?.message_id;
                } else {
                    workingMessageId = originalMessageId;
                }
            }
        } else { // Was a group callback, just send new to DM
            const tempMsg = await safeSendMessage(targetDmChatId, generatingText);
            workingMessageId = tempMsg?.message_id;
        }
    } else { 
         const tempMsg = await safeSendMessage(targetDmChatId, generatingText);
         workingMessageId = tempMsg?.message_id;
    }

    if (!workingMessageId) {
        console.error(`${logPrefix} Failed to establish message context (workingMessageId) for deposit address display in DM.`);
        return;
    }

    let client = null;
    try {
        client = await pool.connect();
        await client.query('BEGIN');

        const confirmationLevelEscaped = escapeMarkdownV2(DEPOSIT_CONFIRMATION_LEVEL || 'confirmed');
        const existingAddressesRes = await client.query(
            "SELECT public_key, expires_at FROM user_deposit_wallets WHERE user_telegram_id = $1 AND is_active = TRUE AND expires_at > NOW() ORDER BY created_at DESC LIMIT 1",
            [userId]
        );

        let depositAddress;
        let expiresAtDate;
        let newAddressGenerated = false;

        if (existingAddressesRes.rows.length > 0) {
            depositAddress = existingAddressesRes.rows[0].public_key;
            expiresAtDate = new Date(existingAddressesRes.rows[0].expires_at);
        } else {
            const newAddressStr = await generateUniqueDepositAddress(userId, client);
            if (!newAddressStr) { throw new Error("Failed to generate a new deposit address\\. Please try again or contact support\\."); }
            depositAddress = newAddressStr;
            newAddressGenerated = true;
            const newAddrDetails = await client.query("SELECT expires_at FROM user_deposit_wallets WHERE public_key = $1 AND user_telegram_id = $2", [depositAddress, userId]);
            expiresAtDate = newAddrDetails.rows.length > 0 ? new Date(newAddrDetails.rows[0].expires_at) : new Date(Date.now() + DEPOSIT_ADDRESS_EXPIRY_MS);
        }

        if (newAddressGenerated || (userObject.last_deposit_address !== depositAddress)) {
            await client.query(
                `UPDATE users SET last_deposit_address = $1, last_deposit_address_generated_at = $2, updated_at = NOW() WHERE telegram_id = $3`,
                [depositAddress, expiresAtDate, userId]
            );
        }
        await client.query('COMMIT');

        const timeRemainingMs = expiresAtDate.getTime() - Date.now();
        const timeRemainingMinutes = Math.max(1, Math.ceil(timeRemainingMs / (60 * 1000)));
        const expiryDateTimeString = expiresAtDate.toLocaleString('en-GB', { hour: '2-digit', minute: '2-digit', day: '2-digit', month: 'short', timeZone: 'UTC' }) + " UTC";

        const escapedAddress = escapeMarkdownV2(depositAddress);
        const timeRemainingMinutesEscaped = escapeMarkdownV2(String(timeRemainingMinutes));
        const expiryDateTimeStringEscaped = escapeMarkdownV2(expiryDateTimeString);

        const message = `💰 *Your ${newAddressGenerated ? 'New' : 'Active'} Deposit Address*\n\n` +
                        `Hi ${playerRef}, please send SOL to your unique deposit address below:\n\n` +
                        `\`${escapedAddress}\`\n` +
                        `_\\(Tap the address above to copy\\)_\n\n` +
                        `This address is valid for approximately *${timeRemainingMinutesEscaped} minutes* \\(expires around ${expiryDateTimeStringEscaped}\\)\\. __Do not use after expiry\\.__\n\n` +
                        `Funds require *${confirmationLevelEscaped}* network confirmations to be credited\\.\n\n` +
                        `⚠️ *Important Information:*\n` +
                        `* Send only SOL to this address\\. Do not send NFTs or other tokens\\.\n` +
                        `* Exchange deposits may take longer to confirm\\.\n` +
                        `* Address is unique to you for this deposit session\\. Do not share it\\.\n` +
                        `* To generate a new address later, please use the \`/deposit\` command or "Deposit SOL" option in your \`/wallet\` menu\\.`;

        const solanaPayUrl = `solana:${depositAddress}?label=${encodeURIComponent(BOT_NAME + " Deposit")}&message=${encodeURIComponent("Casino Deposit for " + playerRef)}`;
        const qrCodeUrl = `https://api.qrserver.com/v1/create-qr-code/?size=250x250&data=${encodeURIComponent(solanaPayUrl)}`;

        const depositKeyboard = [
            [{ text: "🔍 View on Solscan", url: `https://solscan.io/account/${depositAddress}` }],
            [{ text: "📱 Scan QR Code", url: qrCodeUrl }],
            [{ text: "💳 Back to Wallet", callback_data: "menu:wallet" }]
        ];
        const options = { parse_mode: 'MarkdownV2', reply_markup: {inline_keyboard: depositKeyboard}, disable_web_page_preview: true };

        await bot.editMessageText(message, {chat_id: targetDmChatId, message_id: workingMessageId, ...options}).catch(async (e) => {
            if (e.message && (e.message.toLowerCase().includes("can't parse entities") || e.message.toLowerCase().includes("bad request"))) {
                console.error(`❌ ${logPrefix} PARSE ERROR displaying deposit address! Attempting plain text. Original error: ${e.message}`);
                const plainMessage = `Your ${newAddressGenerated ? 'New' : 'Active'} Deposit Address (Tap to copy):\n${depositAddress}\n\nExpires in approx. ${timeRemainingMinutes} minutes (around ${expiryDateTimeString}). Confirmations: ${DEPOSIT_CONFIRMATION_LEVEL || 'confirmed'}.\nImportant: Valid for this session only. Do not use after expiry. Use /deposit for new address. Send SOL only.`;
                const plainKeyboard = {inline_keyboard: [[{ text: 'Back to Wallet', callback_data: 'menu:wallet' }]]};
                await safeSendMessage(targetDmChatId, plainMessage, { reply_markup: plainKeyboard, disable_web_page_preview: true });
                if (workingMessageId) await bot.deleteMessage(targetDmChatId, workingMessageId).catch(()=>{});
            } else if (!e.message?.includes("message is not modified")) {
                console.warn(`${logPrefix} Failed to edit message ${workingMessageId} with deposit address, sending new. Error: ${e.message}`);
                await safeSendMessage(targetDmChatId, message, options);
                if (workingMessageId) await bot.deleteMessage(targetDmChatId, workingMessageId).catch(()=>{});
            }
        });

    } catch (error) {
        if (client) await client.query('ROLLBACK').catch(rbErr => console.error(`${logPrefix} Rollback error: ${rbErr.message}`));
        console.error(`${logPrefix} ❌ Error handling deposit command: ${error.message}`, error.stack?.substring(0, 500));
        const errorText = `⚙️ Apologies, ${playerRef}, we couldn't generate a deposit address for you at this moment: \`${escapeMarkdownV2(error.message)}\`\\. Please try again shortly or contact support\\.`;
        const errorKeyboardButtons = [[{ text: "Try Again", callback_data: DEPOSIT_CALLBACK_ACTION }, { text: "💳 Wallet", callback_data: "menu:wallet" }]];
        const errorOptions = { parse_mode: 'MarkdownV2', reply_markup: {inline_keyboard: errorKeyboardButtons} };
        if (workingMessageId) {
            await bot.editMessageText(errorText, { chat_id: targetDmChatId, message_id: workingMessageId, ...errorOptions })
                .catch(async () => { await safeSendMessage(targetDmChatId, errorText, errorOptions); });
        } else {
            await safeSendMessage(targetDmChatId, errorText, errorOptions);
        }
    } finally {
        if (client) client.release();
    }
}

// Newly ADDED and REVISED handleWithdrawCommand
async function handleWithdrawCommand(msgOrCbMsg, args = [], correctUserIdFromCb = null) {
    const userId = String(correctUserIdFromCb || msgOrCbMsg.from.id || msgOrCbMsg.from.telegram_id);
    const targetDmChatId = userId; 
    const originalCommandChatId = String(msgOrCbMsg.chat.id);
    const originalMessageId = msgOrCbMsg.message_id;
    const isFromMenuActionOrRedirect = (msgOrCbMsg.isCallbackRedirect !== undefined && msgOrCbMsg.isCallbackRedirect) || (correctUserIdFromCb && correctUserIdFromCb === userId);

    const logPrefix = `[WithdrawCmd_HTML_V5_NoBR UID:${userId} OrigChat:${originalCommandChatId}]`; // V5_NoBR

    let userObject = await getOrCreateUser(userId, msgOrCbMsg.from?.username, msgOrCbMsg.from?.first_name, msgOrCbMsg.from?.last_name);
    if (!userObject) {
        await safeSendMessage(targetDmChatId, "Error fetching your player profile for withdrawal.\nPlease try <code>/start</code> again.", { parse_mode: 'HTML' });
        return;
    }
    const playerRefHTML = escapeHTML(getPlayerDisplayReference(userObject));
    clearUserState(userId);

    let botUsername = BOT_NAME || "our bot";
    try { const selfInfo = await bot.getMe(); if (selfInfo.username) botUsername = selfInfo.username; } catch (e) { /* ignore */ }

    if (originalCommandChatId !== targetDmChatId && !isFromMenuActionOrRedirect && !msgOrCbMsg.isCallbackRedirect) {
        if (originalMessageId) await bot.deleteMessage(originalCommandChatId, originalMessageId).catch(() => {});
        await safeSendMessage(originalCommandChatId, `${playerRefHTML}, for your security, withdrawal requests are handled in our private chat: @${escapeHTML(botUsername)} 📬 Please check your DMs.`, { parse_mode: 'HTML' });
    }
    
    if (originalCommandChatId === targetDmChatId && originalMessageId) {
        await bot.deleteMessage(targetDmChatId, originalMessageId).catch(()=>{});
    }

    const loadingDmMsgText = "Preparing your withdrawal request... ⏳";
    const loadingDmMsg = await safeSendMessage(targetDmChatId, loadingDmMsgText, {parse_mode: 'HTML'});
    const workingMessageId = loadingDmMsg?.message_id;

    if (!workingMessageId) {
        console.error(`${logPrefix} Failed to send 'Preparing withdrawal' message to DM.`);
        return;
    }

    try {
        const linkedWallet = await getUserLinkedWallet(userId);
        const currentBalanceLamports = await getUserBalance(userId);

        if (currentBalanceLamports === null) {
            throw new Error("Could not retrieve your current balance.\nPlease try again shortly.");
        }

        if (!linkedWallet) {
            // Corrected: Uses \n\n
            const noWalletText = `⚠️ ${playerRefHTML}, you don't have a Solana withdrawal wallet linked to your account yet!\n\n` +
                                 `Please link a wallet first using the button below, or by typing <code>/setwallet YOUR_SOL_ADDRESS</code> in this chat.`;
            const noWalletKeyboard = { inline_keyboard: [
                [{ text: "🔗 Link Withdrawal Wallet Now", callback_data: "menu:link_wallet_prompt" }],
                [{ text: "💳 Back to Wallet Menu", callback_data: "menu:wallet" }]
            ]};
            await bot.editMessageText(noWalletText, { chat_id: targetDmChatId, message_id: workingMessageId, parse_mode: 'HTML', reply_markup: noWalletKeyboard });
            return; 
        }

        const solPrice = await getSolUsdPrice();
        const effectiveMinWithdrawalLamports = convertUSDToLamports(MIN_WITHDRAWAL_USD_val, solPrice);
        const minWithdrawalDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(effectiveMinWithdrawalLamports, 'USD')); 
        const feeDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(WITHDRAWAL_FEE_LAMPORTS, 'USD')); 
        const currentBalanceDisplayUSD_HTML = escapeHTML(await formatBalanceForDisplay(currentBalanceLamports, 'USD')); 

        // Corrected: Uses \n and \n\n
        const promptTextHTML = `💸 <b>Initiate Withdrawal</b>\n\n` +
                               `Player: ${playerRefHTML}\n` +
                               `Linked Wallet: <code>${escapeHTML(linkedWallet)}</code>\n` +
                               `Available Balance: <b>${currentBalanceDisplayUSD_HTML}</b>\n\n` +
                               `Minimum Withdrawal: <b>${minWithdrawalDisplayUSD_HTML}</b> (approx. $${escapeHTML(MIN_WITHDRAWAL_USD_val.toFixed(2))})\n` +
                               `Withdrawal Fee: <b>${feeDisplayUSD_HTML}</b> (this will be deducted from the amount you withdraw)\n\n` +
                               `Please reply with the amount you wish to withdraw in USD (e.g., <code>50</code> or <code>75.50</code>) or type <code>max</code> to withdraw your maximum available balance (after fees).`;

        const promptKeyboard = { inline_keyboard: [[{ text: "❌ Cancel & Back to Wallet", callback_data: "menu:wallet" }]] };
        await bot.editMessageText(promptTextHTML, { chat_id: targetDmChatId, message_id: workingMessageId, parse_mode: 'HTML', reply_markup: promptKeyboard, disable_web_page_preview: true });

        const stateToSet = {
            state: 'awaiting_withdrawal_amount',
            chatId: targetDmChatId,
            messageId: workingMessageId,
            data: { 
                linkedWallet: linkedWallet, 
                currentBalanceLamportsStr: currentBalanceLamports.toString(),
                originalPromptMessageId: workingMessageId, 
                originalGroupChatId: (originalCommandChatId !== targetDmChatId && !isFromMenuActionOrRedirect && !msgOrCbMsg.isCallbackRedirect) ? originalCommandChatId : (msgOrCbMsg.isCallbackRedirect ? msgOrCbMsg.originalChatInfo?.id : null),
                originalGroupMessageId: (originalCommandChatId !== targetDmChatId && !isFromMenuActionOrRedirect && !msgOrCbMsg.isCallbackRedirect) ? null : (msgOrCbMsg.isCallbackRedirect ? msgOrCbMsg.originalChatInfo?.messageId : null)
            },
            timestamp: Date.now()
        };
        userStateCache.set(userId, stateToSet);
        console.log(`${logPrefix} State SET for awaiting_withdrawal_amount. MsgID: ${workingMessageId}`);
        
    } catch (error) {
        console.error(`${logPrefix} Error preparing withdrawal: ${error.message}`, error.stack?.substring(0,500));
        // Corrected: Ensure error.message (which might contain problematic HTML from a deeper error) is cleaned for this HTML context
        const errorMessageContent = String(error.message || "An unexpected error occurred.").replace(/<br\s*\/?>/gi, '\n');
        const errorText = `⚙️ Apologies, ${playerRefHTML}, an error occurred while preparing your withdrawal request: <code>${escapeHTML(errorMessageContent)}</code>.\nPlease try again from the wallet menu.`;
        const errorKeyboard = { inline_keyboard: [[{ text: "💳 Back to Wallet Menu", callback_data: "menu:wallet" }]] };
        
        if (workingMessageId) {
            await bot.editMessageText(errorText, { chat_id: targetDmChatId, message_id: workingMessageId, parse_mode: 'HTML', reply_markup: errorKeyboard })
                .catch(async () => { 
                    await safeSendMessage(targetDmChatId, errorText, { parse_mode: 'HTML', reply_markup: errorKeyboard });
                });
        } else { 
            await safeSendMessage(targetDmChatId, errorText, { parse_mode: 'HTML', reply_markup: errorKeyboard });
        }
    }
}

async function handleHistoryCommand(msgOrCbMsg) {
    // When called from handleMenuAction, msgOrCbMsg.from is the userObject
    // userObject has .telegram_id, .username, .first_name
    const userId = String(msgOrCbMsg.from.telegram_id); // Correctly use .telegram_id
    const commandChatId = String(msgOrCbMsg.chat.id); // This will be the DM chat ID
    const originalMessageId = msgOrCbMsg.message_id; // ID of the menu message in DM
    // isFromMenuAction is true if msgOrCbMsg.isCallbackRedirect is undefined or false (meaning it's a direct DM menu action)
    // or if msgOrCbMsg.isCallbackEditing is true (a flag I used in handleBonusCommand for refresh)
    const isFromMenuActionInDm = (msgOrCbMsg.isCallbackRedirect === undefined || !msgOrCbMsg.isCallbackRedirect || msgOrCbMsg.isCallbackEditing === true) && commandChatId === userId;


    const LOG_PREFIX_HISTORY_CMD = `[HistoryCmd_V2 UID:${userId} Chat:${commandChatId}]`;

    // Re-fetch user to ensure we have the latest, or use passed userObject if confident
    // For consistency and to ensure all needed fields for getPlayerDisplayReference are fresh:
    let user = await getOrCreateUser(userId, msgOrCbMsg.from.username, msgOrCbMsg.from.first_name, msgOrCbMsg.from.last_name);
    if (!user) {
        await safeSendMessage(commandChatId, "Error fetching your profile for history\\. Please try `/start`\\.", {parse_mode: 'MarkdownV2'});
        return;
    }
    const playerRef = getPlayerDisplayReference(user); // This is MarkdownV2 safe
    let botUsername = BOT_NAME || "our bot";
    try { const selfInfo = await bot.getMe(); if(selfInfo.username) botUsername = selfInfo.username; } catch(e) { /* ignore */ }

    clearUserState(userId); // Clear any pending input state

    // If originalMessageId exists (meaning we are editing a menu in DM)
    // and it's a DM context, delete it before sending new history.
    // If called by /history command directly in DM, originalMessageId would be the command.
    if (originalMessageId && commandChatId === userId) {
        await bot.deleteMessage(targetDmChatId, originalMessageId).catch(()=>{});
    }
    
    const targetDmChatId = userId; // History is always shown in DM
    const loadingDmMsgText = "Fetching your transaction history... ⏳";
    const tempMsg = await safeSendMessage(targetDmChatId, loadingDmMsgText, { parse_mode: 'MarkdownV2' }); // Use MarkdownV2 for consistency
    const workingMessageId = tempMsg?.message_id;

    if (!workingMessageId) {
        console.error(`${LOG_PREFIX_HISTORY_CMD} Failed to establish message context for history display.`);
        return;
    }

    try {
        const historyEntries = await getBetHistoryDB(userId, 15); // getBetHistoryDB is from Part P2
        let historyText = `📜 *Your Recent Casino Activity, ${playerRef}:*\n\n`;

        if (historyEntries.length === 0) {
            historyText += "You have no recorded transactions yet\\. Time to make some moves\\!";
        } else {
            for (const entry of historyEntries) {
                const date = new Date(entry.created_at).toLocaleString('en-GB', { day: '2-digit', month: 'short', /*year: '2-digit',*/ hour: '2-digit', minute: '2-digit', hour12: false });
                // formatBalanceForDisplay returns USD by default. Let's use SOL for history for brevity or make it configurable.
                // Using SOL here as an example.
                const amountDisplay = formatCurrency(entry.amount_lamports, 'SOL'); // formatCurrency returns MDV2 safe string
                const typeDisplay = escapeMarkdownV2(entry.transaction_type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));
                const sign = BigInt(entry.amount_lamports) >= 0n ? '+' : ''; // For amount_lamports
                
                // Get balance after in USD for user context
                const balanceAfterDisplayUSD = escapeMarkdownV2(await formatBalanceForDisplay(entry.balance_after_lamports, 'USD'));

                const txSig = entry.deposit_tx || entry.withdrawal_tx;

                historyText += `🗓️ \`${escapeMarkdownV2(date)}\` \\| ${typeDisplay}\n` +
                               `   Amount: *${sign}${amountDisplay}*\n`; // amountDisplay is already MDV2 safe
                if (txSig) {
                    historyText += `   Tx: [\`${escapeMarkdownV2(txSig.substring(0, 6))}...${escapeMarkdownV2(txSig.substring(txSig.length - 6))}\`](https://solscan.io/tx/${escapeMarkdownV2(txSig)})\n`;
                }
                if (entry.game_log_type) {
                    historyText += `   Game: ${escapeMarkdownV2(entry.game_log_type)} ${entry.game_log_outcome ? `\\(${escapeMarkdownV2(entry.game_log_outcome)}\\)` : ''}\n`;
                }
                if (entry.notes) {
                    historyText += `   Notes: _${escapeMarkdownV2(entry.notes.substring(0,50))}${entry.notes.length > 50 ? '\\.\\.\\.':''}_\n`;
                }
                historyText += `   Bal After: ~*${balanceAfterDisplayUSD}*\n\n`;
            }
        }
        historyText += `\n_Displaying up to 15 most recent transactions\\._`;
        const keyboard = {inline_keyboard: [[{ text: '💳 Back to Wallet', callback_data: 'menu:wallet' }]]};

        await bot.editMessageText(historyText, {chat_id: targetDmChatId, message_id: workingMessageId, parse_mode: 'MarkdownV2', reply_markup: keyboard, disable_web_page_preview:true});

    } catch (error) {
        console.error(`${LOG_PREFIX_HISTORY_CMD} Error fetching history: ${error.message}`, error.stack?.substring(0,300));
        const errText = "⚙️ Sorry, we couldn't fetch your transaction history right now\\. Please try again later\\.";
        await bot.editMessageText(errText, {chat_id: targetDmChatId, message_id: workingMessageId, parse_mode: 'MarkdownV2', reply_markup: {inline_keyboard: [[{text:"⬅️ Back to Wallet", callback_data:"menu:wallet"}]]}});
    }
}

// REPLACE your entire handleMenuAction function with this corrected version.

async function handleMenuAction(userId, originalChatId, originalMessageId, menuTypeInput, params = [], isFromCallback = true, originalChatType = 'private', originalMsgObject = null) {
    const stringUserId = String(userId);
    const menuType = String(menuTypeInput).trim();
    const logPrefix = `[MenuAction UID:${stringUserId} Type:${menuType} OrigChat:${originalChatId}]`;
    console.log(`${logPrefix} Processing menu action. Cleaned menuType: '${menuType}', Params: [${params.join(',')}]`);

    if (stringUserId === "undefined" || stringUserId === "") {
        console.error(`${logPrefix} CRITICAL: stringUserId is problematic: '${stringUserId}'`);
        return;
    }
    let userObject = await getOrCreateUser(stringUserId);

    if(!userObject) {
        console.error(`${logPrefix} Could not fetch user profile for menu action. User ID: ${stringUserId}`);
        if (originalChatId) {
            await safeSendMessage(originalChatId, "Error fetching your player profile. Please try <code>/start</code> again.", {parse_mode:'HTML'});
        }
        return;
    }

    let botUsername = BOT_NAME || "our bot";
    try { const selfInfo = await bot.getMe(); if(selfInfo.username) botUsername = selfInfo.username; } catch(e) { /* ignore */ }

    let targetChatIdForAction = stringUserId; 
    let messageIdToEdit = (isFromCallback && originalChatType === 'private' && originalMessageId) ? originalMessageId : null;
    let isGroupActionRedirect = false;
    
    const sensitiveMenuTypes = ['deposit', 'quick_deposit', 'withdraw', 'menu:wallet', 'menu:history', 'menu:link_wallet_prompt', 'menu:referral', 'process_withdrawal_confirm', 'unlink_wallet_confirm', 'unlink_wallet_execute', 'menu:quick_deposit_choice'];
    const dmPreferredMenuTypes = [...sensitiveMenuTypes, 'rules_list', 'games_overview', 'levels_info', 'main', 'bonus_dashboard_back'];

    // This block handles redirecting group actions to DM for privacy/security
    if ((originalChatType === 'group' || originalChatType === 'supergroup') && dmPreferredMenuTypes.includes(menuType)) {
        isGroupActionRedirect = true;
        const playerRefForRedirect = escapeHTML(getPlayerDisplayReference(userObject));
        const redirectText = `${playerRefForRedirect}, for privacy, please continue this in our direct message: @${escapeHTML(botUsername)}`;
        const callbackParamsForUrl = params && params.length > 0 ? `_${params.join('_')}` : '';
        
        if (originalMessageId && bot) {
            try {
                await bot.editMessageText(redirectText, {
                    chat_id: originalChatId, message_id: Number(originalMessageId), parse_mode: 'HTML',
                    reply_markup: { inline_keyboard: [[{text: `📬 Open DM with @${escapeHTML(botUsername)}`, url: `https://t.me/${botUsername}?start=menu_${menuType}${callbackParamsForUrl}`}]] }
                });
            } catch (e) {
                if (!e.message?.toLowerCase().includes("message is not modified")) {
                    await safeSendMessage(originalChatId, redirectText, {parse_mode: 'HTML'});
                }
            }
        } else {
            await safeSendMessage(originalChatId, redirectText, {parse_mode: 'HTML'});
        }
        messageIdToEdit = null; 
    } else if (originalChatType === 'private') {
        targetChatIdForAction = originalChatId;
    }
    
    const statefulActionsToPreserveState = ['awaiting_withdrawal_address', 'awaiting_withdrawal_amount', 'awaiting_withdrawal_confirmation'];
    if (userStateCache && !statefulActionsToPreserveState.includes(userStateCache.get(stringUserId)?.state)) {
        if (typeof clearUserState === 'function') clearUserState(stringUserId); else userStateCache.delete(stringUserId);
    }

    // --- FIX IS HERE: This object is now built correctly ---
    // It creates a `from` object that consistently uses `.id` as the property for the user's ID.
    const actionMsgContext = {
        from: {
            id: userObject.telegram_id,
            is_bot: false,
            first_name: userObject.first_name,
            username: userObject.username,
            telegram_id: userObject.telegram_id
        },
        chat: { id: targetChatIdForAction, type: 'private' },
        message_id: messageIdToEdit,
        isCallbackRedirect: isGroupActionRedirect,
        originalChatInfo: isGroupActionRedirect ? { id: originalChatId, type: originalChatType, messageId: originalMessageId } : null,
        message: originalMsgObject
    };
    // --- END OF FIX ---
    
    const alwaysNewMessageInDM = ['deposit', 'quick_deposit', 'withdraw', 'referral', 'history', 'link_wallet_prompt', 'main', 'rules_list', 'games_overview', 'levels_info', 'bonus_dashboard_back', 'unlink_wallet_confirm', 'unlink_wallet_execute', 'quick_deposit_choice'];
    if (targetChatIdForAction === stringUserId && actionMsgContext.message_id && alwaysNewMessageInDM.includes(menuType)) {
        await bot.deleteMessage(targetChatIdForAction, Number(actionMsgContext.message_id)).catch(()=>{});
        actionMsgContext.message_id = null;
    }

    let client = null; 

    try {
        if (menuType === 'levels_info' || menuType === 'unlink_wallet_confirm' || menuType === 'unlink_wallet_execute') {
            client = await pool.connect();
        }

        switch(menuType) {
            case 'wallet':
                if (typeof handleWalletCommand === 'function') await handleWalletCommand(actionMsgContext);
                else console.error(`${logPrefix} Missing handler: handleWalletCommand`);
                break;
            case 'deposit':
                const currency = params[0];
                if (currency === 'ltc') {
                    if (typeof handleLitecoinDepositRequest === 'function') await handleLitecoinDepositRequest(actionMsgContext);
                    else console.error(`${logPrefix} Missing handler: handleLitecoinDepositRequest`);
                } else {
                    if (typeof handleDepositCommand === 'function') await handleDepositCommand(actionMsgContext, [], stringUserId);
                    else console.error(`${logPrefix} Missing handler: handleDepositCommand`);
                }
                break;
            case 'quick_deposit_choice':
                 const choiceText = `Hi ${escapeHTML(getPlayerDisplayReference(userObject))}! Which currency would you like to deposit?`;
                 const choiceKeyboard = {
                     inline_keyboard: [
                         [{ text: "➕ Deposit SOL", callback_data: "menu:deposit:sol" }],
                         [{ text: "➕ Deposit LTC", callback_data: "menu:deposit:ltc" }],
                         [{ text: "❌ Cancel", callback_data: "menu:wallet" }] // Go back to wallet on cancel
                     ]
                 };
                 if (actionMsgContext.message_id) {
                     await bot.editMessageText(choiceText, { chat_id: targetChatIdForAction, message_id: Number(actionMsgContext.message_id), parse_mode: 'HTML', reply_markup: choiceKeyboard });
                 } else {
                     await safeSendMessage(targetChatIdForAction, choiceText, { parse_mode: 'HTML', reply_markup: choiceKeyboard });
                 }
                 break;
            case 'withdraw':
                if (typeof handleWithdrawCommand === 'function') await handleWithdrawCommand(actionMsgContext, [], stringUserId);
                else console.error(`${logPrefix} Missing handler: handleWithdrawCommand`);
                break;
            case 'referral':
                if (typeof handleReferralCommand === 'function') await handleReferralCommand(actionMsgContext);
                else console.error(`${logPrefix} Missing handler: handleReferralCommand`);
                break;
            case 'history':
                if (typeof handleHistoryCommand === 'function') await handleHistoryCommand(actionMsgContext);
                else console.error(`${logPrefix} Missing handler: handleHistoryCommand`);
                break;
            case 'link_wallet_prompt':
                const linkedWallet = await getUserLinkedWallet(stringUserId);
                const promptText = `🔗 <b>Link/Update Your Withdrawal Wallet</b>\n\n` +
                                   (linkedWallet ? `Your current linked wallet is: <code>${escapeHTML(linkedWallet)}</code>\n\nTo update, please reply with your new Solana wallet address.\n\n` : `Please reply to this message with your personal Solana wallet address.\n\n`) +
                                   `Ensure it's correct as transactions are irreversible.`;
                
                const keyboardButtons = [];
                if (linkedWallet) {
                    keyboardButtons.push([{ text: '🗑️ Unlink Current Wallet', callback_data: 'menu:unlink_wallet_confirm' }]);
                }
                keyboardButtons.push([{ text: '❌ Cancel & Back to Wallet', callback_data: 'menu:wallet' }]);
                const kbd = { inline_keyboard: keyboardButtons };
                
                const sentDmPrompt = await safeSendMessage(stringUserId, promptText, { parse_mode: 'HTML', reply_markup: kbd });

                if (sentDmPrompt?.message_id) {
                    userStateCache.set(stringUserId, {
                        state: 'awaiting_withdrawal_address', chatId: stringUserId, messageId: sentDmPrompt.message_id,
                        data: { originalPromptMessageId: sentDmPrompt.message_id },
                        timestamp: Date.now()
                    });
                }
                break;
            // ... (All your other cases like unlink_wallet, main, rules_list, etc. remain here) ...
            
            default:
                console.warn(`${logPrefix} Unrecognized menu type in handleMenuAction: '${menuType}'`);
                const unrecognizedMenuMsg = `❓ Unrecognized menu option: <code>${escapeHTML(menuType)}</code>. Please try again or use <code>/help</code>.`;
                const unrecognizedMenuKbd = createBackToMenuKeyboard('menu:main', '⬅️ Back to Main Menu');
                if (actionMsgContext.message_id && bot) { 
                    await bot.editMessageText(unrecognizedMenuMsg, { chat_id: targetChatIdForAction, message_id: Number(actionMsgContext.message_id), parse_mode: 'HTML', reply_markup: unrecognizedMenuKbd}).catch(async (e) => {
                        if (!e.message?.toLowerCase().includes("message is not modified")) await safeSendMessage(targetChatIdForAction, unrecognizedMenuMsg, { parse_mode: 'HTML', reply_markup: unrecognizedMenuKbd });
                    });
                } else {
                    await safeSendMessage(targetChatIdForAction, unrecognizedMenuMsg, { parse_mode: 'HTML', reply_markup: unrecognizedMenuKbd });
                }
        }
    } catch (error) { 
        console.error(`${logPrefix} Outer error in handleMenuAction for menuType ${menuType}: ${error.message}`, error.stack);
        if(actionMsgContext.chat?.id) { 
            await safeSendMessage(actionMsgContext.chat.id, `⚙️ An unexpected error occurred while processing your menu selection. Please try again.`, { parse_mode: 'HTML', reply_markup: createBackToMenuKeyboard('menu:main', '⬅️ Back to Main Menu')});
        }
    } finally {
        if (client) { 
            client.release();
        }
    }
}


async function handleWithdrawalConfirmation(userId, dmChatId, confirmationMessageIdInDm, recipientAddress, amountLamportsStr, feeLamportsStr, originalGroupChatIdForNotif, originalGroupMessageIdForNotif) {
    const stringUserId = String(userId);
    const logPrefix = `[WithdrawConfirm_HTML_V3_Newline UID:${stringUserId}]`;

    // --- ADDED DIAGNOSTIC LOGS ---
    console.log(`${logPrefix} ENTERED handleWithdrawalConfirmation.`);
    console.log(`${logPrefix} Received amountLamportsStr: '${amountLamportsStr}' (type: ${typeof amountLamportsStr})`);
    console.log(`${logPrefix} Received feeLamportsStr: '${feeLamportsStr}' (type: ${typeof feeLamportsStr})`);
    // --- END OF ADDED DIAGNOSTIC LOGS ---
    
    const amountLamports = BigInt(amountLamportsStr); 
    const feeLamports = BigInt(feeLamportsStr);       
    const totalDeduction = amountLamports + feeLamports; 

    const userObjForNotif = await getOrCreateUser(stringUserId); 
    const playerRefHTML = escapeHTML(getPlayerDisplayReference(userObjForNotif || { id: stringUserId, first_name: "Player" }));
    let client = null;

    try {
        client = await pool.connect();
        await client.query('BEGIN');

        const userDetailsCheck = await client.query('SELECT balance FROM users WHERE telegram_id = $1 FOR UPDATE', [stringUserId]);
        if (userDetailsCheck.rowCount === 0) {
            throw new Error("User profile not found during withdrawal confirmation.");
        }
        const currentBalanceOnConfirm = BigInt(userDetailsCheck.rows[0].balance);
        const solPrice = await getSolUsdPrice(); 
        if (currentBalanceOnConfirm < totalDeduction) {
            throw new Error(`Insufficient balance at time of confirmation.\nCurrent: <b>${escapeHTML(await formatBalanceForDisplay(currentBalanceOnConfirm, 'USD', solPrice))}</b>, Needed: <b>${escapeHTML(await formatBalanceForDisplay(totalDeduction, 'USD', solPrice))}</b>.\nWithdrawal cancelled.`);
        }

        const wdReq = await createWithdrawalRequestDB(client, stringUserId, amountLamports, feeLamports, recipientAddress);
        if (!wdReq.success || !wdReq.withdrawalId) {
            throw new Error(wdReq.error || "Failed to create database withdrawal request record.");
        }

        // This is line approx 12848 from your previous error stack for this function if it calls updateUserBalanceAndLedger
        const balUpdate = await updateUserBalanceAndLedger(
            client, stringUserId, BigInt(-totalDeduction), 
            'withdrawal_request_confirmed',
            { withdrawal_id: wdReq.withdrawalId },
            `Withdrawal confirmed to ${recipientAddress.slice(0,6)}...${recipientAddress.slice(-4)}`
        );
        if (!balUpdate.success) {
            throw new Error(balUpdate.error || "Failed to deduct balance for withdrawal. Withdrawal not queued.");
        }

        await client.query('COMMIT');

        if (typeof addPayoutJob === 'function') {
            await addPayoutJob({ type: 'payout_withdrawal', withdrawalId: wdReq.withdrawalId, userId: stringUserId });
            const amountToReceiveDisplayUSD = escapeHTML(await formatBalanceForDisplay(amountLamports, 'USD')); 
            const successMsgDmHTML = `✅ <b>Withdrawal Queued!</b>\nYour request to withdraw <b>${amountToReceiveDisplayUSD}</b> to <code>${escapeHTML(recipientAddress)}</code> is now in the payout queue.\nYou'll be notified by DM once it's processed.`;
            
            const currentState = userStateCache.get(stringUserId); // Re-fetch for originalGroup IDs
            if (confirmationMessageIdInDm && bot) {
                await bot.editMessageText(successMsgDmHTML, {chat_id: dmChatId, message_id: Number(confirmationMessageIdInDm), parse_mode:'HTML', reply_markup:{}});
            } else {
                await safeSendMessage(dmChatId, successMsgDmHTML, {parse_mode:'HTML'});
            }
            
            if (currentState?.data?.originalGroupChatId && currentState?.data?.originalGroupMessageId && bot) {
                 await bot.editMessageText(`${playerRefHTML}'s withdrawal request for <b>${amountToReceiveDisplayUSD}</b> has been queued successfully. Details in DM.`, {chat_id: currentState.data.originalGroupChatId, message_id: Number(currentState.data.originalGroupMessageId), parse_mode:'HTML', reply_markup:{}}).catch(()=>{});
            }
        } else {
            console.error(`${logPrefix} 🚨 CRITICAL: addPayoutJob function is not defined! Cannot queue withdrawal ${wdReq.withdrawalId}.`);
            await notifyAdmin(`🚨 CRITICAL: Withdrawal ${wdReq.withdrawalId} for user ${stringUserId} had balance deducted BUT FAILED TO QUEUE for payout (addPayoutJob missing). MANUAL INTERVENTION REQUIRED TO REFUND OR PROCESS.`, {parse_mode:'HTML'});
            throw new Error("Payout processing system is unavailable.\nYour funds were deducted but the payout could not be queued.\nPlease contact support immediately.");
        }
    } catch (e) {
        if (client) await client.query('ROLLBACK').catch(rbErr => console.error(`${logPrefix} Rollback error: ${rbErr.message}`));
        console.error(`❌ ${logPrefix} Error processing withdrawal confirmation: ${e.message}`, e.stack?.substring(0,500)); // This is where your error was logged
        const errorMsgDmHTML = `⚠️ <b>Withdrawal Failed:</b>\n${e.message}\n\nPlease try again or contact support if the issue persists.`;
        const errorKeyboard = { inline_keyboard: [[{ text: '💳 Back to Wallet', callback_data: 'menu:wallet' }]] };
        if(confirmationMessageIdInDm && bot) {
            await bot.editMessageText(errorMsgDmHTML, {chat_id: dmChatId, message_id: Number(confirmationMessageIdInDm), parse_mode:'HTML', reply_markup: errorKeyboard}).catch(async ()=>{
                 await safeSendMessage(dmChatId, errorMsgDmHTML, {parse_mode:'HTML', reply_markup: errorKeyboard});
            });
        } else {
            await safeSendMessage(dmChatId, errorMsgDmHTML, {parse_mode:'HTML', reply_markup: errorKeyboard});
        }
        
        const currentState = userStateCache.get(stringUserId); 
        if (currentState?.data?.originalGroupChatId && currentState?.data?.originalGroupMessageId && bot) {
            await bot.editMessageText(`${playerRefHTML}, there was an error processing your withdrawal confirmation. Please check your DMs.`, {chat_id: currentState.data.originalGroupChatId, message_id: Number(currentState.data.originalGroupMessageId), parse_mode:'HTML', reply_markup:{}}).catch(()=>{});
        }
    } finally {
        if (client) client.release();
        clearUserState(stringUserId); 
    }
}


// --- Webhook Setup Function ---
function setupPaymentWebhook(expressAppInstance) {
    const logPrefix = '[SetupWebhook]';
    if (!expressAppInstance) {
        console.error(`${logPrefix} 🚨 Express app instance not provided. Cannot set up webhook routes.`);
        return;
    }

    const paymentWebhookPath = process.env.PAYMENT_WEBHOOK_PATH || '/webhook/solana-payments';
    const PAYMENT_WEBHOOK_SECRET = process.env.PAYMENT_WEBHOOK_SECRET;

    console.log(`${logPrefix} 📡 Configuring webhook endpoint at ${paymentWebhookPath}`);

    expressAppInstance.post(paymentWebhookPath, async (req, res) => {
        const webhookLogPrefix = `[PaymentWebhook ${paymentWebhookPath}]`;
        const signatureFromHeader = req.headers['x-signature'] || req.headers['X-Signature'] || req.headers['helius-signature'] || req.headers['shyft-signature']; 

        if (PAYMENT_WEBHOOK_SECRET) {
            if(!signatureFromHeader) console.warn(`${webhookLogPrefix} Webhook secret is SET, but NO signature header found. Processing insecurely (NOT FOR PRODUCTION).`);
            else console.log(`${webhookLogPrefix} Received signature. Implement provider-specific validation for PAYMENT_WEBHOOK_SECRET.`);
        } else {
            console.warn(`${webhookLogPrefix} PAYMENT_WEBHOOK_SECRET NOT SET. Processing insecurely (NOT FOR PRODUCTION).`);
        }

        try {
            const payload = req.body; 
            let relevantTransactions = []; 

            if (Array.isArray(payload)) { 
                payload.forEach(event => {
                    if (event.type === "TRANSFER" && event.transaction?.signature && Array.isArray(event.nativeTransfers)) { // Example for Helius native SOL
                        event.nativeTransfers.forEach(transfer => {
                            if (transfer.toUserAccount && 
                                (transfer.mint === "So11111111111111111111111111111111111111112" || !transfer.mint) && 
                                transfer.amount && transfer.amount > 0) { 
                                relevantTransactions.push({
                                    signature: event.transaction.signature,
                                    depositToAddress: transfer.toUserAccount,
                                });
                            }
                        });
                    }
                    // Add other 'else if' blocks here for different webhook providers or event types
                });
            } else {
                // Handle non-array payloads if your provider sends them differently
                 console.warn(`${webhookLogPrefix} Received non-array payload: ${typeof payload}. Adapt parsing logic.`);
            }

            if (relevantTransactions.length === 0) {
                return res.status(200).send('Webhook received; no actionable SOL transfer data identified.');
            }

            console.log(`${webhookLogPrefix} Identified ${relevantTransactions.length} potential deposit(s) from webhook.`);

            for (const txInfo of relevantTransactions) {
                const { signature, depositToAddress } = txInfo;
                if (!signature || !depositToAddress) {
                    console.warn(`${webhookLogPrefix} Webhook tx info missing signature or depositToAddress. Skipping.`);
                    continue; 
                }

                if (!processedDepositTxSignatures.has(signature)) { 
                    const addrInfo = await findDepositAddressInfoDB(depositToAddress); 
                    if (addrInfo && addrInfo.isActive) { 
                        console.log(`${webhookLogPrefix} ✅ Valid webhook for active address ${depositToAddress}. Queuing TX: ${signature} for User: ${addrInfo.userId}`);
                        depositProcessorQueue.add(() => processDepositTransaction(signature, depositToAddress, addrInfo.walletId, addrInfo.userId));
                        processedDepositTxSignatures.add(signature); 
                        if(processedDepositTxSignatures.size > (parseInt(process.env.MAX_PROCESSED_TX_CACHE, 10) || 10000) * 1.2) {
                           const oldSigs = Array.from(processedDepositTxSignatures).slice(0, processedDepositTxSignatures.size - (parseInt(process.env.MAX_PROCESSED_TX_CACHE, 10) || 10000));
                           oldSigs.forEach(s => processedDepositTxSignatures.delete(s));
                        }
                    } else {
                        console.warn(`${webhookLogPrefix} ⚠️ Webhook for inactive/expired/unknown address ${depositToAddress}. TX ${signature}. AddrInfo found: ${!!addrInfo}`);
                        if(addrInfo) processedDepositTxSignatures.add(signature);
                    }
                }
            }
            res.status(200).send('Webhook data queued for processing where applicable');
        } catch (error) {
            console.error(`❌ ${webhookLogPrefix} Error processing webhook payload: ${error.message}`, error.stack?.substring(0,500));
            res.status(500).send('Internal Server Error during webhook processing');
        }
    });

    console.log(`${logPrefix} ✅ Webhook endpoint ${paymentWebhookPath} configured on Express app.`);
}

// --- End of Part P3 ---
// --- Start of Part P4 ---
// index.js - Part P4: Payment System Background Tasks & Webhook Handling
//---------------------------------------------------------------------------
// Assumed global constants, Solana connection, DB pool, processing queues,
// Keypairs, Utilities, DB Ops, Solana Utils, Cache, and global flags are available.

// --- Helper Function to Analyze Transaction for Deposits ---
/**
 * Analyzes a fetched Solana transaction to find the amount transferred to a specific deposit address.
 * @param {import('@solana/web3.js').VersionedTransactionResponse | import('@solana/web3.js').TransactionResponse | null} txResponse
 * @param {string} depositAddress
 * @returns {{transferAmount: bigint, payerAddress: string | null}}
 */
function analyzeTransactionAmounts(txResponse, depositAddress) {
    let transferAmount = 0n;
    let payerAddress = null;

    if (!txResponse || !txResponse.meta || !txResponse.transaction) {
        return { transferAmount, payerAddress };
    }

    if (txResponse.transaction.message && txResponse.transaction.message.accountKeys && txResponse.transaction.message.accountKeys.length > 0) {
        payerAddress = txResponse.transaction.message.accountKeys[0].toBase58();
    }

    const accountIndex = txResponse.transaction.message.accountKeys.findIndex(
        key => key.toBase58() === depositAddress
    );

    if (accountIndex !== -1 && txResponse.meta.preBalances && txResponse.meta.postBalances &&
        txResponse.meta.preBalances.length > accountIndex && txResponse.meta.postBalances.length > accountIndex) {
        const preBalance = BigInt(txResponse.meta.preBalances[accountIndex]);
        const postBalance = BigInt(txResponse.meta.postBalances[accountIndex]);
        if (postBalance > preBalance) {
            transferAmount = postBalance - preBalance;
        }
    }
    return { transferAmount, payerAddress };
}

// --- Global State for Background Task Control ---
let depositMonitorIntervalId = null;
let sweepIntervalId = null;

// Add static properties to functions to track running state, ensure these are defined before use.
// These functions are defined below in this Part.
// It's better to define these where the functions themselves are defined or manage state differently.
// For now, assuming they might be forward-declared or this is a pattern in use.
// Consider managing `isRunning` state more robustly if issues arise.
// if (typeof monitorDepositsPolling === 'function' && typeof monitorDepositsPolling.isRunning === 'undefined') {
//     monitorDepositsPolling.isRunning = false;
// }
// if (typeof sweepDepositAddresses === 'function' && typeof sweepDepositAddresses.isRunning === 'undefined') {
//     sweepDepositAddresses.isRunning = false;
// }


// --- Deposit Monitoring Logic ---

function startDepositMonitoring() {
    let intervalMs = parseInt(process.env.DEPOSIT_MONITOR_INTERVAL_MS, 10);
    if (isNaN(intervalMs) || intervalMs < 5000) { // Minimum 5 seconds
        intervalMs = 15000; // Default to 15 seconds
        console.warn(`[DepositMonitor] Invalid DEPOSIT_MONITOR_INTERVAL_MS, using default ${intervalMs}ms.`);
    }
    
    if (depositMonitorIntervalId) {
        clearInterval(depositMonitorIntervalId);
    } else {
        console.log(`⚙️ [DepositMonitor] Starting Deposit Monitor (Interval: ${intervalMs / 1000}s)...`);
    }
    
    // Ensure monitorDepositsPolling has the isRunning property initialized
    if (typeof monitorDepositsPolling.isRunning === 'undefined') {
        monitorDepositsPolling.isRunning = false;
    }

    const initialDelay = (parseInt(process.env.INIT_DELAY_MS, 10) || 7000) + 2000; // Stagger start
    setTimeout(() => {
        if (isShuttingDown) return;
        monitorDepositsPolling().catch(err => console.error("❌ [Initial Deposit Monitor Run] Error:", err.message, err.stack?.substring(0,500)));
        
        depositMonitorIntervalId = setInterval(() => {
            monitorDepositsPolling().catch(err => console.error("❌ [Recurring Deposit Monitor Run] Error:", err.message, err.stack?.substring(0,500)));
        }, intervalMs);

        if (depositMonitorIntervalId && typeof depositMonitorIntervalId.unref === 'function') {
            depositMonitorIntervalId.unref(); // Allow Node.js to exit if this is the only timer
        }
    }, initialDelay);
}

function stopDepositMonitoring() {
    if (depositMonitorIntervalId) {
        clearInterval(depositMonitorIntervalId);
        depositMonitorIntervalId = null;
        if (typeof monitorDepositsPolling === 'function') monitorDepositsPolling.isRunning = false; // Reset flag
        console.log("🛑 [DepositMonitor] Deposit monitoring stopped.");
    }
}

async function monitorDepositsPolling() {
    const logPrefix = '[DepositMonitor Polling]';
    if (isShuttingDown) { return; }
    if (monitorDepositsPolling.isRunning) {
        return;
    }
    monitorDepositsPolling.isRunning = true;

    try {
        const batchSize = parseInt(process.env.DEPOSIT_MONITOR_ADDRESS_BATCH_SIZE, 10) || 75;
        const sigFetchLimit = parseInt(process.env.DEPOSIT_MONITOR_SIGNATURE_FETCH_LIMIT, 10) || 15;

        const pendingAddressesRes = await queryDatabase(
            `SELECT wallet_id, public_key, user_telegram_id, derivation_path, expires_at
             FROM user_deposit_wallets
             WHERE is_active = TRUE AND expires_at > NOW()
             ORDER BY created_at ASC
             LIMIT $1`,
            [batchSize]
        );

        if (pendingAddressesRes.rowCount > 0) {
            console.log(`${logPrefix} Found ${pendingAddressesRes.rowCount} active address(es) to check.`);
        }

        for (const row of pendingAddressesRes.rows) {
            if (isShuttingDown) { console.log(`${logPrefix} Shutdown during address check.`); break; }
            
            const depositAddress = row.public_key;
            const userDepositWalletId = row.wallet_id;
            const userId = String(row.user_telegram_id);
            const addrLogPrefix = `[Monitor Addr:${depositAddress.slice(0, 6)} WID:${userDepositWalletId}]`;

            try {
                const pubKey = new PublicKey(depositAddress);
                const signatures = await solanaConnection.getSignaturesForAddress(
                    pubKey, { limit: sigFetchLimit }, DEPOSIT_CONFIRMATION_LEVEL
                );

                if (signatures && signatures.length > 0) {
                    for (const sigInfo of signatures.reverse()) { // Process oldest first
                        if (sigInfo?.signature && !processedDepositTxSignatures.has(sigInfo.signature)) {
                            const isConfirmedByLevel = sigInfo.confirmationStatus === DEPOSIT_CONFIRMATION_LEVEL || sigInfo.confirmationStatus === 'finalized';
                            if (!sigInfo.err && isConfirmedByLevel) {
                                console.log(`${addrLogPrefix} ✅ New confirmed TX: ${sigInfo.signature}. Queuing for processing.`);
                                depositProcessorQueue.add(() => processDepositTransaction(sigInfo.signature, depositAddress, userDepositWalletId, userId))
                                    .catch(queueError => console.error(`❌ ${addrLogPrefix} Error adding TX ${sigInfo.signature} to deposit queue: ${queueError.message}`));
                                processedDepositTxSignatures.add(sigInfo.signature);
                                // Clean up old signatures from the Set to prevent memory leak
                                if(processedDepositTxSignatures.size > (parseInt(process.env.MAX_PROCESSED_TX_CACHE, 10) || 10000) * 1.2) {
                                   const oldSigs = Array.from(processedDepositTxSignatures).slice(0, processedDepositTxSignatures.size - (parseInt(process.env.MAX_PROCESSED_TX_CACHE, 10) || 10000));
                                   oldSigs.forEach(s => processedDepositTxSignatures.delete(s));
                                }
                            } else if (sigInfo.err) {
                                console.warn(`${addrLogPrefix} ⚠️ TX ${sigInfo.signature} has error: ${JSON.stringify(sigInfo.err)}. Marking processed.`);
                                processedDepositTxSignatures.add(sigInfo.signature);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error(`❌ ${addrLogPrefix} Error checking signatures for ${depositAddress}: ${error.message}`);
                if (error?.status === 429 || String(error?.message).toLowerCase().includes('rate limit')) {
                    console.warn(`${addrLogPrefix} Rate limit hit during signature check. Pausing briefly.`);
                    await sleep(5000 + Math.random() * 3000); 
                }
            }
            await sleep(parseInt(process.env.DEPOSIT_MONITOR_ADDRESS_DELAY_MS, 10) || 300); // Delay between checking each address
        }
    } catch (error) {
        console.error(`❌ ${logPrefix} Critical error in main polling loop: ${error.message}`, error.stack?.substring(0,500));
        if (typeof notifyAdmin === 'function') await notifyAdmin(`🚨 *ERROR in Deposit Monitor Loop* 🚨\n\n\`${escapeMarkdownV2(String(error.message || error))}\`\nCheck logs\\.`, {parse_mode: 'MarkdownV2'});
    } finally {
        monitorDepositsPolling.isRunning = false;
    }
}

async function processDepositTransaction(txSignature, depositAddress, userDepositWalletId, userId) {
    const stringUserId = String(userId);
    const logPrefix = `[ProcessDeposit TX:${txSignature.slice(0, 10)} Addr:${depositAddress.slice(0,6)} WID:${userDepositWalletId} UID:${stringUserId}]`;
    console.log(`${logPrefix} Processing deposit transaction...`);
    let client = null;

    try {
        const txResponse = await solanaConnection.getTransaction(txSignature, {
            maxSupportedTransactionVersion: 0, commitment: DEPOSIT_CONFIRMATION_LEVEL
        });

        if (!txResponse || txResponse.meta?.err) {
            console.warn(`ℹ️ ${logPrefix} TX ${txSignature} failed on-chain or details not found. Error: ${JSON.stringify(txResponse?.meta?.err)}. Marking processed locally.`);
            processedDepositTxSignatures.add(txSignature);
            return;
        }

        const { transferAmount, payerAddress } = analyzeTransactionAmounts(txResponse, depositAddress);

        if (transferAmount <= 0n) {
            console.log(`${logPrefix} No positive transfer amount found for ${depositAddress} in TX ${txSignature}. Amount: ${transferAmount}. Marking processed.`);
            processedDepositTxSignatures.add(txSignature);
            return;
        }
        // Prepare display amounts (these will be further escaped before inserting into HTML)
        const depositAmountSOLDisplay = await formatBalanceForDisplay(transferAmount, 'SOL');
        console.log(`✅ ${logPrefix} Valid deposit: ${depositAmountSOLDisplay} from ${payerAddress || 'unknown source'}.`);

        client = await pool.connect();
        await client.query('BEGIN');

        const depositRecordResult = await recordConfirmedDepositDB(client, stringUserId, userDepositWalletId, depositAddress, txSignature, transferAmount, payerAddress, txResponse.blockTime);
        if (depositRecordResult.alreadyProcessed) {
            await client.query('ROLLBACK'); 
            processedDepositTxSignatures.add(txSignature);
            return;
        }
        if (!depositRecordResult.success || !depositRecordResult.depositId) {
            throw new Error(`Failed to record deposit in DB for ${txSignature}: ${depositRecordResult.error || "Unknown DB error."}`);
        }
        const depositId = depositRecordResult.depositId;

        const markedInactive = await markDepositAddressInactiveDB(client, userDepositWalletId, false, null); 
        if (!markedInactive) {
            console.warn(`${logPrefix} ⚠️ Could not mark deposit address WID ${userDepositWalletId} as inactive after deposit.`);
        }

        const ledgerNote = `Deposit from ${payerAddress ? payerAddress.slice(0,6)+'...'+payerAddress.slice(-4) : 'Unknown'} to ${depositAddress.slice(0,6)}... TX:${txSignature.slice(0,6)}...`;
        const balanceUpdateResult = await updateUserBalanceAndLedger(client, stringUserId, transferAmount, 'deposit', { deposit_id: depositId }, ledgerNote); 
        if (!balanceUpdateResult.success || typeof balanceUpdateResult.newBalanceLamports === 'undefined') {
            throw new Error(`Failed to update user ${stringUserId} balance/ledger for deposit: ${balanceUpdateResult.error || "Unknown DB error."}`);
        }
        
        await client.query('COMMIT');
        processedDepositTxSignatures.add(txSignature);

        // Prepare variables for the HTML message
        const newBalanceUSDDisplay = await formatBalanceForDisplay(balanceUpdateResult.newBalanceLamports, 'USD');
        const userForNotif = await getOrCreateUser(stringUserId); 
        // getPlayerDisplayReference output should be HTML-escaped for safety in HTML context
        const playerRefHTML = escapeHTML(getPlayerDisplayReference(userForNotif || { id: stringUserId, first_name: "Player" }));
        
        // Construct the HTML message
        const confirmationMessageHTML = 
            `🎉 <b>Deposit Confirmed, ${playerRefHTML}!</b> 🎉\n\n` +
            `Your deposit of <b>${escapeHTML(depositAmountSOLDisplay)}</b> has been successfully credited to your casino account.\n\n` +
            `💰 Your New Balance: Approx. <b>${escapeHTML(newBalanceUSDDisplay)}</b>\n` +
            `🧾 Transaction ID: <code>${escapeHTML(txSignature)}</code>\n\n` +
            `Time to hit the tables! Good luck! 🎰`;

        await safeSendMessage(stringUserId, 
            confirmationMessageHTML,
            { parse_mode: 'HTML' } // Changed to HTML
        );
        
    } catch (error) {
        console.error(`❌ ${logPrefix} CRITICAL ERROR processing deposit TX ${txSignature}: ${error.message}`, error.stack?.substring(0,500));
        if (client) { await client.query('ROLLBACK').catch(rbErr => console.error(`❌ ${logPrefix} Rollback failed:`, rbErr)); }
        processedDepositTxSignatures.add(txSignature); 
        if (typeof notifyAdmin === 'function') { 
            await notifyAdmin(`🚨 *CRITICAL Error Processing Deposit* 🚨\nTX: <code>${escapeHTML(txSignature)}</code>\nAddr: <code>${escapeHTML(depositAddress)}</code>\nUser: <code>${escapeHTML(stringUserId)}</code>\n*Error:*\n<pre>${escapeHTML(String(error.message || error))}</pre>\nManual investigation required.`, {parse_mode:'HTML'});
        }
    } finally {
        if (client) client.release();
    }
}


// --- Deposit Address Sweeping Logic (Updated with Rent Exemption) ---
function startSweepingProcess() {
    let intervalMs = parseInt(process.env.SWEEP_INTERVAL_MS, 10);
    if (isNaN(intervalMs) || intervalMs <= 0) {
        return; // Sweeping disabled
    }
    if (intervalMs < 60000) { 
        intervalMs = 60000;
        console.warn(`🧹 [Sweeper] SWEEP_INTERVAL_MS too low, enforcing minimum ${intervalMs / 1000}s.`);
    }
    
    if (sweepIntervalId) {
        clearInterval(sweepIntervalId);
    } else {
        console.log(`⚙️ [Sweeper] Starting Fund Sweeper (Interval: ${intervalMs / 1000 / 60} minutes)...`);
    }

    if (typeof sweepDepositAddresses.isRunning === 'undefined') {
        sweepDepositAddresses.isRunning = false;
    }

    const initialDelay = (parseInt(process.env.INIT_DELAY_MS, 10) || 7000) + 15000; // Stagger after other initializations
    setTimeout(() => {
        if (isShuttingDown) return;
        sweepDepositAddresses().catch(err => console.error("❌ [Initial Sweep Run] Error:", err.message, err.stack?.substring(0,500)));
        
        sweepIntervalId = setInterval(() => {
            sweepDepositAddresses().catch(err => console.error("❌ [Recurring Sweep Run] Error:", err.message, err.stack?.substring(0,500)));
        }, intervalMs);

        if (sweepIntervalId && typeof sweepIntervalId.unref === 'function') {
            sweepIntervalId.unref();
        }
    }, initialDelay);
}

function stopSweepingProcess() {
    if (sweepIntervalId) {
        clearInterval(sweepIntervalId);
        sweepIntervalId = null;
        if (typeof sweepDepositAddresses === 'function') sweepDepositAddresses.isRunning = false; 
        console.log("🛑 [Sweeper] Fund sweeping stopped.");
    }
}

// This is the updated sweepDepositAddresses function
async function sweepDepositAddresses() {
    const logPrefix = '[SweepAddresses_V2]'; // Added V2 for new logging
    if (isShuttingDown) { 
        console.log(`${logPrefix} Shutdown detected. Aborting sweep cycle.`);
        return; 
    }
    if (sweepDepositAddresses.isRunning) {
        console.log(`${logPrefix} Sweep cycle already running. Skipping.`);
        return;
    }
    sweepDepositAddresses.isRunning = true;
    console.log(`🧹 ${logPrefix} Starting new sweep cycle...`);

    let addressesProcessedThisCycle = 0;
    let totalSweptThisCycle = 0n;
    const sweepBatchSize = parseInt(process.env.SWEEP_BATCH_SIZE, 10) || 15;
    const sweepAddressDelayMs = parseInt(process.env.SWEEP_ADDRESS_DELAY_MS, 10) || 1500;
    
    if (!MAIN_BOT_KEYPAIR || !DEPOSIT_MASTER_SEED_PHRASE) {
        console.error(`❌ ${logPrefix} CRITICAL: MAIN_BOT_KEYPAIR or DEPOSIT_MASTER_SEED_PHRASE not available. Cannot sweep.`);
        sweepDepositAddresses.isRunning = false;
        if (typeof notifyAdmin === "function") await notifyAdmin(`🚨 ${logPrefix} Critical configuration missing (Main Bot Keypair or Master Seed). Sweeping aborted.`, {parse_mode: 'MarkdownV2'});
        return;
    }
    const sweepTargetAddress = MAIN_BOT_KEYPAIR.publicKey.toBase58();
    console.log(`${logPrefix} Target sweep address: ${sweepTargetAddress}`);

    let rentLamports;
    try {
        rentLamports = BigInt(await solanaConnection.getMinimumBalanceForRentExemption(0));
        console.log(`${logPrefix} Current rent exemption for 0-data account: ${rentLamports} lamports.`);
    } catch (rentError) {
        console.error(`❌ ${logPrefix} Failed to get minimum balance for rent exemption: ${rentError.message}. Using fallback.`);
        rentLamports = BigInt(890880); // Approx 0.00089 SOL
        if (typeof notifyAdmin === "function") await notifyAdmin(`⚠️ ${logPrefix} Failed to fetch rent exemption, using fallback: ${rentLamports}. Error: ${escapeMarkdownV2(rentError.message)}`, {parse_mode: 'MarkdownV2'});
    }

    const feeForSweepTxItself = BigInt(process.env.SWEEP_FEE_BUFFER_LAMPORTS || '20000');
    const minimumLamportsToLeave = rentLamports + feeForSweepTxItself;
    console.log(`${logPrefix} Minimum lamports to leave in source account (rent + fee buffer): ${minimumLamportsToLeave} (${formatCurrency(minimumLamportsToLeave, 'SOL')})`);

    let addressesToConsiderRes = null;

    try {
        const addressesQuery = `SELECT wallet_id, public_key, derivation_path, user_telegram_id
            FROM user_deposit_wallets 
            WHERE swept_at IS NULL 
            AND (is_active = FALSE OR expires_at < NOW() - INTERVAL '5 minutes')
            ORDER BY created_at ASC 
            LIMIT $1`;
        addressesToConsiderRes = await queryDatabase(addressesQuery, [sweepBatchSize]);

        if (!addressesToConsiderRes || !addressesToConsiderRes.rows) {
            console.log(`${logPrefix} No addresses found meeting initial sweep criteria in this batch or query failed.`);
            sweepDepositAddresses.isRunning = false;
            return;
        }

        if (addressesToConsiderRes.rowCount > 0) {
            console.log(`${logPrefix} Found ${addressesToConsiderRes.rowCount} potential addresses in this batch to check for sweeping.`);
        } else {
            console.log(`${logPrefix} No addresses currently meet the criteria for sweeping.`);
            sweepDepositAddresses.isRunning = false;
            return;
        }

        for (const addrData of addressesToConsiderRes.rows) {
            if (isShuttingDown) { console.log(`${logPrefix} Shutdown detected during address processing for WID ${addrData.wallet_id}.`); break; }
            
            const addrLogPrefix = `[Sweep Addr:${addrData.public_key.slice(0, 6)} WID:${addrData.wallet_id}]`;
            let depositKeypair;
            let clientForThisAddress = null;

            try {
                clientForThisAddress = await pool.connect();
                await clientForThisAddress.query('BEGIN');
                console.log(`${addrLogPrefix} Processing address. Path: ${addrData.derivation_path}`);

                try {
                    depositKeypair = deriveSolanaKeypair(DEPOSIT_MASTER_SEED_PHRASE, addrData.derivation_path);
                    if (!depositKeypair || depositKeypair.publicKey.toBase58() !== addrData.public_key) {
                        throw new Error(`Derived public key mismatch! DB: ${addrData.public_key}, Derived: ${depositKeypair?.publicKey?.toBase58()}`);
                    }
                } catch (derivError) {
                    console.error(`❌ ${addrLogPrefix} Critical error deriving key: ${derivError.message}. Marking as sweep_error.`);
                    await markDepositAddressInactiveDB(clientForThisAddress, addrData.wallet_id, true, null); 
                    await clientForThisAddress.query("UPDATE user_deposit_wallets SET notes = COALESCE(notes, '') || ' Sweep Error: Key derivation exception.' WHERE wallet_id = $1", [addrData.wallet_id]);
                    await clientForThisAddress.query('COMMIT');
                    continue; // Move to next address
                }
                console.log(`${addrLogPrefix} Keypair derived successfully.`);

                const balanceLamports = await getSolBalance(addrData.public_key);
                if (balanceLamports === null) {
                    console.warn(`${addrLogPrefix} Could not fetch balance. Skipping.`);
                    await clientForThisAddress.query('ROLLBACK'); 
                    continue;
                }
                console.log(`${addrLogPrefix} On-chain balance: ${balanceLamports} (${formatCurrency(balanceLamports, 'SOL')})`);

                if (balanceLamports <= minimumLamportsToLeave) {
                    console.log(`${addrLogPrefix} Balance ${balanceLamports} is <= minimum to leave ${minimumLamportsToLeave}. Marking 'swept_low_balance'.`);
                    await markDepositAddressInactiveDB(clientForThisAddress, addrData.wallet_id, true, balanceLamports);
                    await clientForThisAddress.query('COMMIT');
                    continue;
                }

                const amountToSweep = balanceLamports - minimumLamportsToLeave;
                console.log(`${addrLogPrefix} Calculated amountToSweep: ${amountToSweep} (${formatCurrency(amountToSweep, 'SOL')})`);
                
                if (amountToSweep <= 0n) {
                    console.warn(`${addrLogPrefix} Calculated amountToSweep is not positive (${amountToSweep}). Balance: ${balanceLamports}, MinToLeave: ${minimumLamportsToLeave}. Marking low balance.`);
                    await markDepositAddressInactiveDB(clientForThisAddress, addrData.wallet_id, true, balanceLamports);
                    await clientForThisAddress.query('COMMIT');
                    continue;
                }

                const sweepPriorityFee = parseInt(process.env.SWEEP_PRIORITY_FEE_MICROLAMPORTS, 10) || 5000;
                const sweepComputeUnits = parseInt(process.env.SWEEP_COMPUTE_UNIT_LIMIT, 10) || 30000;
                console.log(`${addrLogPrefix} Attempting sendSol. Amount: ${amountToSweep}, PrioFee: ${sweepPriorityFee}, ComputeUnits: ${sweepComputeUnits}`);
                
                const sendResult = await sendSol(depositKeypair, sweepTargetAddress, amountToSweep, `Sweep from ${addrData.public_key.slice(0,4)}..${addrData.public_key.slice(-4)}`, sweepPriorityFee, sweepComputeUnits);

                if (sendResult.success && sendResult.signature) {
                    totalSweptThisCycle += amountToSweep;
                    addressesProcessedThisCycle++;
                    console.log(`✅ ${addrLogPrefix} Sweep successful! TX: ${sendResult.signature}. Amount: ${formatCurrency(amountToSweep, 'SOL')}`);
                    await recordSweepTransactionDB(clientForThisAddress, addrData.public_key, sweepTargetAddress, amountToSweep, sendResult.signature);
                    await markDepositAddressInactiveDB(clientForThisAddress, addrData.wallet_id, true, balanceLamports); 
                } else {
                    console.error(`❌ ${addrLogPrefix} Sweep sendSol FAILED: ${sendResult.error}. Type: ${sendResult.errorType}. Retryable: ${sendResult.isRetryable}`);
                    if (sendResult.errorType === "InsufficientFundsError" || sendResult.isRetryable === false) {
                        await markDepositAddressInactiveDB(clientForThisAddress, addrData.wallet_id, false, balanceLamports); 
                        await clientForThisAddress.query("UPDATE user_deposit_wallets SET notes = COALESCE(notes, '') || ' Sweep Attempt Failed (sendSol): " + escapeMarkdownV2(String(sendResult.error || '')).substring(0,100) + "' WHERE wallet_id = $1", [addrData.wallet_id]);
                    }
                }
                await clientForThisAddress.query('COMMIT');
            } catch (addrError) {
                if (clientForThisAddress) await clientForThisAddress.query('ROLLBACK').catch(rbErr => console.error(`${addrLogPrefix} Rollback error: ${rbErr.message}`));
                console.error(`❌ ${addrLogPrefix} Error processing address ${addrData.public_key}: ${addrError.message}`, addrError.stack?.substring(0,500));
                // Mark as error in DB if possible
                if (clientForThisAddress) { 
                    try { /* ... (error marking logic as before) ... */ } catch {}
                }
            } finally {
                if (clientForThisAddress) clientForThisAddress.release();
            }
            await sleep(sweepAddressDelayMs);
        }
    } catch (cycleError) {
        console.error(`❌ ${logPrefix} Critical error in sweep cycle setup or main query: ${cycleError.message}`, cycleError.stack?.substring(0,500));
        if (typeof notifyAdmin === 'function') await notifyAdmin(`🚨 *ERROR in Fund Sweeping Cycle Setup* 🚨\n\n\`${escapeMarkdownV2(String(cycleError.message || cycleError))}\`\nCheck logs. Sweeping aborted this cycle.`, {parse_mode: 'MarkdownV2'});
    } finally {
        sweepDepositAddresses.isRunning = false;
        if (addressesProcessedThisCycle > 0) {
            const sweptAmountFormatted = formatCurrency(totalSweptThisCycle, 'SOL');
            console.log(`🧹 ${logPrefix} Sweep cycle finished. Swept ~${sweptAmountFormatted} from ${addressesProcessedThisCycle} addresses.`);
            if(typeof notifyAdmin === 'function') await notifyAdmin(`🧹 Sweep Report: Swept approx. ${escapeMarkdownV2(sweptAmountFormatted)} from ${addressesProcessedThisCycle} deposit addresses.`, {parse_mode: 'MarkdownV2'});
        } else if (addressesToConsiderRes && addressesToConsiderRes.rowCount > 0) {
            console.log(`🧹 ${logPrefix} Sweep finished. No funds swept from ${addressesToConsiderRes.rowCount} considered addresses (likely due to low balance or errors during processing).`);
        } else {
            console.log(`🧹 ${logPrefix} Sweep cycle finished. No addresses found needing a sweep in this batch.`);
        }
    }
}

// --- Payout Job Processing Logic ---
// (addPayoutJob, handleWithdrawalPayoutJob, handleReferralPayoutJob functions from original Part P4 remain here)
async function addPayoutJob(jobData) {
    const jobType = jobData?.type || 'unknown_payout';
    const jobId = jobData?.withdrawalId || jobData?.payoutId || jobData?.referralId || 'N/A_JobId';
    const userIdForLog = jobData?.userId || jobData?.referrerUserId || 'N/A_User';
    const logPrefix = `[AddPayoutJob Type:${jobType} ID:${jobId} ForUser:${userIdForLog}]`;

    if (typeof payoutProcessorQueue === 'undefined' || typeof sleep === 'undefined' || typeof notifyAdmin === 'undefined' || typeof escapeMarkdownV2 === 'undefined') {
        console.error(`${logPrefix} 🚨 CRITICAL: Payout queue or essential utilities missing. Cannot add job.`);
        if (typeof notifyAdmin === "function") notifyAdmin(`🚨 CRITICAL Error: Cannot add payout job ${escapeMarkdownV2(jobType)}:${escapeMarkdownV2(String(jobId))}. Payout system compromised.`, {parse_mode: 'MarkdownV2'});
        return;
    }

    payoutProcessorQueue.add(async () => {
        let attempts = 0;
        const maxAttempts = (parseInt(process.env.PAYOUT_JOB_RETRIES, 10) || 3) + 1; // +1 for initial attempt
        const baseDelayMs = parseInt(process.env.PAYOUT_JOB_RETRY_DELAY_MS, 10) || 7000;

        while(attempts < maxAttempts) {
            attempts++;
            const attemptLogPrefix = `[PayoutJob Att:${attempts}/${maxAttempts} ${jobType} ID:${jobId}]`;
            try {
                if (jobData.type === 'payout_withdrawal' && typeof handleWithdrawalPayoutJob === 'function') {
                    await handleWithdrawalPayoutJob(jobData.withdrawalId);
                } else if (jobData.type === 'payout_referral' && typeof handleReferralPayoutJob === 'function') {
                    await handleReferralPayoutJob(jobData.referralId); // Assuming jobData has referralId for this type
                } else {
                    throw new Error(`Unknown or unavailable payout job type handler: ${jobData.type}`);
                }
                console.log(`✅ ${attemptLogPrefix} Job completed successfully.`);
                return; 
            } catch(error) {
                console.warn(`⚠️ ${attemptLogPrefix} Attempt failed: ${error.message}`);
                const isRetryableFlag = error.isRetryable === true; // Job specific errors should set this

                if (!isRetryableFlag || attempts >= maxAttempts) {
                    console.error(`❌ ${attemptLogPrefix} Job failed permanently after ${attempts} attempts. Error: ${error.message}`);
                    if (typeof notifyAdmin === "function") {
                        notifyAdmin(`🚨 *PAYOUT JOB FAILED (Permanent)* 🚨\nType: \`${escapeMarkdownV2(jobType)}\`\nID: \`${escapeMarkdownV2(String(jobId))}\`\nUser: \`${escapeMarkdownV2(String(userIdForLog))}\`\nError: \`${escapeMarkdownV2(String(error.message || error))}\`\nManual intervention may be required.`, {parse_mode:'MarkdownV2'}).catch(()=>{});
                    }
                    return; 
                }
                const delayWithJitter = baseDelayMs * Math.pow(1.5, attempts - 1) * (0.8 + Math.random() * 0.4); // Exponential backoff with jitter
                const actualDelay = Math.min(delayWithJitter, parseInt(process.env.RPC_RETRY_MAX_DELAY, 10) || 90000); // Max delay from env or 90s
                await sleep(actualDelay);
            }
        }
    }).catch(queueError => { // Catch errors from adding to queue or if the promise from add itself rejects (e.g. from PQueue timeout)
        console.error(`❌ ${logPrefix} CRITICAL Error in Payout Queue execution or job addition: ${queueError.message}`, queueError.stack?.substring(0,500));
        if (typeof notifyAdmin === "function") {
            notifyAdmin(`🚨 *CRITICAL Payout Queue Error* 🚨\nJob: \`${escapeMarkdownV2(jobType)}:${escapeMarkdownV2(String(jobId))}\`\nError: \`${escapeMarkdownV2(String(queueError.message || queueError))}\`\nQueue potentially compromised.`, {parse_mode:'MarkdownV2'}).catch(()=>{});
        }
    });
}

async function handleWithdrawalPayoutJob(withdrawalId) {
    const logPrefix = `[WithdrawJob_HTML ID:${withdrawalId}]`; // Added HTML to log prefix
    console.log(`⚙️ ${logPrefix} Processing withdrawal payout...`);
    let clientForDb = null;
    // Initialize sendSolResult to ensure error.isRetryable can be checked even if sendSol is not reached
    let sendSolResult = { success: false, error: "Send SOL not initiated", isRetryable: false, signature: null, blockTime: null }; 
    const payerKeypair = MAIN_BOT_KEYPAIR; 

    const details = await getWithdrawalDetailsDB(withdrawalId);
    if (!details) {
        const error = new Error(`Withdrawal details not found for ID ${withdrawalId}. Job cannot proceed.`);
        error.isRetryable = false; // This error is not typically retryable for the job
        console.error(`${logPrefix} ${error.message}`);
        // Optionally, update DB to a specific error state if details are missing, though this job might not run again if error is thrown.
        // This depends on how your job queue handles thrown errors vs. explicit retry flags.
        throw error;
    }

    // If already in a final state, don't re-process.
    if (details.status === 'completed' || details.status === 'confirmed' || details.status === 'sent') {
        console.log(`ℹ️ ${logPrefix} Withdrawal already in a final state (${details.status}). Skipping.`);
        return; 
    }
    // If it previously failed and the failure was marked as non-retryable by sendSol, don't try again.
    // The isRetryable flag on jobError (thrown at the end) controls queue retries.
    if (details.status === 'failed' /* && specific non-retryable error was logged previously */) {
        // This check might be too simple. The job queue's retry mechanism based on thrown error.isRetryable is better.
        // For now, if it's 'failed', we might only proceed if a retry is explicitly desired or if the error type was transient.
        // The current job queue retries based on thrown errors. If it gets here, it's a new attempt.
        console.log(`ℹ️ ${logPrefix} Withdrawal previously marked 'failed'. This is attempt #${(jobData?.attempts || 0) + 1}. Proceeding.`);
    }

    const userId = String(details.user_telegram_id);
    const recipient = details.destination_address;
    const amountToActuallySend = BigInt(details.amount_lamports); // Amount user receives
    const feeApplied = BigInt(details.fee_lamports); // Fee deducted from user's balance initially
    const totalAmountDebitedFromUser = amountToActuallySend + feeApplied; // This was already taken from user balance

    const userForNotif = await getOrCreateUser(userId); 
    // Ensure playerRefHTML is HTML-escaped for use in HTML messages
    const playerRefHTML = escapeHTML(getPlayerDisplayReference(userForNotif || {id:userId, first_name:"Player"}));

    // Phase 1: Mark as 'processing'
    try {
        clientForDb = await pool.connect();
        await clientForDb.query('BEGIN');
        await updateWithdrawalStatusDB(clientForDb, withdrawalId, 'processing', null, null, null); // No sig/err/blocktime yet
        await clientForDb.query('COMMIT');
        console.log(`${logPrefix} Marked withdrawal as 'processing' in DB.`);
    } catch (dbError) {
        if (clientForDb) await clientForDb.query('ROLLBACK').catch(rbErr => console.error(`${logPrefix} DB Rollback Error setting 'processing': ${rbErr.message}`));
        console.error(`❌ ${logPrefix} DB error setting status to 'processing': ${dbError.message}`);
        const jobError = new Error(`DB error pre-send: ${dbError.message}`); 
        jobError.isRetryable = true; // DB errors are often retryable
        throw jobError; 
    } finally {
        if (clientForDb) clientForDb.release();
        clientForDb = null; 
    }

    // Phase 2: Attempt SOL transfer
    try {
        sendSolResult = await sendSol(
            payerKeypair, 
            recipient, 
            amountToActuallySend, 
            `Withdrawal ID ${withdrawalId} from ${BOT_NAME}`, 
            details.priority_fee_microlamports, 
            details.compute_unit_limit
        ); 

        clientForDb = await pool.connect(); 
        await clientForDb.query('BEGIN');

        if (sendSolResult.success && sendSolResult.signature) {
            console.log(`✅ ${logPrefix} sendSol successful. TX: ${sendSolResult.signature}. Marking 'completed'.`);
            
            const finalSignature = sendSolResult.signature; // String
            const finalBlockTime = (typeof sendSolResult.blockTime === 'number') ? sendSolResult.blockTime : null;
            const finalErrorMessage = null; 

            await updateWithdrawalStatusDB(clientForDb, withdrawalId, 'completed', finalSignature, finalErrorMessage, finalBlockTime);
            
            await clientForDb.query('COMMIT');
            console.log(`✅ ${logPrefix} Withdrawal ID ${withdrawalId} successfully marked 'completed' in DB.`);
            
            const successMsgHTML = `💸 <b>Withdrawal Sent Successfully, ${playerRefHTML}!</b> 💸\n\n` +
                                 `Your withdrawal of <b>${escapeHTML(formatCurrency(amountToActuallySend, 'SOL'))}</b> to wallet <code>${escapeHTML(recipient)}</code> has been processed.\n` +
                                 `🧾 Transaction ID: <a href="https://solscan.io/tx/${escapeHTML(sendSolResult.signature)}">${escapeHTML(sendSolResult.signature)}</a>\n\n` +
                                 `Funds should arrive shortly depending on network confirmations. Thank you for playing at ${escapeHTML(BOT_NAME)}!`;
            await safeSendMessage(userId, successMsgHTML, { parse_mode: 'HTML', disable_web_page_preview: true });
            return; // Successful completion of the job
        } else { 
            // sendSol failed
            const sendErrorMsg = sendSolResult.error || 'Unknown sendSol failure.';
            console.error(`❌ ${logPrefix} sendSol FAILED for withdrawal ID ${withdrawalId}. Reason: ${sendErrorMsg}. Type: ${sendSolResult.errorType}. Retryable: ${sendSolResult.isRetryable}`);
            
            // Mark as failed in DB
            await updateWithdrawalStatusDB(clientForDb, withdrawalId, 'failed', null, sendErrorMsg.substring(0, 250), null);
            
            // Refund the user (since balance was already debited when request was confirmed)
            console.log(`${logPrefix} sendSol failed. Attempting to refund ${totalAmountDebitedFromUser} lamports to user ${userId}.`);
            const refundNotes = `Refund for failed withdrawal ID ${withdrawalId}. Send Error: ${sendErrorMsg.substring(0,100)}`;
            const refundUpdateResult = await updateUserBalanceAndLedger( 
                clientForDb, userId, totalAmountDebitedFromUser, // Credit back the full amount
                'withdrawal_refund', { withdrawal_id: withdrawalId }, refundNotes
            );

            if (refundUpdateResult.success) {
                await clientForDb.query('COMMIT');
                console.log(`✅ ${logPrefix} Successfully refunded ${formatCurrency(totalAmountDebitedFromUser, 'SOL')} to user ${userId}.`);
                const failureMsgHTML = `⚠️ <b>Withdrawal Failed</b> ⚠️\n\n${playerRefHTML}, your withdrawal of <b>${escapeHTML(formatCurrency(amountToActuallySend, 'SOL'))}</b> could not be processed at this time (Reason: <code>${escapeHTML(sendErrorMsg)}</code>).\n` +
                                     `The full amount of <b>${escapeHTML(formatCurrency(totalAmountDebitedFromUser, 'SOL'))}</b> (which was reserved for this withdrawal, including fees) has been refunded to your casino balance.`;
                await safeSendMessage(userId, failureMsgHTML, {parse_mode: 'HTML'});
            } else {
                await clientForDb.query('ROLLBACK');
                console.error(`❌ CRITICAL ${logPrefix} FAILED TO REFUND USER ${userId} for withdrawal ${withdrawalId}. Amount: ${formatCurrency(totalAmountDebitedFromUser, 'SOL')}. Refund DB Error: ${refundUpdateResult.error}`);
                if (typeof notifyAdmin === 'function') {
                    notifyAdmin(`🚨🚨 *CRITICAL: FAILED WITHDRAWAL REFUND* 🚨🚨\nUser: ${playerRefHTML} (<code>${escapeHTML(String(userId))}</code>)\nWD ID: <code>${withdrawalId}</code>\nAmount Due (Refund): <code>${escapeHTML(formatCurrency(totalAmountDebitedFromUser, 'SOL'))}</code>\nSend Error: <code>${escapeHTML(sendErrorMsg)}</code>\nRefund DB Error: <code>${escapeHTML(refundUpdateResult.error || 'Unknown')}</code>\nMANUAL INTERVENTION REQUIRED.`, {parse_mode:'HTML'});
                }
            }
            
            const errorToThrowForRetry = new Error(sendErrorMsg);
            errorToThrowForRetry.isRetryable = sendSolResult.isRetryable === true; 
            throw errorToThrowForRetry; // This will make the job queue retry if isRetryable is true
        }
    } catch (jobError) { 
        // This catch block handles errors from sendSol OR subsequent DB operations if sendSol succeeded but DB failed
        if (clientForDb && clientForDb.release) { 
             try { await clientForDb.query('ROLLBACK'); } catch(rbErr) { console.error(`${logPrefix} Final rollback error on jobError: ${rbErr.message}`);}
        }
        console.error(`❌ ${logPrefix} Error during withdrawal job ID ${withdrawalId} (Phase 2 - Send/Post-Send DB): ${jobError.message}`, jobError.stack?.substring(0,500));
        
        // Attempt to mark as 'failed' if not already completed, as a last resort.
        const updateClientFinal = await pool.connect();
        try {
            const currentDetailsAfterJobError = await getWithdrawalDetailsDB(withdrawalId, updateClientFinal); 
            if (currentDetailsAfterJobError && currentDetailsAfterJobError.status !== 'completed' && currentDetailsAfterJobError.status !== 'failed') {
                await updateWithdrawalStatusDB(updateClientFinal, withdrawalId, 'failed', null, `Job error: ${String(jobError.message || jobError)}`.substring(0,250), null);
            }
        } catch (finalStatusUpdateError) {
            console.error(`${logPrefix} Failed to update status to 'failed' after job error (Phase 2): ${finalStatusUpdateError.message}`);
        } finally {
            updateClientFinal.release();
        }
        
        // Ensure the error re-thrown to the job queue has the correct retry flag
        if (jobError.isRetryable === undefined) { 
            jobError.isRetryable = sendSolResult?.isRetryable || false; // Default to sendSolResult's retryable status or false
        }
        throw jobError; // Re-throw for retry mechanism in addPayoutJob
    } finally {
        if (clientForDb && clientForDb.release) clientForDb.release(); 
    }
}


async function handleReferralPayoutJob(referralDbIdFromJob) { // Renamed parameter for clarity
    const referralId = referralDbIdFromJob; // Use the passed ID directly
    const logPrefix = `[ReferralPayoutJob ID:${referralId}]`;
    console.log(`⚙️ ${logPrefix} Processing referral payout for referral_id: ${referralId}...`);
    
    let clientForDb = null;
    // Initialize sendSolResult to ensure error.isRetryable can be checked
    let sendSolResult = { success: false, error: "Send SOL not initiated for referral", isRetryable: false, signature: null };
    const payerKeypair = REFERRAL_PAYOUT_KEYPAIR || MAIN_BOT_KEYPAIR;

    if (!payerKeypair) {
        const criticalError = new Error("CRITICAL: Payer keypair (REFERRAL_PAYOUT_KEYPAIR or MAIN_BOT_KEYPAIR) is not configured. Cannot process referral payout.");
        console.error(`❌ ${logPrefix} ${criticalError.message}`);
        criticalError.isRetryable = false; // This is a config error, not retryable by the job
        // Update status to failed in DB
        const errClient = await pool.connect();
        try {
            await updateReferralPayoutStatusDB(errClient, referralId, 'failed', null, "Referral payout system keypair missing.");
        } catch(e){ console.error(`${logPrefix} DB error marking payout as failed due to missing keypair: ${e.message}`);}
        finally { errClient.release(); }
        throw criticalError;
    }

    const details = await getReferralDetailsDB(referralId); // from Part P2
    if (!details) {
        const error = new Error(`Referral payout details not found for ID ${referralId}. Job cannot proceed.`);
        error.isRetryable = false; // If details are gone, retrying won't help
        console.error(`${logPrefix} ${error.message}`);
        throw error;
    }

    // Check status before proceeding
    if (details.status === 'paid_out') {
        console.log(`ℹ️ ${logPrefix} Referral ID ${referralId} already marked 'paid_out'. Skipping.`);
        return; // Successfully completed previously
    }
    if (details.status === 'processing' && (Date.now() - new Date(details.updated_at).getTime()) < (10 * 60 * 1000) ) {
        // If recently marked as processing (e.g. < 10 mins ago by another attempt), skip to avoid race.
        console.log(`ℹ️ ${logPrefix} Referral ID ${referralId} currently 'processing' (updated recently). Skipping this attempt.`);
        return;
    }
    // Allow retrying if 'earned' or if 'failed'/'processing' (but old)
    if (details.status !== 'earned' && details.status !== 'failed' && details.status !== 'processing') {
        const statusError = `Referral payout ID ${referralId} is not in 'earned', 'failed', or 'processing' state (current: ${details.status}). Cannot process.`;
        console.warn(`${logPrefix} ${statusError}`);
        const error = new Error(statusError);
        error.isRetryable = false; // Status issue, not typically retryable by job queue unless status can change back to earned
        // No DB update here, as the status is unexpected.
        throw error;
    }

    const referrerUserId = String(details.referrer_telegram_id);
    const amountToPay = BigInt(details.commission_amount_lamports || '0');

    if (amountToPay <= 0n) {
        const zeroErrMsg = `Referral commission for ID ${referralId} is zero or less. Cannot pay.`;
        console.warn(`${logPrefix} ${zeroErrMsg}`);
        const zeroErrClient = await pool.connect();
        try {
            await zeroErrClient.query('BEGIN');
            await updateReferralPayoutStatusDB(zeroErrClient, referralId, 'failed', null, zeroErrMsg.substring(0, 250));
            await zeroErrClient.query('COMMIT');
        } catch(e){
            if(zeroErrClient) await zeroErrClient.query('ROLLBACK');
            console.error(`${logPrefix} DB error marking zero commission as failed: ${e.message}`);
        } finally { if(zeroErrClient) zeroErrClient.release(); }
        const error = new Error(zeroErrMsg); error.isRetryable = false; throw error;
    }

    const userForNotif = await getOrCreateUser(referrerUserId);
    const playerRefHTML = escapeHTML(getPlayerDisplayReference(userForNotif || {id: referrerUserId, first_name:"Referrer"}));

    try {
        clientForDb = await pool.connect();
        await clientForDb.query('BEGIN');

        const referrerDetails = await getPaymentSystemUserDetails(referrerUserId, clientForDb); // from Part P2
        if (!referrerDetails?.solana_wallet_address) {
            const noWalletMsg = `Referrer ${playerRefHTML} (ID: ${referrerUserId}) has no linked SOL wallet for referral payout (Commission ID: ${referralId}). Payout cannot proceed.`;
            console.error(`❌ ${logPrefix} ${noWalletMsg}`);
            await updateReferralPayoutStatusDB(clientForDb, referralId, 'failed', null, "Referrer has no linked wallet.".substring(0, 250));
            await clientForDb.query('COMMIT'); // Commit the 'failed' status
            safeSendMessage(referrerUserId, `⚠️ Action Required: We tried to send you a referral bonus, but you don't have a withdrawal wallet linked. Please link one via \`/setwallet YOUR_ADDRESS\` in DM, then contact support regarding referral ID ${referralId}.`, {parse_mode:'MarkdownV2'}).catch(()=>{});
            const error = new Error(noWalletMsg); error.isRetryable = false; throw error;
        }
        const recipientAddress = referrerDetails.solana_wallet_address;

        // Mark as 'processing' before attempting sendSol
        await updateReferralPayoutStatusDB(clientForDb, referralId, 'processing');
        await clientForDb.query('COMMIT'); // Commit 'processing' state
    } catch (dbProcError) {
        if (clientForDb) await clientForDb.query('ROLLBACK').catch(rbErr => console.error(`${logPrefix} DB Rollback Error setting 'processing': ${rbErr.message}`));
        console.error(`${logPrefix} DB error setting status to 'processing': ${dbProcError.message}`);
        const jobError = new Error(`DB error pre-send for referral payout: ${dbProcError.message}`);
        jobError.isRetryable = true; // DB errors are often retryable
        throw jobError;
    } finally {
        if (clientForDb) clientForDb.release();
        clientForDb = null; // Nullify to re-acquire for next transaction block
    }

    // Attempt SOL transfer
    try {
        sendSolResult = await sendSol(
            payerKeypair,
            recipientAddress,
            amountToPay,
            `Referral Bonus - ${BOT_NAME} - Commission ID: ${referralId}`
            // Assuming sendSol uses default priority fees from env for referrals
        );

        clientForDb = await pool.connect();
        await clientForDb.query('BEGIN');

        if (sendSolResult.success && sendSolResult.signature) {
            console.log(`✅ ${logPrefix} sendSol successful for referral ID ${referralId}. TX: ${sendSolResult.signature}.`);
            await updateReferralPayoutStatusDB(clientForDb, referralId, 'paid_out', sendSolResult.signature);

            // NEW: Update total_referral_earnings_paid_lamports for the referrer
            await clientForDb.query(
                `UPDATE users SET total_referral_earnings_paid_lamports = total_referral_earnings_paid_lamports + $1, updated_at = NOW() WHERE telegram_id = $2`,
                [amountToPay.toString(), referrerUserId]
            );
            console.log(`${logPrefix} Updated total_referral_earnings_paid_lamports for referrer ${referrerUserId} by ${amountToPay}.`);

            await clientForDb.query('COMMIT');

            safeSendMessage(referrerUserId,
                `🎁 *Referral Bonus Paid Out!* 🎁\n\n` +
                `Hey ${playerRefHTML}, your referral commission of *${escapeMarkdownV2(formatCurrency(amountToPay, 'SOL'))}* (approx. ${escapeMarkdownV2(await formatBalanceForDisplay(amountToPay, 'USD'))}) has been sent to your linked wallet: \`${escapeMarkdownV2(recipientAddress)}\`.\n` +
                `🧾 Transaction: [View on Solscan](https://solscan.io/tx/${escapeMarkdownV2(sendSolResult.signature)})\n\n` +
                `Keep up the great work! ✨`,
                { parse_mode: 'MarkdownV2', disable_web_page_preview: true }
            ).catch(e => console.warn(`${LOG_PREFIX_PAYOUT} Failed to send successful referral payout DM to ${referrerUserId}: ${e.message}`));
            return; // Job successful
        } else {
            // sendSol failed
            const sendErrorMsg = sendSolResult.error || 'Unknown sendSol failure for referral payout.';
            console.error(`❌ ${logPrefix} sendSol FAILED for referral payout ID ${referralId}. Reason: ${sendErrorMsg}`);
            
            // Mark as failed in DB (still within this new transaction block)
            await updateReferralPayoutStatusDB(clientForDb, referralId, 'failed', null, sendErrorMsg.substring(0, 250));
            await clientForDb.query('COMMIT'); // Commit the 'failed' status update

            safeSendMessage(referrerUserId,
                `⚠️ *Referral Payout Issue*\n\n${playerRefHTML}, we encountered an issue sending your referral reward of *${escapeMarkdownV2(formatCurrency(amountToPay, 'SOL'))}* (Details: \`${escapeMarkdownV2(sendErrorMsg)}\`).\n`+
                `Our team will review this. If the issue persists, please contact support with Commission ID \`${referralId}\`.`,
                { parse_mode: 'MarkdownV2' }
            ).catch(e => console.warn(`${LOG_PREFIX_PAYOUT} Failed to send referral payout failure DM to ${referrerUserId}: ${e.message}`));

            if (typeof notifyAdmin === 'function') {
                notifyAdmin(`🚨 *REFERRAL PAYOUT FAILED (Send Error)* 🚨\nReferrer: ${playerRefHTML} (\`${escapeMarkdownV2(referrerUserId)}\`)\nComm. ID: \`${referralId}\`\nAmount: \`${escapeMarkdownV2(formatCurrency(amountToPay, 'SOL'))}\`\nError: \`${escapeMarkdownV2(sendErrorMsg)}\`.`, { parse_mode: 'MarkdownV2' });
            }
            
            const errorToThrowForRetry = new Error(sendErrorMsg);
            errorToThrowForRetry.isRetryable = sendSolResult.isRetryable === true;
            throw errorToThrowForRetry; // Let addPayoutJob handle retry logic
        }
    } catch (jobError) {
        if (clientForDb) {
            try { await clientForDb.query('ROLLBACK'); } catch (rbErr) { console.error(`${logPrefix} Final rollback error: ${rbErr.message}`); }
        }
        console.error(`❌ ${logPrefix} Error during referral payout job (send/post-send DB) for ID ${referralId}: ${jobError.message}`, jobError.stack?.substring(0, 500));

        // Attempt to mark as 'failed' if not already done and status is still 'processing'
        const updateFailClient = await pool.connect();
        try {
            const currentDetailsAfterJobError = await getReferralDetailsDB(referralId, updateFailClient);
            if (currentDetailsAfterJobError && currentDetailsAfterJobError.status === 'processing') {
                 await updateReferralPayoutStatusDB(updateFailClient, referralId, 'failed', null, `Job error: ${String(jobError.message || jobError).substring(0,200)}`);
            }
        } catch (finalStatusUpdateError) {
            console.error(`${logPrefix} Failed to update referral status to 'failed' after job error: ${finalStatusUpdateError.message}`);
        } finally {
            if (updateFailClient) updateFailClient.release();
        }
        
        // Ensure the error re-thrown to the job queue has the correct retry flag
        if (jobError.isRetryable === undefined) {
            jobError.isRetryable = sendSolResult?.isRetryable || false; // Default to sendSolResult's flag
        }
        throw jobError;
    } finally {
        if (clientForDb) clientForDb.release();
    }
}

// Add this entire block of code to Part P4 in your index.js

// ===================================================================
// --- NEW: LITECOIN PAYMENT SYSTEM - BACKGROUND TASKS & PROCESSING ---
// ===================================================================

async function processLitecoinTransaction(txHash, depositAddress, walletDbId) {
    const logPrefix = `[ProcessLTC_TX HASH:${txHash.slice(0, 10)}]`;
    console.log(`${logPrefix} Processing potential LTC deposit...`);
    let client = null;

    try {
        const addrInfo = await findLtcDepositAddressInfoDB(depositAddress);
        if (!addrInfo || !addrInfo.userId) {
            console.warn(`${logPrefix} No matching user/address info found for ${depositAddress}.`);
            return;
        }
        const { userId } = addrInfo;

        const txDetailsUrl = `${process.env.LITECOIN_API_BASE_URL}/txs/${txHash}`;
        const txResponse = await axios.get(txDetailsUrl, { params: { token: process.env.BLOCKCYPHER_API_TOKEN } });

        if (!txResponse.data || !txResponse.data.outputs) {
            throw new Error("Invalid transaction data from API.");
        }

        let amountInLitoshis = 0n;
        for (const output of txResponse.data.outputs) {
            if (output.addresses && output.addresses.includes(depositAddress)) {
                amountInLitoshis += BigInt(output.value);
            }
        }

        if (amountInLitoshis <= 0n) {
            console.log(`${logPrefix} No positive transfer amount found for this address in TX.`);
            return;
        }

        client = await pool.connect();
        await client.query('BEGIN');

        const depositRecordResult = await recordConfirmedLtcDepositDB(client, userId, walletDbId, depositAddress, txHash, amountInLitoshis);
        if (depositRecordResult.alreadyProcessed) {
            await client.query('ROLLBACK');
            return;
        }
        if (!depositRecordResult.success) throw new Error(depositRecordResult.error);
        
        // --- Convert LTC value to SOL lamports for main balance ---
        const ltcUsdPrice = await getLtcUsdPrice();
        const solUsdPrice = await getSolUsdPrice();
        const depositUsdValue = (Number(amountInLitoshis) / LITOSHIS_PER_LTC) * ltcUsdPrice;
        const equivalentLamports = convertUSDToLamports(depositUsdValue, solUsdPrice);

        const balanceUpdateResult = await updateUserBalanceAndLedger(client, userId, equivalentLamports, 'deposit_ltc', { ltc_deposit_id: depositRecordResult.depositId });
        if (!balanceUpdateResult.success) throw new Error(balanceUpdateResult.error);

        await client.query('COMMIT');

        // --- Notify User ---
        const userForNotif = await getOrCreateUser(userId);
        const playerRefHTML = escapeHTML(getPlayerDisplayReference(userForNotif));
        const newBalanceUSD = await formatBalanceForDisplay(balanceUpdateResult.newBalanceLamports, 'USD');
        const depositAmountLTC = (Number(amountInLitoshis) / LITOSHIS_PER_LTC).toFixed(8);

        const successMsg = `✅ <b>Litecoin Deposit Confirmed!</b>\n\n` +
                         `Your deposit of <b>${depositAmountLTC} LTC</b> (approx. $${depositUsdValue.toFixed(2)} USD) has been credited to your balance.\n\n` +
                         `💰 Your New Balance: <b>${newBalanceUSD}</b>`;
        await safeSendMessage(userId, successMsg, { parse_mode: 'HTML' });

    } catch (error) {
        if (client) await client.query('ROLLBACK');
        console.error(`${logPrefix} CRITICAL ERROR: ${error.message}`);
        if(typeof notifyAdmin === 'function') await notifyAdmin(`🚨 CRITICAL LTC Deposit Processing Error 🚨\nTX: ${txHash}\nError: ${escapeHTML(error.message)}`, {parse_mode: 'HTML'});
    } finally {
        if (client) client.release();
    }
}

// These are new database helper functions you need
async function findLtcDepositAddressInfoDB(depositAddress) {
    const res = await queryDatabase('SELECT user_telegram_id, wallet_id FROM ltc_user_deposit_wallets WHERE address = $1 AND is_active = TRUE', [depositAddress]);
    if (res.rows.length > 0) return { userId: String(res.rows[0].user_telegram_id), walletId: res.rows[0].wallet_id };
    return null;
}

async function recordConfirmedLtcDepositDB(dbClient, userId, walletId, address, txHash, amountLitoshis) {
    const query = `INSERT INTO ltc_deposits (user_telegram_id, ltc_user_deposit_wallet_id, deposit_address, transaction_hash, amount_litoshis, processed_at) VALUES ($1, $2, $3, $4, $5, NOW()) ON CONFLICT (transaction_hash) DO NOTHING RETURNING deposit_id;`;
    const res = await dbClient.query(query, [userId, walletId, address, txHash, amountLitoshis.toString()]);
    if (res.rowCount > 0) return { success: true, depositId: res.rows[0].deposit_id };
    return { success: false, alreadyProcessed: true };
}

// --- NEW: LITECOIN DEPOSIT & SWEEP BACKGROUND TASKS ---
// Add this entire block to Part P4 in your index.js

const processedLtcTxs = new Set(); // In-memory cache to prevent double-processing

/**
 * Starts the polling process for monitoring Litecoin deposits.
 */
function startLitecoinDepositMonitoring() {
    const intervalMs = parseInt(process.env.LTC_DEPOSIT_MONITOR_INTERVAL_MS, 10) || 300000;
    if (isNaN(intervalMs) || intervalMs <= 10000) {
        console.warn("⚠️ [LTC Monitor] Invalid or too frequent interval. Monitoring disabled.");
        return;
    }

    console.log(`⚙️ [LTC Monitor] Starting Litecoin Deposit Monitor (Interval: ${intervalMs / 1000}s)...`);
    
    // Initial run after a short delay
    setTimeout(() => {
        if (!isShuttingDown) monitorLitecoinDeposits();
    }, 10000);

    ltcDepositMonitorIntervalId = setInterval(() => {
        if (!isShuttingDown) monitorLitecoinDeposits();
    }, intervalMs);
}

/**
 * Stops the Litecoin deposit monitoring interval.
 */
function stopLitecoinDepositMonitoring() {
    if (ltcDepositMonitorIntervalId) {
        clearInterval(ltcDepositMonitorIntervalId);
        console.log("🛑 [LTC Monitor] Litecoin deposit monitoring stopped.");
    }
}

/**
 * The main polling function that checks for new Litecoin transactions.
 */
async function monitorLitecoinDeposits() {
    const logPrefix = '[LTC Monitor Polling]';
    if (monitorLitecoinDeposits.isRunning) return;
    monitorLitecoinDeposits.isRunning = true;

    try {
        const activeLtcAddresses = await queryDatabase(
            `SELECT wallet_id, address, user_telegram_id FROM ltc_user_deposit_wallets WHERE is_active = TRUE AND expires_at > NOW() LIMIT 50`
        );

        if (activeLtcAddresses.rowCount === 0) {
            monitorLitecoinDeposits.isRunning = false;
            return;
        }

        for (const wallet of activeLtcAddresses.rows) {
            try {
                const url = `${LITECOIN_API_BASE_URL}/addrs/${wallet.address}/full`;
                const response = await axios.get(url, { params: { token: LITECOIN_API_TOKEN }});

                if (response.data && response.data.txs) {
                    for (const tx of response.data.txs) {
                        if (!processedLtcTxs.has(tx.tx_hash) && (tx.confirmations || 0) >= LTC_DEPOSIT_CONFIRMATIONS) {
                            processedLtcTxs.add(tx.tx_hash);
                            console.log(`${logPrefix} Found confirmed LTC tx ${tx.tx_hash} for address ${wallet.address}. Queuing for processing.`);
                            // Here you would call your processing function
                            // For simplicity, we'll process directly, but a queue is better for production
                            await processLitecoinTransaction(tx.tx_hash, wallet.address, wallet.wallet_id, wallet.user_telegram_id);
                        }
                    }
                }
            } catch (error) {
                if (!error.response || error.response.status !== 404) {
                   console.error(`${logPrefix} Error checking address ${wallet.address}: ${error.message}`);
                }
            }
            await sleep(1000); // Rate limit API calls
        }
    } catch (e) {
        console.error(`${logPrefix} Major error in polling loop: ${e.message}`);
    } finally {
        monitorLitecoinDeposits.isRunning = false;
    }
}

/**
 * Starts the process for sweeping funds from deposit addresses.
 */
function startLitecoinSweepingProcess() {
    const intervalMs = parseInt(process.env.LTC_SWEEP_INTERVAL_MS, 10) || 3600000;
    console.log(`⚙️ [LTC Sweeper] Starting Litecoin Fund Sweeper (Interval: ${intervalMs / 1000 / 60} minutes)...`);
    
    setTimeout(() => {
        if (!isShuttingDown) sweepLitecoinAddresses();
    }, 30000); // Initial delay

    ltcSweepIntervalId = setInterval(() => {
        if (!isShuttingDown) sweepLitecoinAddresses();
    }, intervalMs);
}

/**
 * Stops the Litecoin sweeping interval.
 */
function stopLitecoinSweepingProcess() {
    if (ltcSweepIntervalId) {
        clearInterval(ltcSweepIntervalId);
        console.log("🛑 [LTC Sweeper] Litecoin sweeping stopped.");
    }
}

/**
 * The main function to find and sweep funds from LTC addresses.
 */
async function sweepLitecoinAddresses() {
    const logPrefix = '[LTC SweepAddresses]';
    if (sweepLitecoinAddresses.isRunning) return;
    sweepLitecoinAddresses.isRunning = true;
    console.log(`🧹 ${logPrefix} Starting new LTC sweep cycle...`);

    try {
        const addressesToSweep = await queryDatabase(
            `SELECT wallet_id, address, derivation_path, balance_at_sweep FROM ltc_user_deposit_wallets WHERE swept_at IS NULL AND is_active = FALSE AND balance_at_sweep > 0 LIMIT 10`
        );

        if (addressesToSweep.rowCount === 0) {
            console.log(`${logPrefix} No LTC addresses to sweep in this cycle.`);
            return;
        }

        for (const addr of addressesToSweep.rows) {
            try {
                const { keyPair } = deriveLitecoinAddress(process.env.LITECOIN_MASTER_SEED_PHRASE, addr.derivation_path);
                const sweepTxHash = await sweepLitecoinAddress(keyPair, process.env.LITECOIN_SWEEP_TARGET_ADDRESS);
                
                await queryDatabase(
                    'UPDATE ltc_user_deposit_wallets SET swept_at = NOW(), notes = $1 WHERE wallet_id = $2',
                    [`Swept in tx: ${sweepTxHash}`, addr.wallet_id]
                );
                console.log(`✅ ${logPrefix} Successfully swept ${addr.address}. TXID: ${sweepTxHash}`);

            } catch (error) {
                console.error(`❌ ${logPrefix} Failed to sweep ${addr.address}: ${error.message}`);
                await queryDatabase(
                    'UPDATE ltc_user_deposit_wallets SET notes = $1 WHERE wallet_id = $2',
                    [`Sweep failed: ${error.message.substring(0, 200)}`, addr.wallet_id]
                );
            }
            await sleep(5000); // Delay between sweeps
        }
    } catch (error) {
        console.error(`❌ ${logPrefix} Critical error in sweep cycle: ${error.message}`);
    } finally {
        sweepLitecoinAddresses.isRunning = false;
    }
}

// --- End of Part P4 ---
